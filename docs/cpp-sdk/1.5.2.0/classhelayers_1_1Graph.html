<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17" />
    <title>HElayers SDK: helayers::Graph Class Reference</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;1,700&family=Merriweather&family=Merriweather+Sans&family=Open+Sans&family=Poppins:ital@1&family=Roboto:ital,wght@0,400;1,300;1,900&display=swap"
        rel="stylesheet">
    <script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/latest/ui-shell.min.js"></script>
</head>
<body style="font-family: 'Merriweather', serif;">
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand">HElayers SDK 1.5.2.0</a>
            </div>
        </div>
    </nav>
    <div id="top">
        <bx-header aria-label="IBM Platform Name">
            <bx-header-menu-button button-label-active="Close menu" button-label-inactive="Open menu">
            </bx-header-menu-button>
            <bx-header-name href="index.html" prefix="IBM">HElayers</bx-header-name>
            <bx-header-nav menu-bar-label="IBM HElayers">
                <bx-header-nav-item href="index.html">Overview
                </bx-header-nav-item>
                <bx-header-menu menu-label="Namespaces" trigger-content="Namespaces">
                    <bx-header-menu-item href="namespaces.html">Namespace List
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Namespace Members" trigger-content="Namespace  Members">
                        <bx-header-menu-item href="namespacemembers.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_enum.html">Enumerations
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_eval.html">Enumerator
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Classes" trigger-content="Classes">
                    <bx-header-menu-item href="annotated.html">Class List
                    </bx-header-menu-item>
                    <bx-header-menu-item href="classes.html">Class Index
                    </bx-header-menu-item>
                    <bx-header-menu-item href="inherits.html">Class Hierarchy
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Class Members" trigger-content="Class Members">
                        <bx-header-menu-item href="functions.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Variables
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_enum.html">Enumerations
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Files" trigger-content="Files">
                    <bx-header-menu-item href="files.html">File List</bx-header-menu-item>
                </bx-header-menu>
            </bx-header-nav>
        </bx-header>
        <!-- do not remove this div, it is closed by doxygen! -->
        <!-- end header part --><!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehelayers.html">helayers</a></li><li class="navelem"><a class="el" href="classhelayers_1_1Graph.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhelayers_1_1Graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">helayers::Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class to represent a directed graph with basic operations on it, where nodes are represented as subsequent integers.  
 <a href="classhelayers_1_1Graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Graph_8h_source.html">Graph.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for helayers::Graph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhelayers_1_1Graph.png" usemap="#helayers::Graph_map" alt=""/>
  <map id="helayers::Graph_map" name="helayers::Graph_map">
<area href="classhelayers_1_1SaveableBasic.html" title="Parent class to all objects that can be saved/loaded." alt="helayers::SaveableBasic" shape="rect" coords="0,56,151,80"/>
<area href="classhelayers_1_1Printable.html" title="An abstract class for objects that can be printed to text in a human readable way." alt="helayers::Printable" shape="rect" coords="0,0,151,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a320a9a2b145cf61f4b66df91590bf8a8"><td class="memItemLeft" align="right" valign="top"><a id="a320a9a2b145cf61f4b66df91590bf8a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a320a9a2b145cf61f4b66df91590bf8a8">Graph</a> ()</td></tr>
<tr class="memdesc:a320a9a2b145cf61f4b66df91590bf8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a320a9a2b145cf61f4b66df91590bf8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ac3722f0a20af183a1dc22909b3dd5"><td class="memItemLeft" align="right" valign="top"><a id="a01ac3722f0a20af183a1dc22909b3dd5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a01ac3722f0a20af183a1dc22909b3dd5">~Graph</a> ()=default</td></tr>
<tr class="memdesc:a01ac3722f0a20af183a1dc22909b3dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default destructor. <br /></td></tr>
<tr class="separator:a01ac3722f0a20af183a1dc22909b3dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a8a7fce8c186d4192c5557bc689523"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a82a8a7fce8c186d4192c5557bc689523">Graph</a> (const <a class="el" href="classhelayers_1_1Graph.html">Graph</a> &amp;src)=default</td></tr>
<tr class="memdesc:a82a8a7fce8c186d4192c5557bc689523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="classhelayers_1_1Graph.html#a82a8a7fce8c186d4192c5557bc689523">More...</a><br /></td></tr>
<tr class="separator:a82a8a7fce8c186d4192c5557bc689523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873bbc4c2ec26869f9141079fb56e06c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a873bbc4c2ec26869f9141079fb56e06c">operator=</a> (const <a class="el" href="classhelayers_1_1Graph.html">Graph</a> &amp;src)=default</td></tr>
<tr class="memdesc:a873bbc4c2ec26869f9141079fb56e06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default operator=.  <a href="classhelayers_1_1Graph.html#a873bbc4c2ec26869f9141079fb56e06c">More...</a><br /></td></tr>
<tr class="separator:a873bbc4c2ec26869f9141079fb56e06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81b7f13e90d1a59c6f4cc60c67a09d3"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#aa81b7f13e90d1a59c6f4cc60c67a09d3">save</a> (std::ostream &amp;stream) const override</td></tr>
<tr class="memdesc:aa81b7f13e90d1a59c6f4cc60c67a09d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves this object to a stream in binary form.  <a href="classhelayers_1_1Graph.html#aa81b7f13e90d1a59c6f4cc60c67a09d3">More...</a><br /></td></tr>
<tr class="separator:aa81b7f13e90d1a59c6f4cc60c67a09d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc9374b5cf31fbb6522701fa0008e4a"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a1cc9374b5cf31fbb6522701fa0008e4a">load</a> (std::istream &amp;stream) override</td></tr>
<tr class="memdesc:a1cc9374b5cf31fbb6522701fa0008e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads this object from the given stream.  <a href="classhelayers_1_1Graph.html#a1cc9374b5cf31fbb6522701fa0008e4a">More...</a><br /></td></tr>
<tr class="separator:a1cc9374b5cf31fbb6522701fa0008e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b0062fed2a84207a04b47e0b1098a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#af9b0062fed2a84207a04b47e0b1098a8">addNode</a> ()</td></tr>
<tr class="memdesc:af9b0062fed2a84207a04b47e0b1098a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new node to the graph.  <a href="classhelayers_1_1Graph.html#af9b0062fed2a84207a04b47e0b1098a8">More...</a><br /></td></tr>
<tr class="separator:af9b0062fed2a84207a04b47e0b1098a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86fcd25db4bc6da43126eb09ccb8aa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#ac86fcd25db4bc6da43126eb09ccb8aa4">addEdge</a> (int src, int dst)</td></tr>
<tr class="memdesc:ac86fcd25db4bc6da43126eb09ccb8aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new directed edge to the graph.  <a href="classhelayers_1_1Graph.html#ac86fcd25db4bc6da43126eb09ccb8aa4">More...</a><br /></td></tr>
<tr class="separator:ac86fcd25db4bc6da43126eb09ccb8aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bc4ea90dc8357cb3630318ba8d4a48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a82bc4ea90dc8357cb3630318ba8d4a48">removeNode</a> (int node)</td></tr>
<tr class="memdesc:a82bc4ea90dc8357cb3630318ba8d4a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an existing node from the graph along with all the edges connected to it.  <a href="classhelayers_1_1Graph.html#a82bc4ea90dc8357cb3630318ba8d4a48">More...</a><br /></td></tr>
<tr class="separator:a82bc4ea90dc8357cb3630318ba8d4a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650a361dd9692161dd7ebeb2469fb8a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a650a361dd9692161dd7ebeb2469fb8a0">removeEdge</a> (int src, int dst)</td></tr>
<tr class="memdesc:a650a361dd9692161dd7ebeb2469fb8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an existing edge from the graph.  <a href="classhelayers_1_1Graph.html#a650a361dd9692161dd7ebeb2469fb8a0">More...</a><br /></td></tr>
<tr class="separator:a650a361dd9692161dd7ebeb2469fb8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e524b0e595dc9776addd94b0dd2959f"><td class="memItemLeft" align="right" valign="top"><a id="a7e524b0e595dc9776addd94b0dd2959f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a7e524b0e595dc9776addd94b0dd2959f">getNumNodes</a> () const</td></tr>
<tr class="memdesc:a7e524b0e595dc9776addd94b0dd2959f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the graph. <br /></td></tr>
<tr class="separator:a7e524b0e595dc9776addd94b0dd2959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179fa7dd00a54ebc48e26ba23ec2b04d"><td class="memItemLeft" align="right" valign="top"><a id="a179fa7dd00a54ebc48e26ba23ec2b04d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a179fa7dd00a54ebc48e26ba23ec2b04d">getNumEdges</a> () const</td></tr>
<tr class="memdesc:a179fa7dd00a54ebc48e26ba23ec2b04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges in the graph. <br /></td></tr>
<tr class="separator:a179fa7dd00a54ebc48e26ba23ec2b04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236d449816d6d8cd3720139696dff71c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a236d449816d6d8cd3720139696dff71c">repositionBefore</a> (int sourceNode, int targetNode)</td></tr>
<tr class="memdesc:a236d449816d6d8cd3720139696dff71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repositions an existing source node in the graph such that it is connected to a given target node.  <a href="classhelayers_1_1Graph.html#a236d449816d6d8cd3720139696dff71c">More...</a><br /></td></tr>
<tr class="separator:a236d449816d6d8cd3720139696dff71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae87647ca69af17381eed93d4072e27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a6ae87647ca69af17381eed93d4072e27">repositionAfter</a> (int sourceNode, int targetNode)</td></tr>
<tr class="memdesc:a6ae87647ca69af17381eed93d4072e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repositions an existing source node in the graph such that a given target node is connected to it.  <a href="classhelayers_1_1Graph.html#a6ae87647ca69af17381eed93d4072e27">More...</a><br /></td></tr>
<tr class="separator:a6ae87647ca69af17381eed93d4072e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6e467fb4490fd74a107c72ba4adb3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#aec6e467fb4490fd74a107c72ba4adb3e">placeBefore</a> (int sourceNode, int targetNode)</td></tr>
<tr class="memdesc:aec6e467fb4490fd74a107c72ba4adb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an existing source node in the graph, that has no neighbours, such that it is connected to a given target node.  <a href="classhelayers_1_1Graph.html#aec6e467fb4490fd74a107c72ba4adb3e">More...</a><br /></td></tr>
<tr class="separator:aec6e467fb4490fd74a107c72ba4adb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcf2a1f68e056b7cd59cccf4b3470b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#aedcf2a1f68e056b7cd59cccf4b3470b2">placeAfter</a> (int sourceNode, int targetNode)</td></tr>
<tr class="memdesc:aedcf2a1f68e056b7cd59cccf4b3470b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an existing source node in the graph, that has no neighbours, such that a given target node is connected to it.  <a href="classhelayers_1_1Graph.html#aedcf2a1f68e056b7cd59cccf4b3470b2">More...</a><br /></td></tr>
<tr class="separator:aedcf2a1f68e056b7cd59cccf4b3470b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dab35d4fcdeab04cccc8eae0d0811e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a20dab35d4fcdeab04cccc8eae0d0811e">bypassNode</a> (int node)</td></tr>
<tr class="memdesc:a20dab35d4fcdeab04cccc8eae0d0811e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the edges entering and leaving an existing node in the graph, and adds new edges between the current neighbours of the node such that the node is "bypassed".  <a href="classhelayers_1_1Graph.html#a20dab35d4fcdeab04cccc8eae0d0811e">More...</a><br /></td></tr>
<tr class="separator:a20dab35d4fcdeab04cccc8eae0d0811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f69a0e29019b164cba3f0200005d456"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a9f69a0e29019b164cba3f0200005d456">getInboundNodes</a> (int node) const</td></tr>
<tr class="memdesc:a9f69a0e29019b164cba3f0200005d456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inbound nodes of a given node in the graph.  <a href="classhelayers_1_1Graph.html#a9f69a0e29019b164cba3f0200005d456">More...</a><br /></td></tr>
<tr class="separator:a9f69a0e29019b164cba3f0200005d456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64783bbad1f66d73a82d609d83387b34"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a64783bbad1f66d73a82d609d83387b34">getOutboundNodes</a> (int node) const</td></tr>
<tr class="memdesc:a64783bbad1f66d73a82d609d83387b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbound nodes of a given node in the graph.  <a href="classhelayers_1_1Graph.html#a64783bbad1f66d73a82d609d83387b34">More...</a><br /></td></tr>
<tr class="separator:a64783bbad1f66d73a82d609d83387b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6001955f42a2000c163ba4ac61d512"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a2f6001955f42a2000c163ba4ac61d512">getInboundNodeIndex</a> (int node, int inboundNode) const</td></tr>
<tr class="memdesc:a2f6001955f42a2000c163ba4ac61d512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns, with respect to a given first node, the index of a given second node that is an inbound node of the first node, in the set of all inbound nodes of the first node.  <a href="classhelayers_1_1Graph.html#a2f6001955f42a2000c163ba4ac61d512">More...</a><br /></td></tr>
<tr class="separator:a2f6001955f42a2000c163ba4ac61d512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ed295307b0b99e696d01e8ad621447"><td class="memItemLeft" align="right" valign="top"><a id="a52ed295307b0b99e696d01e8ad621447"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a52ed295307b0b99e696d01e8ad621447">getTopologicalOrder</a> () const</td></tr>
<tr class="memdesc:a52ed295307b0b99e696d01e8ad621447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a topological order of the nodes in the graph. <br /></td></tr>
<tr class="separator:a52ed295307b0b99e696d01e8ad621447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8742fc9a39d1b944b6bcdfc2c42cd9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#ae8742fc9a39d1b944b6bcdfc2c42cd9f">doAllNodesReachableFrom</a> (int node) const</td></tr>
<tr class="memdesc:ae8742fc9a39d1b944b6bcdfc2c42cd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indication to whether all the nodes in the graph are reachable from a given node, by a directed path of any length.  <a href="classhelayers_1_1Graph.html#ae8742fc9a39d1b944b6bcdfc2c42cd9f">More...</a><br /></td></tr>
<tr class="separator:ae8742fc9a39d1b944b6bcdfc2c42cd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e63d3b7f10a5484c00f017ed61b9a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a68e63d3b7f10a5484c00f017ed61b9a9">doAllNodesReach</a> (int node) const</td></tr>
<tr class="memdesc:a68e63d3b7f10a5484c00f017ed61b9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indication to whether all the nodes in the graph reach a given node, by a directed path of any length.  <a href="classhelayers_1_1Graph.html#a68e63d3b7f10a5484c00f017ed61b9a9">More...</a><br /></td></tr>
<tr class="separator:a68e63d3b7f10a5484c00f017ed61b9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945c4bd5baf42ab299c9040323c0cb43"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Graph.html#a945c4bd5baf42ab299c9040323c0cb43">getReachableNodes</a> (int node, bool reverse=false) const</td></tr>
<tr class="memdesc:a945c4bd5baf42ab299c9040323c0cb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the nodes in the graph reachable from a given node.  <a href="classhelayers_1_1Graph.html#a945c4bd5baf42ab299c9040323c0cb43">More...</a><br /></td></tr>
<tr class="separator:a945c4bd5baf42ab299c9040323c0cb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhelayers_1_1SaveableBasic"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhelayers_1_1SaveableBasic')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhelayers_1_1SaveableBasic.html">helayers::SaveableBasic</a></td></tr>
<tr class="memitem:a358d2b3c4d78745ad008490663c49201 inherit pub_methods_classhelayers_1_1SaveableBasic"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SaveableBasic.html#a358d2b3c4d78745ad008490663c49201">debugPrint</a> (const std::string &amp;title=&quot;&quot;, <a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0a">Verbosity</a> verbosity=<a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0aa9a86dd20fce918c63f5475acbd48bdfb">VERBOSITY_REGULAR</a>, std::ostream &amp;out=std::cout) const override</td></tr>
<tr class="memdesc:a358d2b3c4d78745ad008490663c49201 inherit pub_methods_classhelayers_1_1SaveableBasic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the content of this object.  <a href="classhelayers_1_1SaveableBasic.html#a358d2b3c4d78745ad008490663c49201">More...</a><br /></td></tr>
<tr class="separator:a358d2b3c4d78745ad008490663c49201 inherit pub_methods_classhelayers_1_1SaveableBasic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhelayers_1_1Printable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhelayers_1_1Printable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhelayers_1_1Printable.html">helayers::Printable</a></td></tr>
<tr class="memitem:a367c7b06f92c6c5997b462c55be6e3d1 inherit pub_methods_classhelayers_1_1Printable"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Printable.html#a367c7b06f92c6c5997b462c55be6e3d1">toString</a> (<a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0a">Verbosity</a> verbosity=<a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0aa9a86dd20fce918c63f5475acbd48bdfb">VERBOSITY_REGULAR</a>) const</td></tr>
<tr class="memdesc:a367c7b06f92c6c5997b462c55be6e3d1 inherit pub_methods_classhelayers_1_1Printable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert object to string.  <a href="classhelayers_1_1Printable.html#a367c7b06f92c6c5997b462c55be6e3d1">More...</a><br /></td></tr>
<tr class="separator:a367c7b06f92c6c5997b462c55be6e3d1 inherit pub_methods_classhelayers_1_1Printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class to represent a directed graph with basic operations on it, where nodes are represented as subsequent integers. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a82a8a7fce8c186d4192c5557bc689523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a8a7fce8c186d4192c5557bc689523">&#9670;&nbsp;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">helayers::Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac86fcd25db4bc6da43126eb09ccb8aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86fcd25db4bc6da43126eb09ccb8aa4">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds new directed edge to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source node. </td></tr>
    <tr><td class="paramname">dst</td><td>The destination node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9b0062fed2a84207a04b47e0b1098a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b0062fed2a84207a04b47e0b1098a8">&#9670;&nbsp;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::Graph::addNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds new node to the graph. </p>
<p>The index of it will be the next available integer. </p>

</div>
</div>
<a id="a20dab35d4fcdeab04cccc8eae0d0811e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20dab35d4fcdeab04cccc8eae0d0811e">&#9670;&nbsp;</a></span>bypassNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::Graph::bypassNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the edges entering and leaving an existing node in the graph, and adds new edges between the current neighbours of the node such that the node is "bypassed". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The given node to bypass. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68e63d3b7f10a5484c00f017ed61b9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e63d3b7f10a5484c00f017ed61b9a9">&#9670;&nbsp;</a></span>doAllNodesReach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helayers::Graph::doAllNodesReach </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns indication to whether all the nodes in the graph reach a given node, by a directed path of any length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The given node to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8742fc9a39d1b944b6bcdfc2c42cd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8742fc9a39d1b944b6bcdfc2c42cd9f">&#9670;&nbsp;</a></span>doAllNodesReachableFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helayers::Graph::doAllNodesReachableFrom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns indication to whether all the nodes in the graph are reachable from a given node, by a directed path of any length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The given node to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f6001955f42a2000c163ba4ac61d512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6001955f42a2000c163ba4ac61d512">&#9670;&nbsp;</a></span>getInboundNodeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int helayers::Graph::getInboundNodeIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inboundNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns, with respect to a given first node, the index of a given second node that is an inbound node of the first node, in the set of all inbound nodes of the first node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The first node. </td></tr>
    <tr><td class="paramname">inboundNode</td><td>The second node, must be an inbound node of the first node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f69a0e29019b164cba3f0200005d456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f69a0e29019b164cba3f0200005d456">&#9670;&nbsp;</a></span>getInboundNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;int&gt; helayers::Graph::getInboundNodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inbound nodes of a given node in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The given node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64783bbad1f66d73a82d609d83387b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64783bbad1f66d73a82d609d83387b34">&#9670;&nbsp;</a></span>getOutboundNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;int&gt; helayers::Graph::getOutboundNodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the outbound nodes of a given node in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The given node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a945c4bd5baf42ab299c9040323c0cb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945c4bd5baf42ab299c9040323c0cb43">&#9670;&nbsp;</a></span>getReachableNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;int&gt; helayers::Graph::getReachableNodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all the nodes in the graph reachable from a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The given node to check. </td></tr>
    <tr><td class="paramname">reverse</td><td>Whether to iterate the graph in reverse, such that the direction of every directed edge if flipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cc9374b5cf31fbb6522701fa0008e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc9374b5cf31fbb6522701fa0008e4a">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff helayers::Graph::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads this object from the given stream. </p>
<p>Returns the number of bytes read from the input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>input stream to read from </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1SaveableBasic.html#a8c971cb9770468987fc8690f270268ae">helayers::SaveableBasic</a>.</p>

</div>
</div>
<a id="a873bbc4c2ec26869f9141079fb56e06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873bbc4c2ec26869f9141079fb56e06c">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1Graph.html">Graph</a>&amp; helayers::Graph::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default operator=. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedcf2a1f68e056b7cd59cccf4b3470b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcf2a1f68e056b7cd59cccf4b3470b2">&#9670;&nbsp;</a></span>placeAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::Graph::placeAfter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places an existing source node in the graph, that has no neighbours, such that a given target node is connected to it. </p>
<p>All the edges currently leaving the target node will now be connected to the source node instead. An edge will be added between the target and source nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNode</td><td>The source node to palce. </td></tr>
    <tr><td class="paramname">targetNode</td><td>The target node to palce after. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec6e467fb4490fd74a107c72ba4adb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6e467fb4490fd74a107c72ba4adb3e">&#9670;&nbsp;</a></span>placeBefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::Graph::placeBefore </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places an existing source node in the graph, that has no neighbours, such that it is connected to a given target node. </p>
<p>All the edges currently entering the target node will now be connected to the source node instead. An edge will be added between the source and target nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNode</td><td>The source node to palce. </td></tr>
    <tr><td class="paramname">targetNode</td><td>The target node to palce before. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a650a361dd9692161dd7ebeb2469fb8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650a361dd9692161dd7ebeb2469fb8a0">&#9670;&nbsp;</a></span>removeEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::Graph::removeEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an existing edge from the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source node. </td></tr>
    <tr><td class="paramname">dst</td><td>The destination node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82bc4ea90dc8357cb3630318ba8d4a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bc4ea90dc8357cb3630318ba8d4a48">&#9670;&nbsp;</a></span>removeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::Graph::removeNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an existing node from the graph along with all the edges connected to it. </p>
<p>this operation changes the indexes of nodes in the graph to keep them subsequent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ae87647ca69af17381eed93d4072e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae87647ca69af17381eed93d4072e27">&#9670;&nbsp;</a></span>repositionAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::Graph::repositionAfter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repositions an existing source node in the graph such that a given target node is connected to it. </p>
<p>All the edges currently leaving the source node will now be connected to all the so-far-neighbours of the source node instead, and all the edges currently leaving the target node will now be connected to the source node instead. An edge will be added between the target and source nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNode</td><td>The source node to reposition. </td></tr>
    <tr><td class="paramname">targetNode</td><td>The target node to reposition after. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a236d449816d6d8cd3720139696dff71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236d449816d6d8cd3720139696dff71c">&#9670;&nbsp;</a></span>repositionBefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::Graph::repositionBefore </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repositions an existing source node in the graph such that it is connected to a given target node. </p>
<p>All the edges currently entering the source node will now be connected to all the so-far-neighbours of the source node instead, and all the edges currently entering the target node will now be connected to the source node instead. An edge will be added between the source and target nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNode</td><td>The source node to reposition. </td></tr>
    <tr><td class="paramname">targetNode</td><td>The target node to reposition before. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa81b7f13e90d1a59c6f4cc60c67a09d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81b7f13e90d1a59c6f4cc60c67a09d3">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff helayers::Graph::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves this object to a stream in binary form. </p>
<p>Returns the number of bytes written to the output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>output stream to write to </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1SaveableBasic.html#ab18f669c53f332ed1cbbc4854ae4f64f">helayers::SaveableBasic</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/helayers/hebase/utils/<a class="el" href="Graph_8h_source.html">Graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
