<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17" />
    <title>HElayers SDK: helayers::DoubleTensor Class Reference</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;1,700&family=Merriweather&family=Merriweather+Sans&family=Open+Sans&family=Poppins:ital@1&family=Roboto:ital,wght@0,400;1,300;1,900&display=swap"
        rel="stylesheet">
    <script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/latest/ui-shell.min.js"></script>
</head>
<body style="font-family: 'Merriweather', serif;">
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand">HElayers SDK 1.5.1.0</a>
            </div>
        </div>
    </nav>
    <div id="top">
        <bx-header aria-label="IBM Platform Name">
            <bx-header-menu-button button-label-active="Close menu" button-label-inactive="Open menu">
            </bx-header-menu-button>
            <bx-header-name href="index.html" prefix="IBM">HElayers</bx-header-name>
            <bx-header-nav menu-bar-label="IBM HElayers">
                <bx-header-nav-item href="index.html">Overview
                </bx-header-nav-item>
                <bx-header-menu menu-label="Namespaces" trigger-content="Namespaces">
                    <bx-header-menu-item href="namespaces.html">Namespace List
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Namespace Members" trigger-content="Namespace  Members">
                        <bx-header-menu-item href="namespacemembers.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_enum.html">Enumerations
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_eval.html">Enumerator
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Classes" trigger-content="Classes">
                    <bx-header-menu-item href="annotated.html">Class List
                    </bx-header-menu-item>
                    <bx-header-menu-item href="classes.html">Class Index
                    </bx-header-menu-item>
                    <bx-header-menu-item href="inherits.html">Class Hierarchy
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Class Members" trigger-content="Class Members">
                        <bx-header-menu-item href="functions.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Variables
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_enum.html">Enumerations
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Files" trigger-content="Files">
                    <bx-header-menu-item href="files.html">File List</bx-header-menu-item>
                </bx-header-menu>
            </bx-header-nav>
        </bx-header>
        <!-- do not remove this div, it is closed by doxygen! -->
        <!-- end header part --><!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehelayers.html">helayers</a></li><li class="navelem"><a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classhelayers_1_1DoubleTensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">helayers::DoubleTensor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A thin wrapper over a boost::numeric::ublas::tensor&lt;double&gt; object.  
 <a href="classhelayers_1_1DoubleTensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DoubleTensor_8h_source.html">DoubleTensor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af9daef516ce96d777837a539a0961035"><td class="memItemLeft" align="right" valign="top"><a id="af9daef516ce96d777837a539a0961035"></a>
typedef boost::numeric::ublas::tensor&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#af9daef516ce96d777837a539a0961035">TensorImpl</a></td></tr>
<tr class="memdesc:af9daef516ce96d777837a539a0961035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying type used internally to store the tensor. <br /></td></tr>
<tr class="separator:af9daef516ce96d777837a539a0961035"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af99a229d09f507c97fe60b3c4ea18fd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#af99a229d09f507c97fe60b3c4ea18fd0">DoubleTensor</a> ()</td></tr>
<tr class="memdesc:af99a229d09f507c97fe60b3c4ea18fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty tensor.  <a href="classhelayers_1_1DoubleTensor.html#af99a229d09f507c97fe60b3c4ea18fd0">More...</a><br /></td></tr>
<tr class="separator:af99a229d09f507c97fe60b3c4ea18fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57defd9fb37686ffcadb1fe165c0e11e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a57defd9fb37686ffcadb1fe165c0e11e">DoubleTensor</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html#af9daef516ce96d777837a539a0961035">TensorImpl</a> &amp;src)</td></tr>
<tr class="memdesc:a57defd9fb37686ffcadb1fe165c0e11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct copy of given tensor.  <a href="classhelayers_1_1DoubleTensor.html#a57defd9fb37686ffcadb1fe165c0e11e">More...</a><br /></td></tr>
<tr class="separator:a57defd9fb37686ffcadb1fe165c0e11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8dea2cf9f0a6789d8efd3f4a4ad330"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a3f8dea2cf9f0a6789d8efd3f4a4ad330">DoubleTensor</a> (std::initializer_list&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; shape)</td></tr>
<tr class="memdesc:a3f8dea2cf9f0a6789d8efd3f4a4ad330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zeroed tensor with given shape.  <a href="classhelayers_1_1DoubleTensor.html#a3f8dea2cf9f0a6789d8efd3f4a4ad330">More...</a><br /></td></tr>
<tr class="separator:a3f8dea2cf9f0a6789d8efd3f4a4ad330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16119879d51d90ae7b3b3efb0f4e592"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#aa16119879d51d90ae7b3b3efb0f4e592">DoubleTensor</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;shape)</td></tr>
<tr class="memdesc:aa16119879d51d90ae7b3b3efb0f4e592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zeroed tensor with given shape.  <a href="classhelayers_1_1DoubleTensor.html#aa16119879d51d90ae7b3b3efb0f4e592">More...</a><br /></td></tr>
<tr class="separator:aa16119879d51d90ae7b3b3efb0f4e592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e902beb4bc4207c27bc61682b44d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a36e902beb4bc4207c27bc61682b44d0f">init</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;shape, const std::vector&lt; double &gt; &amp;vals, bool firstOrder=true)</td></tr>
<tr class="memdesc:a36e902beb4bc4207c27bc61682b44d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialized tensor with given shape and values.  <a href="classhelayers_1_1DoubleTensor.html#a36e902beb4bc4207c27bc61682b44d0f">More...</a><br /></td></tr>
<tr class="separator:a36e902beb4bc4207c27bc61682b44d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47705ebbc59fa628b297bfa828ff89e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a47705ebbc59fa628b297bfa828ff89e7">init</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;shape, double val)</td></tr>
<tr class="memdesc:a47705ebbc59fa628b297bfa828ff89e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialized tensor with given shape and value.  <a href="classhelayers_1_1DoubleTensor.html#a47705ebbc59fa628b297bfa828ff89e7">More...</a><br /></td></tr>
<tr class="separator:a47705ebbc59fa628b297bfa828ff89e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62534b3b8cdcd05172b0a249049cdf00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a62534b3b8cdcd05172b0a249049cdf00">reshape</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;shape)</td></tr>
<tr class="memdesc:a62534b3b8cdcd05172b0a249049cdf00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes tensor.  <a href="classhelayers_1_1DoubleTensor.html#a62534b3b8cdcd05172b0a249049cdf00">More...</a><br /></td></tr>
<tr class="separator:a62534b3b8cdcd05172b0a249049cdf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ae127bb4ce1e880686bb39c37aa54d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a71ae127bb4ce1e880686bb39c37aa54d">reshape</a> (std::initializer_list&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; shape)</td></tr>
<tr class="memdesc:a71ae127bb4ce1e880686bb39c37aa54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes tensor.  <a href="classhelayers_1_1DoubleTensor.html#a71ae127bb4ce1e880686bb39c37aa54d">More...</a><br /></td></tr>
<tr class="separator:a71ae127bb4ce1e880686bb39c37aa54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af746ad8d5598bbcc619033eb568e2151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#af746ad8d5598bbcc619033eb568e2151">reorderDims</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;dimOrder)</td></tr>
<tr class="memdesc:af746ad8d5598bbcc619033eb568e2151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the dimensions of this tensor.  <a href="classhelayers_1_1DoubleTensor.html#af746ad8d5598bbcc619033eb568e2151">More...</a><br /></td></tr>
<tr class="separator:af746ad8d5598bbcc619033eb568e2151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c657645680ef5c8ff7e7334e9623981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a1c657645680ef5c8ff7e7334e9623981">init</a> (const std::vector&lt; double &gt; &amp;vals, bool firstOrder=true)</td></tr>
<tr class="memdesc:a1c657645680ef5c8ff7e7334e9623981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates existing tensor with values.  <a href="classhelayers_1_1DoubleTensor.html#a1c657645680ef5c8ff7e7334e9623981">More...</a><br /></td></tr>
<tr class="separator:a1c657645680ef5c8ff7e7334e9623981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840cbe65af87d59f93aaee022828c73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a840cbe65af87d59f93aaee022828c73f">init</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;matrix)</td></tr>
<tr class="memdesc:a840cbe65af87d59f93aaee022828c73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates existing 2D tensor with values from a matrix.  <a href="classhelayers_1_1DoubleTensor.html#a840cbe65af87d59f93aaee022828c73f">More...</a><br /></td></tr>
<tr class="separator:a840cbe65af87d59f93aaee022828c73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6508d952727568309291ef47928e729"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ae6508d952727568309291ef47928e729">init</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html#af9daef516ce96d777837a539a0961035">TensorImpl</a> tensor)</td></tr>
<tr class="memdesc:ae6508d952727568309291ef47928e729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize object with a tensor object of the underlying type.  <a href="classhelayers_1_1DoubleTensor.html#ae6508d952727568309291ef47928e729">More...</a><br /></td></tr>
<tr class="separator:ae6508d952727568309291ef47928e729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b266c36fc95886e769779b75fc2c2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a89b266c36fc95886e769779b75fc2c2c">initRandom</a> ()</td></tr>
<tr class="memdesc:a89b266c36fc95886e769779b75fc2c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates existing tensor with random values in [-0.5, 0.5].  <a href="classhelayers_1_1DoubleTensor.html#a89b266c36fc95886e769779b75fc2c2c">More...</a><br /></td></tr>
<tr class="separator:a89b266c36fc95886e769779b75fc2c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed40a3720291805ff33b9b050716021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a1ed40a3720291805ff33b9b050716021">initRandom</a> (double min, double max, double sparseRate=0)</td></tr>
<tr class="memdesc:a1ed40a3720291805ff33b9b050716021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates existing tensor with random values in the range [min, max)  <a href="classhelayers_1_1DoubleTensor.html#a1ed40a3720291805ff33b9b050716021">More...</a><br /></td></tr>
<tr class="separator:a1ed40a3720291805ff33b9b050716021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863fde6ffbd927646c62cf558e9a71ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a863fde6ffbd927646c62cf558e9a71ba">addDim</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> <a class="el" href="classhelayers_1_1DoubleTensor.html#a585b0b108de4c4c319a5af25395d9511">size</a>=1)</td></tr>
<tr class="memdesc:a863fde6ffbd927646c62cf558e9a71ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new dimension to the tensor.  <a href="classhelayers_1_1DoubleTensor.html#a863fde6ffbd927646c62cf558e9a71ba">More...</a><br /></td></tr>
<tr class="separator:a863fde6ffbd927646c62cf558e9a71ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f97c835fd0289e9ed67b85efe73d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a73f97c835fd0289e9ed67b85efe73d34">resizeDim</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> newSize)</td></tr>
<tr class="memdesc:a73f97c835fd0289e9ed67b85efe73d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes an existing dimension.  <a href="classhelayers_1_1DoubleTensor.html#a73f97c835fd0289e9ed67b85efe73d34">More...</a><br /></td></tr>
<tr class="separator:a73f97c835fd0289e9ed67b85efe73d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6aa5611214bd09d0f5e70da554f2e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#aca6aa5611214bd09d0f5e70da554f2e4">duplicateOverDim</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim)</td></tr>
<tr class="memdesc:aca6aa5611214bd09d0f5e70da554f2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates the values of a specified existing dimension.  <a href="classhelayers_1_1DoubleTensor.html#aca6aa5611214bd09d0f5e70da554f2e4">More...</a><br /></td></tr>
<tr class="separator:aca6aa5611214bd09d0f5e70da554f2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac79c4a3fc2bea6cad6f9a204afbfc8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#aac79c4a3fc2bea6cad6f9a204afbfc8f">argMinOverDim</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim)</td></tr>
<tr class="memdesc:aac79c4a3fc2bea6cad6f9a204afbfc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes arg-min over a given dimension.  <a href="classhelayers_1_1DoubleTensor.html#aac79c4a3fc2bea6cad6f9a204afbfc8f">More...</a><br /></td></tr>
<tr class="separator:aac79c4a3fc2bea6cad6f9a204afbfc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4792edad26fbbed7288f66750f40b43f"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a4792edad26fbbed7288f66750f40b43f">save</a> (std::ostream &amp;stream) const</td></tr>
<tr class="memdesc:a4792edad26fbbed7288f66750f40b43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save this object to a binary stream.  <a href="classhelayers_1_1DoubleTensor.html#a4792edad26fbbed7288f66750f40b43f">More...</a><br /></td></tr>
<tr class="separator:a4792edad26fbbed7288f66750f40b43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae8cf0327799cfd81404e04d42eca29"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a7ae8cf0327799cfd81404e04d42eca29">load</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a7ae8cf0327799cfd81404e04d42eca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load this object from a binary stream.  <a href="classhelayers_1_1DoubleTensor.html#a7ae8cf0327799cfd81404e04d42eca29">More...</a><br /></td></tr>
<tr class="separator:a7ae8cf0327799cfd81404e04d42eca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbab4692249d2946df2771b4795ebe80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#afbab4692249d2946df2771b4795ebe80">nicePrint</a> (std::ostream &amp;out=std::cout, bool withShape=true) const</td></tr>
<tr class="memdesc:afbab4692249d2946df2771b4795ebe80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the tensor nicely formatted.  <a href="classhelayers_1_1DoubleTensor.html#afbab4692249d2946df2771b4795ebe80">More...</a><br /></td></tr>
<tr class="separator:afbab4692249d2946df2771b4795ebe80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7dc56d9220c37e43ec7cc2e1c7c93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a2f7dc56d9220c37e43ec7cc2e1c7c93e">debugPrint</a> (const std::string &amp;title, int verbose=0, std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:a2f7dc56d9220c37e43ec7cc2e1c7c93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints state for debugging.  <a href="classhelayers_1_1DoubleTensor.html#a2f7dc56d9220c37e43ec7cc2e1c7c93e">More...</a><br /></td></tr>
<tr class="separator:a2f7dc56d9220c37e43ec7cc2e1c7c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa583469e98d01bd3dae78f17f7bb94ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#aa583469e98d01bd3dae78f17f7bb94ca">calcConvolution</a> (<a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;res, const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;filters, const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;biases, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> strideX=1, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> strideY=1, const <a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a> &amp;padding=<a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a>()) const</td></tr>
<tr class="memdesc:aa583469e98d01bd3dae78f17f7bb94ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform convolution of this object with filters.  <a href="classhelayers_1_1DoubleTensor.html#aa583469e98d01bd3dae78f17f7bb94ca">More...</a><br /></td></tr>
<tr class="separator:aa583469e98d01bd3dae78f17f7bb94ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab201fa702854ea4c6a825bdb3a475854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ab201fa702854ea4c6a825bdb3a475854">calcSumPooling</a> (<a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;res, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> filterX, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> filterY, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> strideX=1, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> strideY=1, const <a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a> &amp;padding=<a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a>()) const</td></tr>
<tr class="memdesc:ab201fa702854ea4c6a825bdb3a475854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sum-pooling of this object.  <a href="classhelayers_1_1DoubleTensor.html#ab201fa702854ea4c6a825bdb3a475854">More...</a><br /></td></tr>
<tr class="separator:ab201fa702854ea4c6a825bdb3a475854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa073cb593d470a107f257c92df5c69c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#aa073cb593d470a107f257c92df5c69c4">calcAveragePooling</a> (<a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;res, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> filterX, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> filterY, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> strideX=1, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> strideY=1, const <a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a> &amp;padding=<a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a>()) const</td></tr>
<tr class="memdesc:aa073cb593d470a107f257c92df5c69c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform average-pooling of this object.  <a href="classhelayers_1_1DoubleTensor.html#aa073cb593d470a107f257c92df5c69c4">More...</a><br /></td></tr>
<tr class="separator:aa073cb593d470a107f257c92df5c69c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258ed7c71fbce5c0c0130e695f43037b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a258ed7c71fbce5c0c0130e695f43037b">batchNorm</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, const std::vector&lt; double &gt; &amp;means, const std::vector&lt; double &gt; &amp;vars, const std::vector&lt; double &gt; &amp;scales, const std::vector&lt; double &gt; &amp;biases, double eps)</td></tr>
<tr class="memdesc:a258ed7c71fbce5c0c0130e695f43037b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform batch normalization on this object.  <a href="classhelayers_1_1DoubleTensor.html#a258ed7c71fbce5c0c0130e695f43037b">More...</a><br /></td></tr>
<tr class="separator:a258ed7c71fbce5c0c0130e695f43037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbab8d3eed5ddd7c924dbc52c407ca9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#adbab8d3eed5ddd7c924dbc52c407ca9d">flattenConvolutionOutput</a> (bool channelsLast)</td></tr>
<tr class="memdesc:adbab8d3eed5ddd7c924dbc52c407ca9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens a 4D tensor that is an output of a convolution operation into 3D tensor with sizes [dim0 x dim1 x dim2, 1, dim3], where dimX is the size of dimension X of the original tensor.  <a href="classhelayers_1_1DoubleTensor.html#adbab8d3eed5ddd7c924dbc52c407ca9d">More...</a><br /></td></tr>
<tr class="separator:adbab8d3eed5ddd7c924dbc52c407ca9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23983509fdd0be62f60a57d491fabc0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a23983509fdd0be62f60a57d491fabc0d">order</a> () const</td></tr>
<tr class="memdesc:a23983509fdd0be62f60a57d491fabc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of dimensions.  <a href="classhelayers_1_1DoubleTensor.html#a23983509fdd0be62f60a57d491fabc0d">More...</a><br /></td></tr>
<tr class="separator:a23983509fdd0be62f60a57d491fabc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585b0b108de4c4c319a5af25395d9511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a585b0b108de4c4c319a5af25395d9511">size</a> () const</td></tr>
<tr class="memdesc:a585b0b108de4c4c319a5af25395d9511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements in tensor.  <a href="classhelayers_1_1DoubleTensor.html#a585b0b108de4c4c319a5af25395d9511">More...</a><br /></td></tr>
<tr class="separator:a585b0b108de4c4c319a5af25395d9511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb7bd877548a09ce8ef0f9762be7023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a0fb7bd877548a09ce8ef0f9762be7023">getDimSize</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim) const</td></tr>
<tr class="memdesc:a0fb7bd877548a09ce8ef0f9762be7023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size for specific dimension.  <a href="classhelayers_1_1DoubleTensor.html#a0fb7bd877548a09ce8ef0f9762be7023">More...</a><br /></td></tr>
<tr class="separator:a0fb7bd877548a09ce8ef0f9762be7023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57f57b4df9377b2527efc33c1c72fa5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#af57f57b4df9377b2527efc33c1c72fa5">getShape</a> () const</td></tr>
<tr class="memdesc:af57f57b4df9377b2527efc33c1c72fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns shape.  <a href="classhelayers_1_1DoubleTensor.html#af57f57b4df9377b2527efc33c1c72fa5">More...</a><br /></td></tr>
<tr class="separator:af57f57b4df9377b2527efc33c1c72fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1b7c892546ab44b5aa23853f03ba26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1DoubleTensor.html#af9daef516ce96d777837a539a0961035">TensorImpl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a5d1b7c892546ab44b5aa23853f03ba26">getTensor</a> ()</td></tr>
<tr class="memdesc:a5d1b7c892546ab44b5aa23853f03ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns underlying tensor object.  <a href="classhelayers_1_1DoubleTensor.html#a5d1b7c892546ab44b5aa23853f03ba26">More...</a><br /></td></tr>
<tr class="separator:a5d1b7c892546ab44b5aa23853f03ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ba555060ffbcd2e0db34fe9c804e8f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhelayers_1_1DoubleTensor.html#af9daef516ce96d777837a539a0961035">TensorImpl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a31ba555060ffbcd2e0db34fe9c804e8f">getTensor</a> () const</td></tr>
<tr class="memdesc:a31ba555060ffbcd2e0db34fe9c804e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns underlying tensor object.  <a href="classhelayers_1_1DoubleTensor.html#a31ba555060ffbcd2e0db34fe9c804e8f">More...</a><br /></td></tr>
<tr class="separator:a31ba555060ffbcd2e0db34fe9c804e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac329294a54582ea14e7d61cde416de25"><td class="memItemLeft" align="right" valign="top"><a id="ac329294a54582ea14e7d61cde416de25"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ac329294a54582ea14e7d61cde416de25">getShapeAsString</a> () const</td></tr>
<tr class="memdesc:ac329294a54582ea14e7d61cde416de25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of this object's shape. <br /></td></tr>
<tr class="separator:ac329294a54582ea14e7d61cde416de25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae79fb53dd400bf3cabec088a93dc88e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#aae79fb53dd400bf3cabec088a93dc88e">assertShapeEquals</a> (std::initializer_list&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; shape) const</td></tr>
<tr class="memdesc:aae79fb53dd400bf3cabec088a93dc88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts given shape equals tensor's shape.  <a href="classhelayers_1_1DoubleTensor.html#aae79fb53dd400bf3cabec088a93dc88e">More...</a><br /></td></tr>
<tr class="separator:aae79fb53dd400bf3cabec088a93dc88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a8c1714e3f6d6dd34ed7b8d028dd18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a07a8c1714e3f6d6dd34ed7b8d028dd18">getSlice</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> startIndex, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> sliceDepth=1) const</td></tr>
<tr class="memdesc:a07a8c1714e3f6d6dd34ed7b8d028dd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of the tensor in specific dimension.  <a href="classhelayers_1_1DoubleTensor.html#a07a8c1714e3f6d6dd34ed7b8d028dd18">More...</a><br /></td></tr>
<tr class="separator:a07a8c1714e3f6d6dd34ed7b8d028dd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8737d1efe354caa8f0d308f528eeac11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a8737d1efe354caa8f0d308f528eeac11">putSlice</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> startIndex, const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;slice)</td></tr>
<tr class="memdesc:a8737d1efe354caa8f0d308f528eeac11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a tensor slice into an existing tensor.  <a href="classhelayers_1_1DoubleTensor.html#a8737d1efe354caa8f0d308f528eeac11">More...</a><br /></td></tr>
<tr class="separator:a8737d1efe354caa8f0d308f528eeac11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9599626d9cca922e05aa4c57e5c918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a7a9599626d9cca922e05aa4c57e5c918">removeSlice</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> startIndex, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> sliceDepth=1)</td></tr>
<tr class="memdesc:a7a9599626d9cca922e05aa4c57e5c918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified slice from this <a class="el" href="classhelayers_1_1DoubleTensor.html" title="A thin wrapper over a boost::numeric::ublas::tensor&lt;double&gt; object.">DoubleTensor</a>, in place.  <a href="classhelayers_1_1DoubleTensor.html#a7a9599626d9cca922e05aa4c57e5c918">More...</a><br /></td></tr>
<tr class="separator:a7a9599626d9cca922e05aa4c57e5c918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabab78bf3711fb752c7e4ca132ea84d3"><td class="memTemplParams" colspan="2"><a id="aabab78bf3711fb752c7e4ca132ea84d3"></a>
template&lt;class... DimInts&gt; </td></tr>
<tr class="memitem:aabab78bf3711fb752c7e4ca132ea84d3"><td class="memTemplItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#aabab78bf3711fb752c7e4ca132ea84d3">at</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> i, DimInts... is) const</td></tr>
<tr class="memdesc:aabab78bf3711fb752c7e4ca132ea84d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at specified indices. <br /></td></tr>
<tr class="separator:aabab78bf3711fb752c7e4ca132ea84d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccff3d5a06a4ef71244eb0c03da9a30"><td class="memTemplParams" colspan="2"><a id="a6ccff3d5a06a4ef71244eb0c03da9a30"></a>
template&lt;class... DimInts&gt; </td></tr>
<tr class="memitem:a6ccff3d5a06a4ef71244eb0c03da9a30"><td class="memTemplItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a6ccff3d5a06a4ef71244eb0c03da9a30">at</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> i, DimInts... is)</td></tr>
<tr class="memdesc:a6ccff3d5a06a4ef71244eb0c03da9a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at specified indices. <br /></td></tr>
<tr class="separator:a6ccff3d5a06a4ef71244eb0c03da9a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90296e2f65a6b089df2efb3de132eb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a90296e2f65a6b089df2efb3de132eb76">transpose</a> ()</td></tr>
<tr class="memdesc:a90296e2f65a6b089df2efb3de132eb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the order of the first two dimensions.  <a href="classhelayers_1_1DoubleTensor.html#a90296e2f65a6b089df2efb3de132eb76">More...</a><br /></td></tr>
<tr class="separator:a90296e2f65a6b089df2efb3de132eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2221ddee01c3863ea19a49f3bd529c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a1d2221ddee01c3863ea19a49f3bd529c">rotateAlongDim</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim)</td></tr>
<tr class="memdesc:a1d2221ddee01c3863ea19a49f3bd529c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the content of this <a class="el" href="classhelayers_1_1DoubleTensor.html" title="A thin wrapper over a boost::numeric::ublas::tensor&lt;double&gt; object.">DoubleTensor</a> along the specified dimension.  <a href="classhelayers_1_1DoubleTensor.html#a1d2221ddee01c3863ea19a49f3bd529c">More...</a><br /></td></tr>
<tr class="separator:a1d2221ddee01c3863ea19a49f3bd529c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4d5f3e40b1c4ff4776776fc2e144d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a1a4d5f3e40b1c4ff4776776fc2e144d9">getFlattened</a> (bool firstOrder=true) const</td></tr>
<tr class="memdesc:a1a4d5f3e40b1c4ff4776776fc2e144d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns tensor content as flat vector.  <a href="classhelayers_1_1DoubleTensor.html#a1a4d5f3e40b1c4ff4776776fc2e144d9">More...</a><br /></td></tr>
<tr class="separator:a1a4d5f3e40b1c4ff4776776fc2e144d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5bf0b0a7851619f03eab528d267bae"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a3b5bf0b0a7851619f03eab528d267bae">sumOfElements</a> ()</td></tr>
<tr class="memdesc:a3b5bf0b0a7851619f03eab528d267bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the tensor.  <a href="classhelayers_1_1DoubleTensor.html#a3b5bf0b0a7851619f03eab528d267bae">More...</a><br /></td></tr>
<tr class="separator:a3b5bf0b0a7851619f03eab528d267bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50338b11ec0042bd932169bb563e6f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ab50338b11ec0042bd932169bb563e6f7">elementAdd</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;other)</td></tr>
<tr class="memdesc:ab50338b11ec0042bd932169bb563e6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs element-wise add of other into this.  <a href="classhelayers_1_1DoubleTensor.html#ab50338b11ec0042bd932169bb563e6f7">More...</a><br /></td></tr>
<tr class="separator:ab50338b11ec0042bd932169bb563e6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807d0470b253c6e4557080ecba520d44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a807d0470b253c6e4557080ecba520d44">elementSub</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;other)</td></tr>
<tr class="memdesc:a807d0470b253c6e4557080ecba520d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs element-wise subtract of other from this.  <a href="classhelayers_1_1DoubleTensor.html#a807d0470b253c6e4557080ecba520d44">More...</a><br /></td></tr>
<tr class="separator:a807d0470b253c6e4557080ecba520d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd8810708891139d26b00fa6965d549"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#aebd8810708891139d26b00fa6965d549">elementMultiply</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;other)</td></tr>
<tr class="memdesc:aebd8810708891139d26b00fa6965d549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs element-wise multiplication of other into this.  <a href="classhelayers_1_1DoubleTensor.html#aebd8810708891139d26b00fa6965d549">More...</a><br /></td></tr>
<tr class="separator:aebd8810708891139d26b00fa6965d549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9595fef5c29e1f9385b3d0ed7c54fac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ab9595fef5c29e1f9385b3d0ed7c54fac">matrixMultiply</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;other)</td></tr>
<tr class="memdesc:ab9595fef5c29e1f9385b3d0ed7c54fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the result of matrix multiplication of this and other in-place.  <a href="classhelayers_1_1DoubleTensor.html#ab9595fef5c29e1f9385b3d0ed7c54fac">More...</a><br /></td></tr>
<tr class="separator:ab9595fef5c29e1f9385b3d0ed7c54fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390518706fab29c609c8970b5bca46bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a390518706fab29c609c8970b5bca46bf">matrixMultiplyLeft</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;other)</td></tr>
<tr class="memdesc:a390518706fab29c609c8970b5bca46bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as matrixMutiply, but computes other*this, and stores results in this.  <a href="classhelayers_1_1DoubleTensor.html#a390518706fab29c609c8970b5bca46bf">More...</a><br /></td></tr>
<tr class="separator:a390518706fab29c609c8970b5bca46bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c00f28ebd321170ac991111373e698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a13c00f28ebd321170ac991111373e698">getMatrixMultiply</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;other, <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;res) const</td></tr>
<tr class="memdesc:a13c00f28ebd321170ac991111373e698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets in res the result of matrix-multiplication of this and other.  <a href="classhelayers_1_1DoubleTensor.html#a13c00f28ebd321170ac991111373e698">More...</a><br /></td></tr>
<tr class="separator:a13c00f28ebd321170ac991111373e698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7034e8c0f1c7fc73741876b74a2b822d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a7034e8c0f1c7fc73741876b74a2b822d">addVector</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;vector)</td></tr>
<tr class="memdesc:a7034e8c0f1c7fc73741876b74a2b822d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the result of adding a vector to this vector.  <a href="classhelayers_1_1DoubleTensor.html#a7034e8c0f1c7fc73741876b74a2b822d">More...</a><br /></td></tr>
<tr class="separator:a7034e8c0f1c7fc73741876b74a2b822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab444286d02e92ce0e06cb887e88a870f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ab444286d02e92ce0e06cb887e88a870f">addScalar</a> (double val)</td></tr>
<tr class="memdesc:ab444286d02e92ce0e06cb887e88a870f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds given scalar to all elements.  <a href="classhelayers_1_1DoubleTensor.html#ab444286d02e92ce0e06cb887e88a870f">More...</a><br /></td></tr>
<tr class="separator:ab444286d02e92ce0e06cb887e88a870f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3816893f0af9af9cb54df9efb2e57966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a3816893f0af9af9cb54df9efb2e57966">subtractScalar</a> (double val)</td></tr>
<tr class="memdesc:a3816893f0af9af9cb54df9efb2e57966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts given scalar to all elements.  <a href="classhelayers_1_1DoubleTensor.html#a3816893f0af9af9cb54df9efb2e57966">More...</a><br /></td></tr>
<tr class="separator:a3816893f0af9af9cb54df9efb2e57966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6b68dfaef44c4d0da8e5f5daa3f623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a1b6b68dfaef44c4d0da8e5f5daa3f623">multiplyScalar</a> (double val)</td></tr>
<tr class="memdesc:a1b6b68dfaef44c4d0da8e5f5daa3f623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all elements by a given scalar.  <a href="classhelayers_1_1DoubleTensor.html#a1b6b68dfaef44c4d0da8e5f5daa3f623">More...</a><br /></td></tr>
<tr class="separator:a1b6b68dfaef44c4d0da8e5f5daa3f623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d3170b4811b7f3a7c8def77d764533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a16d3170b4811b7f3a7c8def77d764533">multiplyScalarsDimWise</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, const std::vector&lt; double &gt; &amp;vals)</td></tr>
<tr class="memdesc:a16d3170b4811b7f3a7c8def77d764533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all elements by a scalar, where with respect to a given dimension, every "slice" along that dimension will be multiplied by a different scalar.  <a href="classhelayers_1_1DoubleTensor.html#a16d3170b4811b7f3a7c8def77d764533">More...</a><br /></td></tr>
<tr class="separator:a16d3170b4811b7f3a7c8def77d764533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fee4f8b515547464eae145e09df229c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a1fee4f8b515547464eae145e09df229c">elementPolyEval</a> (const std::vector&lt; double &gt; &amp;coeffs)</td></tr>
<tr class="memdesc:a1fee4f8b515547464eae145e09df229c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs element-wise polynomial computation into this.  <a href="classhelayers_1_1DoubleTensor.html#a1fee4f8b515547464eae145e09df229c">More...</a><br /></td></tr>
<tr class="separator:a1fee4f8b515547464eae145e09df229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150d5a8eae659e3aafe120edf4c8e8fc"><td class="memItemLeft" align="right" valign="top"><a id="a150d5a8eae659e3aafe120edf4c8e8fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a150d5a8eae659e3aafe120edf4c8e8fc">sign</a> ()</td></tr>
<tr class="memdesc:a150d5a8eae659e3aafe120edf4c8e8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an element-wise indication of the sign of a number into this. <br /></td></tr>
<tr class="separator:a150d5a8eae659e3aafe120edf4c8e8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a0f6aa839ad550ff18885e7f7b33bf"><td class="memItemLeft" align="right" valign="top"><a id="a46a0f6aa839ad550ff18885e7f7b33bf"></a>
<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a46a0f6aa839ad550ff18885e7f7b33bf">argmax</a> () const</td></tr>
<tr class="memdesc:a46a0f6aa839ad550ff18885e7f7b33bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element with maximal value in the tensor. <br /></td></tr>
<tr class="separator:a46a0f6aa839ad550ff18885e7f7b33bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125fa6111a849c5e5c4a2bb7376807ed"><td class="memItemLeft" align="right" valign="top"><a id="a125fa6111a849c5e5c4a2bb7376807ed"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a125fa6111a849c5e5c4a2bb7376807ed">maxAbs</a> () const</td></tr>
<tr class="memdesc:a125fa6111a849c5e5c4a2bb7376807ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal absolute value in the tensor. <br /></td></tr>
<tr class="separator:a125fa6111a849c5e5c4a2bb7376807ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace0a6b6c0419e59c160ad26663ffbc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#aace0a6b6c0419e59c160ad26663ffbc5">readMatrixFromCsvFile</a> (const std::string &amp;filePath, bool ignoreFirstRow=false)</td></tr>
<tr class="memdesc:aace0a6b6c0419e59c160ad26663ffbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix from a CSV file.  <a href="classhelayers_1_1DoubleTensor.html#aace0a6b6c0419e59c160ad26663ffbc5">More...</a><br /></td></tr>
<tr class="separator:aace0a6b6c0419e59c160ad26663ffbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f85909a6f70119c6dc53073e9f37cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ab0f85909a6f70119c6dc53073e9f37cf">readMatrixFromCsvStream</a> (std::istream &amp;stream, bool ignoreFirstRow=false)</td></tr>
<tr class="memdesc:ab0f85909a6f70119c6dc53073e9f37cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix from a stream containing the content of a CSV file.  <a href="classhelayers_1_1DoubleTensor.html#ab0f85909a6f70119c6dc53073e9f37cf">More...</a><br /></td></tr>
<tr class="separator:ab0f85909a6f70119c6dc53073e9f37cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2848cf3b5efdd57b78100950f3cbd9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ae2848cf3b5efdd57b78100950f3cbd9b">writeMatrixToCsv</a> (const std::string &amp;filePath) const</td></tr>
<tr class="memdesc:ae2848cf3b5efdd57b78100950f3cbd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the content of this to a CSV file.  <a href="classhelayers_1_1DoubleTensor.html#ae2848cf3b5efdd57b78100950f3cbd9b">More...</a><br /></td></tr>
<tr class="separator:ae2848cf3b5efdd57b78100950f3cbd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f0bef1585d7516d4f30e92e2b65ec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a90f0bef1585d7516d4f30e92e2b65ec7">writeMatrixToCsv</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a90f0bef1585d7516d4f30e92e2b65ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the content of this as CSV to a stream.  <a href="classhelayers_1_1DoubleTensor.html#a90f0bef1585d7516d4f30e92e2b65ec7">More...</a><br /></td></tr>
<tr class="separator:a90f0bef1585d7516d4f30e92e2b65ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b10ce490d29b00a56f2a8652090d901"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; std::istream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a5b10ce490d29b00a56f2a8652090d901">getCsvMatrixStream</a> () const</td></tr>
<tr class="memdesc:a5b10ce490d29b00a56f2a8652090d901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream containing this tensor as CSV.  <a href="classhelayers_1_1DoubleTensor.html#a5b10ce490d29b00a56f2a8652090d901">More...</a><br /></td></tr>
<tr class="separator:a5b10ce490d29b00a56f2a8652090d901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2723ef5780669b81d580e6010c7e3910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a2723ef5780669b81d580e6010c7e3910">assertSameShape</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;other, const std::string &amp;title=&quot;&quot;, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> skippedDim=-1) const</td></tr>
<tr class="memdesc:a2723ef5780669b81d580e6010c7e3910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts <code>other</code> has the same shape as <code>this</code>, except an optional skipped dimension that is allowed to have a different size (-1 to compare all dimensions).  <a href="classhelayers_1_1DoubleTensor.html#a2723ef5780669b81d580e6010c7e3910">More...</a><br /></td></tr>
<tr class="separator:a2723ef5780669b81d580e6010c7e3910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c24bf005e2fac85f829a75a7f2de46"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a41c24bf005e2fac85f829a75a7f2de46">assertEquals</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;other, const std::string &amp;title=&quot;&quot;, double eps=1e-5, bool relative=false) const</td></tr>
<tr class="memdesc:a41c24bf005e2fac85f829a75a7f2de46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies this tensor equals other tensor.  <a href="classhelayers_1_1DoubleTensor.html#a41c24bf005e2fac85f829a75a7f2de46">More...</a><br /></td></tr>
<tr class="separator:a41c24bf005e2fac85f829a75a7f2de46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6472dc275cebf567ec52ad94b5d1d90e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a6472dc275cebf567ec52ad94b5d1d90e">testMse</a> (const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;expectedVals, const std::string &amp;title=&quot;&quot;, double eps=-1) const</td></tr>
<tr class="memdesc:a6472dc275cebf567ec52ad94b5d1d90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the MSE (Mean Square Error) with expected values.  <a href="classhelayers_1_1DoubleTensor.html#a6472dc275cebf567ec52ad94b5d1d90e">More...</a><br /></td></tr>
<tr class="separator:a6472dc275cebf567ec52ad94b5d1d90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e693436117af2dbf59efe4d8708632a"><td class="memItemLeft" align="right" valign="top"><a id="a3e693436117af2dbf59efe4d8708632a"></a>
std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a3e693436117af2dbf59efe4d8708632a">getNonTrivialDims</a> () const</td></tr>
<tr class="memdesc:a3e693436117af2dbf59efe4d8708632a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of dimension indices whose sizes are larger than 1. <br /></td></tr>
<tr class="separator:a3e693436117af2dbf59efe4d8708632a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a60fdbfaadf547d9c298f483511cb4dad"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#a60fdbfaadf547d9c298f483511cb4dad">shapeToString</a> (std::initializer_list&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; shape)</td></tr>
<tr class="memdesc:a60fdbfaadf547d9c298f483511cb4dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of shape.  <a href="classhelayers_1_1DoubleTensor.html#a60fdbfaadf547d9c298f483511cb4dad">More...</a><br /></td></tr>
<tr class="separator:a60fdbfaadf547d9c298f483511cb4dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9bf3a890557aa78a62c1ea4e7f22f1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#acc9bf3a890557aa78a62c1ea4e7f22f1">shapeToString</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;shape)</td></tr>
<tr class="memdesc:acc9bf3a890557aa78a62c1ea4e7f22f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of shape.  <a href="classhelayers_1_1DoubleTensor.html#acc9bf3a890557aa78a62c1ea4e7f22f1">More...</a><br /></td></tr>
<tr class="separator:acc9bf3a890557aa78a62c1ea4e7f22f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43285e301710b02a2fece274772275d"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ac43285e301710b02a2fece274772275d">getNonTrivialDims</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;dimSizes)</td></tr>
<tr class="memdesc:ac43285e301710b02a2fece274772275d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indices of the input dimension sizes list of all elements whose size is larger than 1.  <a href="classhelayers_1_1DoubleTensor.html#ac43285e301710b02a2fece274772275d">More...</a><br /></td></tr>
<tr class="separator:ac43285e301710b02a2fece274772275d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dd70a7d5f7821fe73adf01de52097a"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1DoubleTensor.html#ac7dd70a7d5f7821fe73adf01de52097a">getDimsFor2dArrayPrint</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;shape)</td></tr>
<tr class="memdesc:ac7dd70a7d5f7821fe73adf01de52097a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension used for printing as a 2d array.  <a href="classhelayers_1_1DoubleTensor.html#ac7dd70a7d5f7821fe73adf01de52097a">More...</a><br /></td></tr>
<tr class="separator:ac7dd70a7d5f7821fe73adf01de52097a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A thin wrapper over a boost::numeric::ublas::tensor&lt;double&gt; object. </p>
<p>Uses the first-order convention. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af99a229d09f507c97fe60b3c4ea18fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99a229d09f507c97fe60b3c4ea18fd0">&#9670;&nbsp;</a></span>DoubleTensor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::DoubleTensor::DoubleTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty tensor. </p>

</div>
</div>
<a id="a57defd9fb37686ffcadb1fe165c0e11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57defd9fb37686ffcadb1fe165c0e11e">&#9670;&nbsp;</a></span>DoubleTensor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::DoubleTensor::DoubleTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html#af9daef516ce96d777837a539a0961035">TensorImpl</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct copy of given tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>tensor to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f8dea2cf9f0a6789d8efd3f4a4ad330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8dea2cf9f0a6789d8efd3f4a4ad330">&#9670;&nbsp;</a></span>DoubleTensor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::DoubleTensor::DoubleTensor </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a zeroed tensor with given shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa16119879d51d90ae7b3b3efb0f4e592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16119879d51d90ae7b3b3efb0f4e592">&#9670;&nbsp;</a></span>DoubleTensor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::DoubleTensor::DoubleTensor </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a zeroed tensor with given shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a863fde6ffbd927646c62cf558e9a71ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863fde6ffbd927646c62cf558e9a71ba">&#9670;&nbsp;</a></span>addDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::addDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new dimension to the tensor. </p>
<p>The result is a tensor with number of dimensions increased by one. The added dimension is being padded with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the dimension to add. Must be at the start or between or end of the existing dimensions. Any existing dimensions with index equal or greater will have their index be advanced in 1. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the new dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab444286d02e92ce0e06cb887e88a870f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab444286d02e92ce0e06cb887e88a870f">&#9670;&nbsp;</a></span>addScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::addScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds given scalar to all elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7034e8c0f1c7fc73741876b74a2b822d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7034e8c0f1c7fc73741876b74a2b822d">&#9670;&nbsp;</a></span>addVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::addVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the result of adding a vector to this vector. </p>
<p>The other vector is a 2D tensor of sizes [a,1] and this vector is a 3D tensor of sizes [a,1,batch]. The result is a 3D tensor of sizes [a,1,batch].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>the 2D vector to add to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac79c4a3fc2bea6cad6f9a204afbfc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac79c4a3fc2bea6cad6f9a204afbfc8f">&#9670;&nbsp;</a></span>argMinOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::argMinOverDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes arg-min over a given dimension. </p>
<p>After this operation the dimension size will be 1, and it will contain the index of the previous minimal value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the dimension to run arg-min over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41c24bf005e2fac85f829a75a7f2de46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c24bf005e2fac85f829a75a7f2de46">&#9670;&nbsp;</a></span>assertEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helayers::DoubleTensor::assertEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>relative</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies this tensor equals other tensor. </p>
<p>Returns the mean squared error (MSE).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other tensor to verify equality to. </td></tr>
    <tr><td class="paramname">title</td><td>A title to print in case the assertion fails. </td></tr>
    <tr><td class="paramname">eps</td><td>The maximal diff allowed in each slot between this and other. A negative value indicates not to throw an exception, and use this function just for its return value. </td></tr>
    <tr><td class="paramname">relative</td><td>Whether to apply comparison with respect to relative difference between values. Defaults to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2723ef5780669b81d580e6010c7e3910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2723ef5780669b81d580e6010c7e3910">&#9670;&nbsp;</a></span>assertSameShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::assertSameShape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>skippedDim</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts <code>other</code> has the same shape as <code>this</code>, except an optional skipped dimension that is allowed to have a different size (-1 to compare all dimensions). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other tensor to test with </td></tr>
    <tr><td class="paramname">title</td><td>Optional title for error printouts </td></tr>
    <tr><td class="paramname">skippedDim</td><td>Optional dimension to skip </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae79fb53dd400bf3cabec088a93dc88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae79fb53dd400bf3cabec088a93dc88e">&#9670;&nbsp;</a></span>assertShapeEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::assertShapeEquals </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts given shape equals tensor's shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>Shape. If a zero value is passed for a certain dimension, it means this dimension should be skipped when verifying its size </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If assertion fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a258ed7c71fbce5c0c0130e695f43037b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258ed7c71fbce5c0c0130e695f43037b">&#9670;&nbsp;</a></span>batchNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::batchNorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>biases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform batch normalization on this object. </p>
<p>The object can be at any shape. This operation does not change the shape of the object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The features dimension. Must exist in this object. Its size must equal the size of the vectors of means, vars, scales and biases. </td></tr>
    <tr><td class="paramname">means</td><td>A vector with the mean of each feature along the features dimension. </td></tr>
    <tr><td class="paramname">vars</td><td>A vector with the variance of each feature along the features dimension. </td></tr>
    <tr><td class="paramname">scales</td><td>A vector with the scale of each feature along the features dimension. </td></tr>
    <tr><td class="paramname">biases</td><td>A vector with the bias of each feature along the features dimension. </td></tr>
    <tr><td class="paramname">eps</td><td>The epsilon value to use for the normalization, to avoid deviding by zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa073cb593d470a107f257c92df5c69c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa073cb593d470a107f257c92df5c69c4">&#9670;&nbsp;</a></span>calcAveragePooling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::calcAveragePooling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>filterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>filterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>strideX</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>strideY</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a> &amp;&#160;</td>
          <td class="paramname"><em>padding</em> = <code><a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform average-pooling of this object. </p>
<p>Expects this object to be a 4-dimensional tensor: [X,Y,CHANNELS,BATCH] The average-pooling is done over a (filterRows X filterCols) filter. The result will be [OUTX,OUTY,FILTERS,BATCH]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>Resulting tensor </td></tr>
    <tr><td class="paramname">filterX</td><td>Width of filter on the X axis (first dimension) to average over </td></tr>
    <tr><td class="paramname">filterY</td><td>Width of filter on the Y axis (second dimension) to average over </td></tr>
    <tr><td class="paramname">strideX</td><td>Stride on the X axis (first dimension) </td></tr>
    <tr><td class="paramname">strideY</td><td>Stride on the Y axis (second dimension) </td></tr>
    <tr><td class="paramname">padding</td><td>The padding values (default, all zeros) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa583469e98d01bd3dae78f17f7bb94ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa583469e98d01bd3dae78f17f7bb94ca">&#9670;&nbsp;</a></span>calcConvolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::calcConvolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>biases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>strideX</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>strideY</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a> &amp;&#160;</td>
          <td class="paramname"><em>padding</em> = <code><a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform convolution of this object with filters. </p>
<p>Expects this object to be a 4-dimensional tensor: [X,Y,CHANNELS,BATCH] The filters should be [FILTERX,FILTERY,CHANNELS,FILTERS] The biases can be any tensor with FILTERS number of elements. The result will be [OUTX,OUTY,FILTERS,BATCH]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>Resulting tensor </td></tr>
    <tr><td class="paramname">filters</td><td>Filters </td></tr>
    <tr><td class="paramname">biases</td><td>Biases </td></tr>
    <tr><td class="paramname">strideX</td><td>Stride on the X axis (first dimension) </td></tr>
    <tr><td class="paramname">strideY</td><td>Stride on the Y axis (second dimension) </td></tr>
    <tr><td class="paramname">padding</td><td>The padding values (default, all zeros) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab201fa702854ea4c6a825bdb3a475854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab201fa702854ea4c6a825bdb3a475854">&#9670;&nbsp;</a></span>calcSumPooling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::calcSumPooling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>filterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>filterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>strideX</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>strideY</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a> &amp;&#160;</td>
          <td class="paramname"><em>padding</em> = <code><a class="el" href="structhelayers_1_1Padding2d.html">Padding2d</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sum-pooling of this object. </p>
<p>Expects this object to be a 4-dimensional tensor: [X,Y,CHANNELS,BATCH] The sum-pooling is done over a (filterRows X filterCols) filter. The result will be [OUTX,OUTY,FILTERS,BATCH]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>Resulting tensor </td></tr>
    <tr><td class="paramname">filterX</td><td>Width of filter on the X axis (first dimension) to sum over </td></tr>
    <tr><td class="paramname">filterY</td><td>Width of filter on the Y axis (second dimension) to sum over </td></tr>
    <tr><td class="paramname">strideX</td><td>Stride on the X axis (first dimension) </td></tr>
    <tr><td class="paramname">strideY</td><td>Stride on the Y axis (second dimension) </td></tr>
    <tr><td class="paramname">padding</td><td>The padding values (default, all zeros) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f7dc56d9220c37e43ec7cc2e1c7c93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7dc56d9220c37e43ec7cc2e1c7c93e">&#9670;&nbsp;</a></span>debugPrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::debugPrint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints state for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td>Title to print alongside state </td></tr>
    <tr><td class="paramname">verbose</td><td>Verbosity of printout </td></tr>
    <tr><td class="paramname">out</td><td>output stream to print to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca6aa5611214bd09d0f5e70da554f2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6aa5611214bd09d0f5e70da554f2e4">&#9670;&nbsp;</a></span>duplicateOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::duplicateOverDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates the values of a specified existing dimension. </p>
<p>The values will be taken from the slot at index 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the dimension to duplicate over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50338b11ec0042bd932169bb563e6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50338b11ec0042bd932169bb563e6f7">&#9670;&nbsp;</a></span>elementAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::elementAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs element-wise add of other into this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tensor to add into this. must have the same shape as this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebd8810708891139d26b00fa6965d549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd8810708891139d26b00fa6965d549">&#9670;&nbsp;</a></span>elementMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::elementMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs element-wise multiplication of other into this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tensor to multiply into this. must have the same shape as this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fee4f8b515547464eae145e09df229c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fee4f8b515547464eae145e09df229c">&#9670;&nbsp;</a></span>elementPolyEval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::elementPolyEval </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs element-wise polynomial computation into this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>the coefficients of the polynomial, in the order: c[0],c[1],...,c[n] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a807d0470b253c6e4557080ecba520d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807d0470b253c6e4557080ecba520d44">&#9670;&nbsp;</a></span>elementSub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::elementSub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs element-wise subtract of other from this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tensor to subtract from this. must have the same shape as this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbab8d3eed5ddd7c924dbc52c407ca9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbab8d3eed5ddd7c924dbc52c407ca9d">&#9670;&nbsp;</a></span>flattenConvolutionOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::flattenConvolutionOutput </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>channelsLast</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens a 4D tensor that is an output of a convolution operation into 3D tensor with sizes [dim0 x dim1 x dim2, 1, dim3], where dimX is the size of dimension X of the original tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelsLast</td><td>Indication to whether the flatten should be performed in the channels-last or channels-first convention. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b10ce490d29b00a56f2a8652090d901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b10ce490d29b00a56f2a8652090d901">&#9670;&nbsp;</a></span>getCsvMatrixStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; istream &gt; helayers::DoubleTensor::getCsvMatrixStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a stream containing this tensor as CSV. </p>
<p>The shape of this must be 2D </p>

</div>
</div>
<a id="ac7dd70a7d5f7821fe73adf01de52097a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dd70a7d5f7821fe73adf01de52097a">&#9670;&nbsp;</a></span>getDimsFor2dArrayPrint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; helayers::DoubleTensor::getDimsFor2dArrayPrint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dimension used for printing as a 2d array. </p>
<p>If the tensor has 3 or more non-trivial dims, it returns an empty list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>Tensor shape </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fb7bd877548a09ce8ef0f9762be7023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb7bd877548a09ce8ef0f9762be7023">&#9670;&nbsp;</a></span>getDimSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> helayers::DoubleTensor::getDimSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns size for specific dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a4d5f3e40b1c4ff4776776fc2e144d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4d5f3e40b1c4ff4776776fc2e144d9">&#9670;&nbsp;</a></span>getFlattened()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; helayers::DoubleTensor::getFlattened </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>firstOrder</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns tensor content as flat vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstOrder</td><td>Whether to populate the vector using first order convention </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13c00f28ebd321170ac991111373e698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c00f28ebd321170ac991111373e698">&#9670;&nbsp;</a></span>getMatrixMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::getMatrixMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets in res the result of matrix-multiplication of this and other. </p>
<p>Both this and other tensor can be either 2D or 3D. If they are 3D, the third dimension is considered the batch dimension. If they are 3D they both need to be 3D with the same batch dimension, and so is the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other matrix to multiply with. </td></tr>
    <tr><td class="paramname">res</td><td>Output tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac43285e301710b02a2fece274772275d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43285e301710b02a2fece274772275d">&#9670;&nbsp;</a></span>getNonTrivialDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&gt; helayers::DoubleTensor::getNonTrivialDims </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimSizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the indices of the input dimension sizes list of all elements whose size is larger than 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimSizes</td><td><a class="el" href="structhelayers_1_1Input.html" title="Structure to hold specification of an input layer in an NN.">Input</a> list of dimension sizes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af57f57b4df9377b2527efc33c1c72fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57f57b4df9377b2527efc33c1c72fa5">&#9670;&nbsp;</a></span>getShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; helayers::DoubleTensor::getShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns shape. </p>
<p>Note: allocates a new vector. Don't use in efficiency-critical code. </p>

</div>
</div>
<a id="a07a8c1714e3f6d6dd34ed7b8d028dd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a8c1714e3f6d6dd34ed7b8d028dd18">&#9670;&nbsp;</a></span>getSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> helayers::DoubleTensor::getSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>sliceDepth</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a slice of the tensor in specific dimension. </p>
<p>Result has the same number of dimensions as the original tensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the dimension to slice along. Specifying negative value will count from the last dim backwards (-1 fot the last dim, -2 for the previoud one etc.). </td></tr>
    <tr><td class="paramname">startIndex</td><td>the index to start slicing at along the dimension </td></tr>
    <tr><td class="paramname">sliceDepth</td><td>the depth/size of the slice along the dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d1b7c892546ab44b5aa23853f03ba26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1b7c892546ab44b5aa23853f03ba26">&#9670;&nbsp;</a></span>getTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1DoubleTensor.html#af9daef516ce96d777837a539a0961035">TensorImpl</a>&amp; helayers::DoubleTensor::getTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns underlying tensor object. </p>

</div>
</div>
<a id="a31ba555060ffbcd2e0db34fe9c804e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ba555060ffbcd2e0db34fe9c804e8f">&#9670;&nbsp;</a></span>getTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhelayers_1_1DoubleTensor.html#af9daef516ce96d777837a539a0961035">TensorImpl</a>&amp; helayers::DoubleTensor::getTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns underlying tensor object. </p>

</div>
</div>
<a id="a36e902beb4bc4207c27bc61682b44d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e902beb4bc4207c27bc61682b44d0f">&#9670;&nbsp;</a></span>init() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::init </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>firstOrder</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialized tensor with given shape and values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>New shape to set </td></tr>
    <tr><td class="paramname">vals</td><td>Vals to fill tensor with. </td></tr>
    <tr><td class="paramname">firstOrder</td><td>Indicates whether supplied values are in first-order. Note that internally they'll be stored according to internal convention. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47705ebbc59fa628b297bfa828ff89e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47705ebbc59fa628b297bfa828ff89e7">&#9670;&nbsp;</a></span>init() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::init </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialized tensor with given shape and value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>New shape to set </td></tr>
    <tr><td class="paramname">vals</td><td>A single value to fill tensor with in all slots. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c657645680ef5c8ff7e7334e9623981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c657645680ef5c8ff7e7334e9623981">&#9670;&nbsp;</a></span>init() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::init </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>firstOrder</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates existing tensor with values. </p>
<p>The tensor can have any number of dimensions, and its shape is maintained. Caller can specify whether input vector is in the first-order convention or not. Internally it is stored according to the internal convention.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>a vector with the values to populate. size of vector must equal the size of tensor </td></tr>
    <tr><td class="paramname">firstOrder</td><td>whether vals is given in the first order convention or last order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a840cbe65af87d59f93aaee022828c73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840cbe65af87d59f93aaee022828c73f">&#9670;&nbsp;</a></span>init() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::init </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates existing 2D tensor with values from a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>a matrix with the values to populate. size of matrix must equal the size of the 2D tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6508d952727568309291ef47928e729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6508d952727568309291ef47928e729">&#9670;&nbsp;</a></span>init() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html#af9daef516ce96d777837a539a0961035">TensorImpl</a>&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize object with a tensor object of the underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>Tensor object to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89b266c36fc95886e769779b75fc2c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b266c36fc95886e769779b75fc2c2c">&#9670;&nbsp;</a></span>initRandom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::initRandom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates existing tensor with random values in [-0.5, 0.5]. </p>

</div>
</div>
<a id="a1ed40a3720291805ff33b9b050716021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed40a3720291805ff33b9b050716021">&#9670;&nbsp;</a></span>initRandom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::initRandom </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sparseRate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates existing tensor with random values in the range [min, max) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>A lower limit for the random values. </td></tr>
    <tr><td class="paramname">max</td><td>An upper limit for the random values. </td></tr>
    <tr><td class="paramname">sparseRate</td><td>The rate of zeroed values. Must be in the range of [0,1]. For example, 0 means no values will be set to zero, while 0.3 means ~30% of the values will be set to zero and ~70% will get values in the range of [min,max). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ae8cf0327799cfd81404e04d42eca29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae8cf0327799cfd81404e04d42eca29">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">streamoff helayers::DoubleTensor::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load this object from a binary stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream to load from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9595fef5c29e1f9385b3d0ed7c54fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9595fef5c29e1f9385b3d0ed7c54fac">&#9670;&nbsp;</a></span>matrixMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::matrixMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the result of matrix multiplication of this and other in-place. </p>
<p>Both this and other tensor can be either 2D or 3D. If they are 3D, the third dimension is considered the batch dimension. The output will have a batch dimension of either inputs have it. If both inputs have the batch dimension, we require it to be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix to multiply with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a390518706fab29c609c8970b5bca46bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390518706fab29c609c8970b5bca46bf">&#9670;&nbsp;</a></span>matrixMultiplyLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::matrixMultiplyLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as matrixMutiply, but computes other*this, and stores results in this. </p>
<p>See <a class="el" href="classhelayers_1_1DoubleTensor.html#ab9595fef5c29e1f9385b3d0ed7c54fac" title="Calculates the result of matrix multiplication of this and other in-place.">matrixMultiply()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix to multiply with this on the left. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6b68dfaef44c4d0da8e5f5daa3f623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6b68dfaef44c4d0da8e5f5daa3f623">&#9670;&nbsp;</a></span>multiplyScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::multiplyScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies all elements by a given scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to multiply by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16d3170b4811b7f3a7c8def77d764533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d3170b4811b7f3a7c8def77d764533">&#9670;&nbsp;</a></span>multiplyScalarsDimWise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::multiplyScalarsDimWise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies all elements by a scalar, where with respect to a given dimension, every "slice" along that dimension will be multiplied by a different scalar. </p>
<p>For example, if the given dimension is dimension 0 and its size is 3, a vector of 3 scalars [s0,s1,s2] should be provided. All the slots in the result tensor at index 0/1/2 along dimension 0 will be multiplied by the scalar s0/s1/s2, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The given dimension. </td></tr>
    <tr><td class="paramname">vals</td><td>The scalars to multiply by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbab4692249d2946df2771b4795ebe80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbab4692249d2946df2771b4795ebe80">&#9670;&nbsp;</a></span>nicePrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::nicePrint </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withShape</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the tensor nicely formatted. </p>
<p>For tensor with one or two non-trivial dims, it is printed as a table with right-aligned numbers according to <a class="el" href="structhelayers_1_1PrintOptions.html#a8eb546b3d12ce4f38ae9e1d226a81dff" title="Width of element when printing tables of numbers.">PrintOptions::tableCellWidth</a>.</p>
<p>For other tensors the printout is the same as debugPrint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream to print to </td></tr>
    <tr><td class="paramname">withShape</td><td>when true, the shape of the tensor is printed as well. Note that if the tensor can't be printed in tabular form, the shape is always printed and this argument is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23983509fdd0be62f60a57d491fabc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23983509fdd0be62f60a57d491fabc0d">&#9670;&nbsp;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> helayers::DoubleTensor::order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of dimensions. </p>

</div>
</div>
<a id="a8737d1efe354caa8f0d308f528eeac11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8737d1efe354caa8f0d308f528eeac11">&#9670;&nbsp;</a></span>putSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::putSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put a tensor slice into an existing tensor. </p>
<p>Putting the slice will override existing values in indexes positioned where the slice will be put, and the tensor size along the provided domension will be increased if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>an existing dimension to put the slice in. Specifying negative value will count from the last dim backwards (-1 fot the last dim, -2 for the previoud one etc.). </td></tr>
    <tr><td class="paramname">startIndex</td><td>the index to start positioning the slice in along the dimension. specifying -1 will append slice after last current index. </td></tr>
    <tr><td class="paramname">slice</td><td>the slice to put. must be a tensor with the same number of dimensions as this, and with sizes of dimensions exactly maching the sizes of this except for the provided dimension to put the slice in, that might be at any size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aace0a6b6c0419e59c160ad26663ffbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace0a6b6c0419e59c160ad26663ffbc5">&#9670;&nbsp;</a></span>readMatrixFromCsvFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::readMatrixFromCsvFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreFirstRow</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a matrix from a CSV file. </p>
<p>Any current content or shape of this is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path to legal CSV file to read from. </td></tr>
    <tr><td class="paramname">ignoreFirstRow</td><td>if true, it assumes the first row is column names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0f85909a6f70119c6dc53073e9f37cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f85909a6f70119c6dc53073e9f37cf">&#9670;&nbsp;</a></span>readMatrixFromCsvStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::readMatrixFromCsvStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreFirstRow</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a matrix from a stream containing the content of a CSV file. </p>
<p>Any current content or shape of this is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Stream containing the content of a legal CSV file to read from. </td></tr>
    <tr><td class="paramname">ignoreFirstRow</td><td>if true, it assumes the first row is column names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a9599626d9cca922e05aa4c57e5c918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9599626d9cca922e05aa4c57e5c918">&#9670;&nbsp;</a></span>removeSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::removeSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>sliceDepth</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified slice from this <a class="el" href="classhelayers_1_1DoubleTensor.html" title="A thin wrapper over a boost::numeric::ublas::tensor&lt;double&gt; object.">DoubleTensor</a>, in place. </p>
<p>The removed slice starts at startIndex of the given dimension and ends at startIndex + sliceDepth - 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the dimension to slice along. Specifying negative value will count from the last dim backwards (-1 fot the last dim, -2 for the previoud one etc.). </td></tr>
    <tr><td class="paramname">startIndex</td><td>the index to start slicing at along the dimension </td></tr>
    <tr><td class="paramname">sliceDepth</td><td>the depth/size of the slice along the dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af746ad8d5598bbcc619033eb568e2151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af746ad8d5598bbcc619033eb568e2151">&#9670;&nbsp;</a></span>reorderDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::reorderDims </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the dimensions of this tensor. </p>
<p>For example, given {1,2,0}, the current second dimension will become first, the current third dimension will become second, and the current first dimension will become last. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimOrder</td><td>New order of dimensions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62534b3b8cdcd05172b0a249049cdf00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62534b3b8cdcd05172b0a249049cdf00">&#9670;&nbsp;</a></span>reshape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::reshape </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71ae127bb4ce1e880686bb39c37aa54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ae127bb4ce1e880686bb39c37aa54d">&#9670;&nbsp;</a></span>reshape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::reshape </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73f97c835fd0289e9ed67b85efe73d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f97c835fd0289e9ed67b85efe73d34">&#9670;&nbsp;</a></span>resizeDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::resizeDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes an existing dimension. </p>
<p>If the size is being increased, the resized dimension is being padded with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the dimension to resize. </td></tr>
    <tr><td class="paramname">newSize</td><td>the new desired size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d2221ddee01c3863ea19a49f3bd529c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2221ddee01c3863ea19a49f3bd529c">&#9670;&nbsp;</a></span>rotateAlongDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::rotateAlongDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates the content of this <a class="el" href="classhelayers_1_1DoubleTensor.html" title="A thin wrapper over a boost::numeric::ublas::tensor&lt;double&gt; object.">DoubleTensor</a> along the specified dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The dimension to rotate along </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4792edad26fbbed7288f66750f40b43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4792edad26fbbed7288f66750f40b43f">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">streamoff helayers::DoubleTensor::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save this object to a binary stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc9bf3a890557aa78a62c1ea4e7f22f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9bf3a890557aa78a62c1ea4e7f22f1">&#9670;&nbsp;</a></span>shapeToString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string helayers::DoubleTensor::shapeToString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>Shape </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60fdbfaadf547d9c298f483511cb4dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fdbfaadf547d9c298f483511cb4dad">&#9670;&nbsp;</a></span>shapeToString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string helayers::DoubleTensor::shapeToString </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>Shape </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a585b0b108de4c4c319a5af25395d9511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585b0b108de4c4c319a5af25395d9511">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> helayers::DoubleTensor::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of elements in tensor. </p>

</div>
</div>
<a id="a3816893f0af9af9cb54df9efb2e57966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3816893f0af9af9cb54df9efb2e57966">&#9670;&nbsp;</a></span>subtractScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::subtractScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts given scalar to all elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to subtract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b5bf0b0a7851619f03eab528d267bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5bf0b0a7851619f03eab528d267bae">&#9670;&nbsp;</a></span>sumOfElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helayers::DoubleTensor::sumOfElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sum of all elements in the tensor. </p>

</div>
</div>
<a id="a6472dc275cebf567ec52ad94b5d1d90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6472dc275cebf567ec52ad94b5d1d90e">&#9670;&nbsp;</a></span>testMse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helayers::DoubleTensor::testMse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1DoubleTensor.html">DoubleTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>expectedVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the MSE (Mean Square Error) with expected values. </p>
<p>If title!="", prints results to cout. If eps&gt;=0, asserts MSE&lt;=eps </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expectedVals</td><td>tensor input to compare </td></tr>
    <tr><td class="paramname">title</td><td>If not empty, will be output to cout along with MSE </td></tr>
    <tr><td class="paramname">eps</td><td>If non-negative, an exception will be thrown if MSE&gt;eps </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90296e2f65a6b089df2efb3de132eb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90296e2f65a6b089df2efb3de132eb76">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips the order of the first two dimensions. </p>
<p>For a 2d matrix, this means the transposed matrix. Requires at least 2 dimensions. </p>

</div>
</div>
<a id="ae2848cf3b5efdd57b78100950f3cbd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2848cf3b5efdd57b78100950f3cbd9b">&#9670;&nbsp;</a></span>writeMatrixToCsv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::writeMatrixToCsv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the content of this to a CSV file. </p>
<p>The shape of this must be 2D.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>Path to CSV file to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90f0bef1585d7516d4f30e92e2b65ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f0bef1585d7516d4f30e92e2b65ec7">&#9670;&nbsp;</a></span>writeMatrixToCsv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::DoubleTensor::writeMatrixToCsv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the content of this as CSV to a stream. </p>
<p>The shape of this must be 2D.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/helayers/math/<a class="el" href="DoubleTensor_8h_source.html">DoubleTensor.h</a></li>
<li>src/helayers/math/DoubleTensor.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
