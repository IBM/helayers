<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17" />
    <title>HElayers SDK: helayers::CircuitContext Class Reference</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;1,700&family=Merriweather&family=Merriweather+Sans&family=Open+Sans&family=Poppins:ital@1&family=Roboto:ital,wght@0,400;1,300;1,900&display=swap"
        rel="stylesheet">
    <script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/latest/ui-shell.min.js"></script>
</head>
<body style="font-family: 'Merriweather', serif;">
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand">HElayers SDK 1.5.1.0</a>
            </div>
        </div>
    </nav>
    <div id="top">
        <bx-header aria-label="IBM Platform Name">
            <bx-header-menu-button button-label-active="Close menu" button-label-inactive="Open menu">
            </bx-header-menu-button>
            <bx-header-name href="index.html" prefix="IBM">HElayers</bx-header-name>
            <bx-header-nav menu-bar-label="IBM HElayers">
                <bx-header-nav-item href="index.html">Overview
                </bx-header-nav-item>
                <bx-header-menu menu-label="Namespaces" trigger-content="Namespaces">
                    <bx-header-menu-item href="namespaces.html">Namespace List
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Namespace Members" trigger-content="Namespace  Members">
                        <bx-header-menu-item href="namespacemembers.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_enum.html">Enumerations
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_eval.html">Enumerator
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Classes" trigger-content="Classes">
                    <bx-header-menu-item href="annotated.html">Class List
                    </bx-header-menu-item>
                    <bx-header-menu-item href="classes.html">Class Index
                    </bx-header-menu-item>
                    <bx-header-menu-item href="inherits.html">Class Hierarchy
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Class Members" trigger-content="Class Members">
                        <bx-header-menu-item href="functions.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Variables
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_enum.html">Enumerations
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Files" trigger-content="Files">
                    <bx-header-menu-item href="files.html">File List</bx-header-menu-item>
                </bx-header-menu>
            </bx-header-nav>
        </bx-header>
        <!-- do not remove this div, it is closed by doxygen! -->
        <!-- end header part --><!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehelayers.html">helayers</a></li><li class="navelem"><a class="el" href="classhelayers_1_1CircuitContext.html">CircuitContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhelayers_1_1CircuitContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">helayers::CircuitContext Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for helayers::CircuitContext:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhelayers_1_1CircuitContext.png" usemap="#helayers::CircuitContext_map" alt=""/>
  <map id="helayers::CircuitContext_map" name="helayers::CircuitContext_map">
<area href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,..." alt="helayers::HeContext" shape="rect" coords="0,0,146,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0fd2dfadcd045e05873bf4ccfee540db"><td class="memItemLeft" align="right" valign="top"><a id="a0fd2dfadcd045e05873bf4ccfee540db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a0fd2dfadcd045e05873bf4ccfee540db">init</a> (const <a class="el" href="structhelayers_1_1HeConfigRequirement.html">HeConfigRequirement</a> &amp;req) override</td></tr>
<tr class="memdesc:a0fd2dfadcd045e05873bf4ccfee540db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use. <br /></td></tr>
<tr class="separator:a0fd2dfadcd045e05873bf4ccfee540db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74754f41a2a993eb1550885e40f1ef9c"><td class="memItemLeft" align="right" valign="top"><a id="a74754f41a2a993eb1550885e40f1ef9c"></a>
circuit::CtxtId&#160;</td><td class="memItemRight" valign="bottom"><b>getCtxtId</b> ()</td></tr>
<tr class="separator:a74754f41a2a993eb1550885e40f1ef9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa3917e7edadc57f35bb34944d61f64"><td class="memItemLeft" align="right" valign="top"><a id="a7aa3917e7edadc57f35bb34944d61f64"></a>
circuit::PtxtId&#160;</td><td class="memItemRight" valign="bottom"><b>getPtxtId</b> ()</td></tr>
<tr class="separator:a7aa3917e7edadc57f35bb34944d61f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32386fdfae0565b5cce59661e1f96f03"><td class="memItemLeft" align="right" valign="top"><a id="a32386fdfae0565b5cce59661e1f96f03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCircuitOutput</b> (<a class="el" href="classhelayers_1_1circuit_1_1AbstractIo.html">circuit::AbstractIo</a> *o)</td></tr>
<tr class="separator:a32386fdfae0565b5cce59661e1f96f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa271519f45c9929e0c96ca9d1e60f799"><td class="memItemLeft" align="right" valign="top"><a id="aa271519f45c9929e0c96ca9d1e60f799"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>labelCtxt</b> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, const std::string &amp;label)</td></tr>
<tr class="separator:aa271519f45c9929e0c96ca9d1e60f799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9334ea508d15754e66e1734b7c078ed7"><td class="memItemLeft" align="right" valign="top"><a id="a9334ea508d15754e66e1734b7c078ed7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>labelCtxt</b> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;c, const std::string &amp;label)</td></tr>
<tr class="separator:a9334ea508d15754e66e1734b7c078ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3b3134ac5c8a97c97df4c75561c8f7"><td class="memItemLeft" align="right" valign="top"><a id="aef3b3134ac5c8a97c97df4c75561c8f7"></a>
virtual std::shared_ptr&lt; <a class="el" href="classhelayers_1_1AbstractCiphertext.html">AbstractCiphertext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#aef3b3134ac5c8a97c97df4c75561c8f7">createAbstractCipher</a> () const override</td></tr>
<tr class="memdesc:aef3b3134ac5c8a97c97df4c75561c8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use. Should be made private. <br /></td></tr>
<tr class="separator:aef3b3134ac5c8a97c97df4c75561c8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf3da738517ece92aafd246814a5ad2"><td class="memItemLeft" align="right" valign="top"><a id="afaf3da738517ece92aafd246814a5ad2"></a>
virtual std::shared_ptr&lt; <a class="el" href="classhelayers_1_1AbstractPlaintext.html">AbstractPlaintext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#afaf3da738517ece92aafd246814a5ad2">createAbstractPlain</a> () const override</td></tr>
<tr class="memdesc:afaf3da738517ece92aafd246814a5ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use. Should be made private. <br /></td></tr>
<tr class="separator:afaf3da738517ece92aafd246814a5ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab225c83a2d93aae681a578ed6c0ae42c"><td class="memItemLeft" align="right" valign="top"><a id="ab225c83a2d93aae681a578ed6c0ae42c"></a>
std::shared_ptr&lt; <a class="el" href="classhelayers_1_1AbstractEncoder.html">AbstractEncoder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#ab225c83a2d93aae681a578ed6c0ae42c">getEncoder</a> () const override</td></tr>
<tr class="memdesc:ab225c83a2d93aae681a578ed6c0ae42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use. Should be made private. <br /></td></tr>
<tr class="separator:ab225c83a2d93aae681a578ed6c0ae42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ab0b704ac8f307725f6b6760588e1a"><td class="memItemLeft" align="right" valign="top"><a id="a81ab0b704ac8f307725f6b6760588e1a"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a81ab0b704ac8f307725f6b6760588e1a">slotCount</a> () const override</td></tr>
<tr class="memdesc:a81ab0b704ac8f307725f6b6760588e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of slots in each <a class="el" href="classhelayers_1_1CTile.html" title="A class representing a ciphertext.">CTile</a> (ciphertext) or <a class="el" href="classhelayers_1_1PTile.html" title="A class representing an encoded (unencrypted) plaintext.">PTile</a> (plaintext) created over this context. <br /></td></tr>
<tr class="separator:a81ab0b704ac8f307725f6b6760588e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dcb5dd599b377d9d83ce5d68fa1a77"><td class="memItemLeft" align="right" valign="top"><a id="ae7dcb5dd599b377d9d83ce5d68fa1a77"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#ae7dcb5dd599b377d9d83ce5d68fa1a77">getTopChainIndex</a> () const override</td></tr>
<tr class="memdesc:ae7dcb5dd599b377d9d83ce5d68fa1a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest available chain index (for schemes where it is applicable). <br /></td></tr>
<tr class="separator:ae7dcb5dd599b377d9d83ce5d68fa1a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1444b31ed32939dc2b6a0b8e15a2760c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a1444b31ed32939dc2b6a0b8e15a2760c">hasSecretKey</a> () const override</td></tr>
<tr class="memdesc:a1444b31ed32939dc2b6a0b8e15a2760c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this context contains a secret key.  <a href="classhelayers_1_1CircuitContext.html#a1444b31ed32939dc2b6a0b8e15a2760c">More...</a><br /></td></tr>
<tr class="separator:a1444b31ed32939dc2b6a0b8e15a2760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2dc0a00f2b7780e856901a1bb5b4bb"><td class="memItemLeft" align="right" valign="top"><a id="a0c2dc0a00f2b7780e856901a1bb5b4bb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a0c2dc0a00f2b7780e856901a1bb5b4bb">getSecurityLevel</a> () const override</td></tr>
<tr class="memdesc:a0c2dc0a00f2b7780e856901a1bb5b4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the security level supplied by this context. <br /></td></tr>
<tr class="separator:a0c2dc0a00f2b7780e856901a1bb5b4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a9472207aaddb9c58abbb1a2a074f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#aa0a9472207aaddb9c58abbb1a2a074f3">printSignature</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:aa0a9472207aaddb9c58abbb1a2a074f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a summary of library details and configuration params.  <a href="classhelayers_1_1CircuitContext.html#aa0a9472207aaddb9c58abbb1a2a074f3">More...</a><br /></td></tr>
<tr class="separator:aa0a9472207aaddb9c58abbb1a2a074f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65106509f94dd23c05edaf69dc39a41c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a65106509f94dd23c05edaf69dc39a41c">debugPrint</a> (const std::string &amp;title=&quot;&quot;, int verbose=0, std::ostream &amp;out=std::cout) const override</td></tr>
<tr class="memdesc:a65106509f94dd23c05edaf69dc39a41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints detailed information for debug purposes.  <a href="classhelayers_1_1CircuitContext.html#a65106509f94dd23c05edaf69dc39a41c">More...</a><br /></td></tr>
<tr class="separator:a65106509f94dd23c05edaf69dc39a41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad149553a08a9a8084d0ad8025c38e140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#ad149553a08a9a8084d0ad8025c38e140">saveSecretKey</a> (std::ostream &amp;out, bool seedOnly=false) override</td></tr>
<tr class="memdesc:ad149553a08a9a8084d0ad8025c38e140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save secret key to the given ostream.  <a href="classhelayers_1_1CircuitContext.html#ad149553a08a9a8084d0ad8025c38e140">More...</a><br /></td></tr>
<tr class="separator:ad149553a08a9a8084d0ad8025c38e140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83953539362546d47e5e8591c5077b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#ab83953539362546d47e5e8591c5077b7">loadSecretKey</a> (std::istream &amp;out, bool seedOnly=false) override</td></tr>
<tr class="memdesc:ab83953539362546d47e5e8591c5077b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load secret key from the given istream.  <a href="classhelayers_1_1CircuitContext.html#ab83953539362546d47e5e8591c5077b7">More...</a><br /></td></tr>
<tr class="separator:ab83953539362546d47e5e8591c5077b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00669738f824cd4d8fc6a3d1f0c3edd6"><td class="memItemLeft" align="right" valign="top"><a id="a00669738f824cd4d8fc6a3d1f0c3edd6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a00669738f824cd4d8fc6a3d1f0c3edd6">getLibraryName</a> () const override</td></tr>
<tr class="memdesc:a00669738f824cd4d8fc6a3d1f0c3edd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the underlying library. <br /></td></tr>
<tr class="separator:a00669738f824cd4d8fc6a3d1f0c3edd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390b5bcd4e470a2ff05355fdfdbaf84a"><td class="memItemLeft" align="right" valign="top"><a id="a390b5bcd4e470a2ff05355fdfdbaf84a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a390b5bcd4e470a2ff05355fdfdbaf84a">getSchemeName</a> () const override</td></tr>
<tr class="memdesc:a390b5bcd4e470a2ff05355fdfdbaf84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the underlying scheme. <br /></td></tr>
<tr class="separator:a390b5bcd4e470a2ff05355fdfdbaf84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3e01bbc4445751a424a85eb049f96b"><td class="memItemLeft" align="right" valign="top"><a id="a6b3e01bbc4445751a424a85eb049f96b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a6b3e01bbc4445751a424a85eb049f96b">getSignature</a> () const override</td></tr>
<tr class="memdesc:a6b3e01bbc4445751a424a85eb049f96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a signature of the context that distinguishes it enough to be able to load previously stored contexts based on their signatures. <br /></td></tr>
<tr class="separator:a6b3e01bbc4445751a424a85eb049f96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119e9a833cda69ff34a87a051030ac2f"><td class="memItemLeft" align="right" valign="top"><a id="a119e9a833cda69ff34a87a051030ac2f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a119e9a833cda69ff34a87a051030ac2f">isConfigRequirementFeasible</a> (const <a class="el" href="structhelayers_1_1HeConfigRequirement.html">HeConfigRequirement</a> &amp;req) const override</td></tr>
<tr class="memdesc:a119e9a833cda69ff34a87a051030ac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use. <br /></td></tr>
<tr class="separator:a119e9a833cda69ff34a87a051030ac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e5942f6d58c563d93cd1fe814a3499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#ad3e5942f6d58c563d93cd1fe814a3499">log</a> (circuit::OpType t, const <a class="el" href="classhelayers_1_1CircuitCiphertext.html">CircuitCiphertext</a> &amp;out)</td></tr>
<tr class="memdesc:ad3e5942f6d58c563d93cd1fe814a3499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log operations with no input ctxts (e.g.  <a href="classhelayers_1_1CircuitContext.html#ad3e5942f6d58c563d93cd1fe814a3499">More...</a><br /></td></tr>
<tr class="separator:ad3e5942f6d58c563d93cd1fe814a3499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab700312cbfb9c82e4c03c35c686aaf72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#ab700312cbfb9c82e4c03c35c686aaf72">log</a> (circuit::OpType t, const circuit::CtxtId &amp;out, const circuit::CtxtId &amp;in)</td></tr>
<tr class="memdesc:ab700312cbfb9c82e4c03c35c686aaf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log operations with a single input ctxt (e.g.  <a href="classhelayers_1_1CircuitContext.html#ab700312cbfb9c82e4c03c35c686aaf72">More...</a><br /></td></tr>
<tr class="separator:ab700312cbfb9c82e4c03c35c686aaf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece07911d8ffa9f71f5088a3c31848dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#aece07911d8ffa9f71f5088a3c31848dd">log</a> (circuit::OpType t, const circuit::CtxtId &amp;out, const circuit::CtxtId &amp;in1, const circuit::CtxtId &amp;in2)</td></tr>
<tr class="memdesc:aece07911d8ffa9f71f5088a3c31848dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log operations with a two input ctxts (e.g.  <a href="classhelayers_1_1CircuitContext.html#aece07911d8ffa9f71f5088a3c31848dd">More...</a><br /></td></tr>
<tr class="separator:aece07911d8ffa9f71f5088a3c31848dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe890c7a4c3ca8be86c662bacc27a738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#afe890c7a4c3ca8be86c662bacc27a738">log</a> (circuit::OpType t, const circuit::CtxtId &amp;out, const circuit::CtxtId &amp;in1, const <a class="el" href="classhelayers_1_1CircuitPlaintext.html">CircuitPlaintext</a> &amp;in2)</td></tr>
<tr class="memdesc:afe890c7a4c3ca8be86c662bacc27a738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log operations with a input ptxts (e.g.  <a href="classhelayers_1_1CircuitContext.html#afe890c7a4c3ca8be86c662bacc27a738">More...</a><br /></td></tr>
<tr class="separator:afe890c7a4c3ca8be86c662bacc27a738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce3abcfe95565597c48ee09c1df7ae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a8ce3abcfe95565597c48ee09c1df7ae5">log</a> (circuit::OpType t, const circuit::CtxtId &amp;out, const circuit::CtxtId &amp;in1, int n)</td></tr>
<tr class="memdesc:a8ce3abcfe95565597c48ee09c1df7ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log operations with a integer ptxts (e.g.  <a href="classhelayers_1_1CircuitContext.html#a8ce3abcfe95565597c48ee09c1df7ae5">More...</a><br /></td></tr>
<tr class="separator:a8ce3abcfe95565597c48ee09c1df7ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3001ad6913087d63d6601374a333a655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a3001ad6913087d63d6601374a333a655">setUnlabeledInput</a> (const circuit::CtxtId &amp;id, const circuit::RawValues &amp;v, int chainIndex)</td></tr>
<tr class="memdesc:a3001ad6913087d63d6601374a333a655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record a ctxt we encounter.  <a href="classhelayers_1_1CircuitContext.html#a3001ad6913087d63d6601374a333a655">More...</a><br /></td></tr>
<tr class="separator:a3001ad6913087d63d6601374a333a655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ffe728fca48357fc913a0f79b4a932"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#ac3ffe728fca48357fc913a0f79b4a932">unsetUnlabeledInput</a> (const circuit::CtxtId &amp;id)</td></tr>
<tr class="memdesc:ac3ffe728fca48357fc913a0f79b4a932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a ctxt from the unlabeled database.  <a href="classhelayers_1_1CircuitContext.html#ac3ffe728fca48357fc913a0f79b4a932">More...</a><br /></td></tr>
<tr class="separator:ac3ffe728fca48357fc913a0f79b4a932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3989bbbe4999b52b3576fc838de40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#add3989bbbe4999b52b3576fc838de40d">saveUnlabeledInputs</a> (<a class="el" href="classhelayers_1_1circuit_1_1AbstractIo.html">circuit::AbstractIo</a> *out)</td></tr>
<tr class="memdesc:add3989bbbe4999b52b3576fc838de40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record all unlabeled ctxt the circuit encountered.  <a href="classhelayers_1_1CircuitContext.html#add3989bbbe4999b52b3576fc838de40d">More...</a><br /></td></tr>
<tr class="separator:add3989bbbe4999b52b3576fc838de40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd28e326eb4cf2b58470d41ca8e3788e"><td class="memItemLeft" align="right" valign="top"><a id="afd28e326eb4cf2b58470d41ca8e3788e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#afd28e326eb4cf2b58470d41ca8e3788e">flush</a> ()</td></tr>
<tr class="memdesc:afd28e326eb4cf2b58470d41ca8e3788e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize writing to the output. <br /></td></tr>
<tr class="separator:afd28e326eb4cf2b58470d41ca8e3788e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804748ea74a4ed1a76501d3b2ae44da9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CircuitContext.html#a804748ea74a4ed1a76501d3b2ae44da9">publicFunctionsSupported</a> (const <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> &amp;publicFunctions) const override</td></tr>
<tr class="memdesc:a804748ea74a4ed1a76501d3b2ae44da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> object is supported by this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a>.  <a href="classhelayers_1_1CircuitContext.html#a804748ea74a4ed1a76501d3b2ae44da9">More...</a><br /></td></tr>
<tr class="separator:a804748ea74a4ed1a76501d3b2ae44da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhelayers_1_1HeContext"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhelayers_1_1HeContext')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhelayers_1_1HeContext.html">helayers::HeContext</a></td></tr>
<tr class="memitem:ad4afe56cc8b987f938100b9eedc6a762 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="ad4afe56cc8b987f938100b9eedc6a762"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ad4afe56cc8b987f938100b9eedc6a762">HeContext</a> ()</td></tr>
<tr class="memdesc:ad4afe56cc8b987f938100b9eedc6a762 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty object. <br /></td></tr>
<tr class="separator:ad4afe56cc8b987f938100b9eedc6a762 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a623a4a47183402da3db30afd7e50af inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a6a623a4a47183402da3db30afd7e50af">HeContext</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;src)=delete</td></tr>
<tr class="memdesc:a6a623a4a47183402da3db30afd7e50af inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classhelayers_1_1HeContext.html#a6a623a4a47183402da3db30afd7e50af">More...</a><br /></td></tr>
<tr class="separator:a6a623a4a47183402da3db30afd7e50af inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737ce1cabc4e12c1c18f3e3d7925be71 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a737ce1cabc4e12c1c18f3e3d7925be71">operator=</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;src)=delete</td></tr>
<tr class="memdesc:a737ce1cabc4e12c1c18f3e3d7925be71 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from another object.  <a href="classhelayers_1_1HeContext.html#a737ce1cabc4e12c1c18f3e3d7925be71">More...</a><br /></td></tr>
<tr class="separator:a737ce1cabc4e12c1c18f3e3d7925be71 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dca88b0fbc207c05fc12f31fe59669c inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="a2dca88b0fbc207c05fc12f31fe59669c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a2dca88b0fbc207c05fc12f31fe59669c">init</a> (const <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> &amp;publicFunctions=<a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a>())</td></tr>
<tr class="memdesc:a2dca88b0fbc207c05fc12f31fe59669c inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use. <br /></td></tr>
<tr class="separator:a2dca88b0fbc207c05fc12f31fe59669c inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22eb8ee2f0d267877d5132255257daf inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="ac22eb8ee2f0d267877d5132255257daf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ac22eb8ee2f0d267877d5132255257daf">getContextFileHeaderCode</a> () const</td></tr>
<tr class="memdesc:ac22eb8ee2f0d267877d5132255257daf inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that identifies a concrete <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> class for the purpose of dynamic loading. <br /></td></tr>
<tr class="separator:ac22eb8ee2f0d267877d5132255257daf inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77e410fea07b3732d1563941b6d57b0 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhelayers_1_1HeConfigRequirement.html">HeConfigRequirement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ab77e410fea07b3732d1563941b6d57b0">getActualConfigRequirement</a> (const <a class="el" href="structhelayers_1_1HeConfigRequirement.html">HeConfigRequirement</a> &amp;req) const</td></tr>
<tr class="memdesc:ab77e410fea07b3732d1563941b6d57b0 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual config requirement that will be enabled by the HE context when provided with the given config requirement.  <a href="classhelayers_1_1HeContext.html#ab77e410fea07b3732d1563941b6d57b0">More...</a><br /></td></tr>
<tr class="separator:ab77e410fea07b3732d1563941b6d57b0 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1127d0592ca4e607815e5805388c09 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a0f1127d0592ca4e607815e5805388c09">getBestFeasibleFractionalPartPrecision</a> (const <a class="el" href="structhelayers_1_1HeConfigRequirement.html">HeConfigRequirement</a> &amp;req) const</td></tr>
<tr class="memdesc:a0f1127d0592ca4e607815e5805388c09 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best feasible fractional part precision under the given configuration requirement.  <a href="classhelayers_1_1HeContext.html#a0f1127d0592ca4e607815e5805388c09">More...</a><br /></td></tr>
<tr class="separator:a0f1127d0592ca4e607815e5805388c09 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c20bcce5c9313679e270eace3f76f4 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a24c20bcce5c9313679e270eace3f76f4">getBestFeasibleMulDepth</a> (const <a class="el" href="structhelayers_1_1HeConfigRequirement.html">HeConfigRequirement</a> &amp;req) const</td></tr>
<tr class="memdesc:a24c20bcce5c9313679e270eace3f76f4 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best feasible multiplication depth under the given configuration requirement.  <a href="classhelayers_1_1HeContext.html#a24c20bcce5c9313679e270eace3f76f4">More...</a><br /></td></tr>
<tr class="separator:a24c20bcce5c9313679e270eace3f76f4 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c61acf21d57753e1148479af4e5a2e inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a44c61acf21d57753e1148479af4e5a2e">getMinFeasibleNumSlots</a> (const <a class="el" href="structhelayers_1_1HeConfigRequirement.html">HeConfigRequirement</a> &amp;req) const</td></tr>
<tr class="memdesc:a44c61acf21d57753e1148479af4e5a2e inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest number of slots that guarantees the other requirements in the given <a class="el" href="structhelayers_1_1HeConfigRequirement.html" title="For internal use.">HeConfigRequirement</a>.  <a href="classhelayers_1_1HeContext.html#a44c61acf21d57753e1148479af4e5a2e">More...</a><br /></td></tr>
<tr class="separator:a44c61acf21d57753e1148479af4e5a2e inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e0daf2a4949a348b62f8f984376ade inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="ae5e0daf2a4949a348b62f8f984376ade"></a>
virtual std::shared_ptr&lt; <a class="el" href="classhelayers_1_1AbstractFunctionEvaluator.html">AbstractFunctionEvaluator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ae5e0daf2a4949a348b62f8f984376ade">getFunctionEvaluator</a> ()</td></tr>
<tr class="memdesc:ae5e0daf2a4949a348b62f8f984376ade inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use. Should be made private. <br /></td></tr>
<tr class="separator:ae5e0daf2a4949a348b62f8f984376ade inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a593b325288b5915345cd2b0cd0c5e inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="ac1a593b325288b5915345cd2b0cd0c5e"></a>
virtual std::shared_ptr&lt; <a class="el" href="classhelayers_1_1AbstractBitwiseEvaluator.html">AbstractBitwiseEvaluator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ac1a593b325288b5915345cd2b0cd0c5e">getBitwiseEvaluator</a> () const</td></tr>
<tr class="memdesc:ac1a593b325288b5915345cd2b0cd0c5e inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use. Should be made private. <br /></td></tr>
<tr class="separator:ac1a593b325288b5915345cd2b0cd0c5e inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4463117b2214b564d59b26da2e66507 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="af4463117b2214b564d59b26da2e66507"></a>
virtual std::shared_ptr&lt; <a class="el" href="classhelayers_1_1AbstractBootstrapEvaluator.html">AbstractBootstrapEvaluator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#af4463117b2214b564d59b26da2e66507">createAbstractBootstrapEvaluator</a> (const <a class="el" href="classhelayers_1_1BootstrapConfig.html">BootstrapConfig</a> &amp;bsConfig) const</td></tr>
<tr class="memdesc:af4463117b2214b564d59b26da2e66507 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use. Should be made private. <br /></td></tr>
<tr class="separator:af4463117b2214b564d59b26da2e66507 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb408ca3a162a74c722ef3474efdcd9 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="afbb408ca3a162a74c722ef3474efdcd9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#afbb408ca3a162a74c722ef3474efdcd9">getBootstrappable</a> () const</td></tr>
<tr class="memdesc:afbb408ca3a162a74c722ef3474efdcd9 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indication to whether this HE context is bootstrappable. <br /></td></tr>
<tr class="separator:afbb408ca3a162a74c722ef3474efdcd9 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24aa5b726ba9c61f0f9ec0f2f3e75b6 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="ac24aa5b726ba9c61f0f9ec0f2f3e75b6"></a>
const <a class="el" href="classhelayers_1_1BootstrapConfig.html">BootstrapConfig</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ac24aa5b726ba9c61f0f9ec0f2f3e75b6">getBootstrapConfig</a> () const</td></tr>
<tr class="memdesc:ac24aa5b726ba9c61f0f9ec0f2f3e75b6 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal bootstrap configuration object. <br /></td></tr>
<tr class="separator:ac24aa5b726ba9c61f0f9ec0f2f3e75b6 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533b2ab6372f8c4d0a31207eed6de256 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="a533b2ab6372f8c4d0a31207eed6de256"></a>
const <a class="el" href="classhelayers_1_1BootstrapEvaluator.html">BootstrapEvaluator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a533b2ab6372f8c4d0a31207eed6de256">getBootstrapEvaluator</a> () const</td></tr>
<tr class="memdesc:a533b2ab6372f8c4d0a31207eed6de256 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal bootstrap evaluator object. <br /></td></tr>
<tr class="separator:a533b2ab6372f8c4d0a31207eed6de256 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5296de4e128b920a8190e307a6570613 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="a5296de4e128b920a8190e307a6570613"></a>
const <a class="el" href="classhelayers_1_1HeTraits.html">HeTraits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a5296de4e128b920a8190e307a6570613">getTraits</a> () const</td></tr>
<tr class="memdesc:a5296de4e128b920a8190e307a6570613 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhelayers_1_1HeTraits.html" title="A set of flags characterizing the underyling HE scheme.">HeTraits</a> object containing various properties of the underlying scheme. <br /></td></tr>
<tr class="separator:a5296de4e128b920a8190e307a6570613 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe8fe7c9d02159765025c1bb8e0e7f1 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="a8fe8fe7c9d02159765025c1bb8e0e7f1"></a>
virtual std::shared_ptr&lt; std::vector&lt; uint64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a8fe8fe7c9d02159765025c1bb8e0e7f1">getModulusChain</a> () const</td></tr>
<tr class="memdesc:a8fe8fe7c9d02159765025c1bb8e0e7f1 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the modulus chain: the value of each prime in the chain (where applicable). <br /></td></tr>
<tr class="separator:a8fe8fe7c9d02159765025c1bb8e0e7f1 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062ba4c2a7905133ce3a7f5ec92b93d2 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="a062ba4c2a7905133ce3a7f5ec92b93d2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a062ba4c2a7905133ce3a7f5ec92b93d2">setModulusChain</a> (const std::shared_ptr&lt; std::vector&lt; uint64_t &gt;&gt; &amp;modChain)</td></tr>
<tr class="memdesc:a062ba4c2a7905133ce3a7f5ec92b93d2 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the modulus chain: the value of each prime in the chain (where applicable). <br /></td></tr>
<tr class="separator:a062ba4c2a7905133ce3a7f5ec92b93d2 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917fd1eb7abe0cbf339fcf1ae054839b inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a917fd1eb7abe0cbf339fcf1ae054839b">saveSecretKeyToFile</a> (const std::string &amp;fileName, bool seedOnly=false)</td></tr>
<tr class="memdesc:a917fd1eb7abe0cbf339fcf1ae054839b inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">save secret key to the given file.  <a href="classhelayers_1_1HeContext.html#a917fd1eb7abe0cbf339fcf1ae054839b">More...</a><br /></td></tr>
<tr class="separator:a917fd1eb7abe0cbf339fcf1ae054839b inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a37c8f2f1bc9361f5cc37ec04a1a7e inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ae6a37c8f2f1bc9361f5cc37ec04a1a7e">loadSecretKeyFromFile</a> (const std::string &amp;fileName, bool seedOnly=false)</td></tr>
<tr class="memdesc:ae6a37c8f2f1bc9361f5cc37ec04a1a7e inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">load secret key from the given file.  <a href="classhelayers_1_1HeContext.html#ae6a37c8f2f1bc9361f5cc37ec04a1a7e">More...</a><br /></td></tr>
<tr class="separator:ae6a37c8f2f1bc9361f5cc37ec04a1a7e inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0cd4c1daf7d71066ad7da6789a468e inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="a5a0cd4c1daf7d71066ad7da6789a468e"></a>
virtual <a class="el" href="namespacehelayers.html#a3d097427c2c9f7801dd419a53571fc3f">DeviceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a5a0cd4c1daf7d71066ad7da6789a468e">getDefaultDevice</a> () const</td></tr>
<tr class="memdesc:a5a0cd4c1daf7d71066ad7da6789a468e inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default device of the ciphertexts and plaintexts generated using this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a>. <br /></td></tr>
<tr class="separator:a5a0cd4c1daf7d71066ad7da6789a468e inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc92868072e5fce5e1c106c6987aea66 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#adc92868072e5fce5e1c106c6987aea66">setDefaultDevice</a> (<a class="el" href="namespacehelayers.html#a3d097427c2c9f7801dd419a53571fc3f">DeviceType</a> device)</td></tr>
<tr class="memdesc:adc92868072e5fce5e1c106c6987aea66 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default device of the ciphertexts and plaintexts generated using this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a>.  <a href="classhelayers_1_1HeContext.html#adc92868072e5fce5e1c106c6987aea66">More...</a><br /></td></tr>
<tr class="separator:adc92868072e5fce5e1c106c6987aea66 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba00fd63c23a7607f4e731524f0f1fe inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="aaba00fd63c23a7607f4e731524f0f1fe"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#aaba00fd63c23a7607f4e731524f0f1fe">getDefaultScale</a> () const</td></tr>
<tr class="memdesc:aaba00fd63c23a7607f4e731524f0f1fe inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns default scale used in encoding (where applicable). <br /></td></tr>
<tr class="separator:aaba00fd63c23a7607f4e731524f0f1fe inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fab8ebf606934920e77db33244ee0f inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ad9fab8ebf606934920e77db33244ee0f">setDefaultScale</a> (double v)</td></tr>
<tr class="memdesc:ad9fab8ebf606934920e77db33244ee0f inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default scale to be used in encoding (where applicable).  <a href="classhelayers_1_1HeContext.html#ad9fab8ebf606934920e77db33244ee0f">More...</a><br /></td></tr>
<tr class="separator:ad9fab8ebf606934920e77db33244ee0f inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627b736df0a964274cdbd3394b7b43a1 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="a627b736df0a964274cdbd3394b7b43a1"></a>
virtual std::map&lt; std::string, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a627b736df0a964274cdbd3394b7b43a1">getEstimatedMeasures</a> () const</td></tr>
<tr class="memdesc:a627b736df0a964274cdbd3394b7b43a1 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use. <br /></td></tr>
<tr class="separator:a627b736df0a964274cdbd3394b7b43a1 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdde96b31a8e06cd208750ed4d04e53 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#adbdde96b31a8e06cd208750ed4d04e53">getMaxAllowedValues</a> () const</td></tr>
<tr class="memdesc:adbdde96b31a8e06cd208750ed4d04e53 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal absolute value allowed for each chain index.  <a href="classhelayers_1_1HeContext.html#adbdde96b31a8e06cd208750ed4d04e53">More...</a><br /></td></tr>
<tr class="separator:adbdde96b31a8e06cd208750ed4d04e53 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f498ad38187910c475589f8359193d1 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a2f498ad38187910c475589f8359193d1">getMaxAllowedValueByRange</a> (int high, int low) const</td></tr>
<tr class="memdesc:a2f498ad38187910c475589f8359193d1 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal absolute value allowed for values that may be in any chain index within a range that's defined between a given low and high chain indexes.  <a href="classhelayers_1_1HeContext.html#a2f498ad38187910c475589f8359193d1">More...</a><br /></td></tr>
<tr class="separator:a2f498ad38187910c475589f8359193d1 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e64a335c129921f72fe8e0e309a921 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a13e64a335c129921f72fe8e0e309a921">getMaxAllowedValue</a> (int chainIndex) const</td></tr>
<tr class="memdesc:a13e64a335c129921f72fe8e0e309a921 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal absolute value allowed for values in a given chain index.  <a href="classhelayers_1_1HeContext.html#a13e64a335c129921f72fe8e0e309a921">More...</a><br /></td></tr>
<tr class="separator:a13e64a335c129921f72fe8e0e309a921 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a24b28859b62b22c3de46670315b7e inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="ae5a24b28859b62b22c3de46670315b7e"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ae5a24b28859b62b22c3de46670315b7e">getMaxAllowedBsValue</a> () const</td></tr>
<tr class="memdesc:ae5a24b28859b62b22c3de46670315b7e inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal absolute value allowed for values going through a bootstrap operation. <br /></td></tr>
<tr class="separator:ae5a24b28859b62b22c3de46670315b7e inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8164950cb092b7bdbd3c9009ac9a8f6a inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a8164950cb092b7bdbd3c9009ac9a8f6a">clone</a> () const</td></tr>
<tr class="memdesc:a8164950cb092b7bdbd3c9009ac9a8f6a inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an uninitialized context of the same type.  <a href="classhelayers_1_1HeContext.html#a8164950cb092b7bdbd3c9009ac9a8f6a">More...</a><br /></td></tr>
<tr class="separator:a8164950cb092b7bdbd3c9009ac9a8f6a inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011037e592bd4813f3d30be4365c3d2e inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a011037e592bd4813f3d30be4365c3d2e">getAccurateScale</a> (int chainIndex) const</td></tr>
<tr class="memdesc:a011037e592bd4813f3d30be4365c3d2e inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the accurate scale to be used for a given chain index.  <a href="classhelayers_1_1HeContext.html#a011037e592bd4813f3d30be4365c3d2e">More...</a><br /></td></tr>
<tr class="separator:a011037e592bd4813f3d30be4365c3d2e inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac1a05e68a2de13e54e71e7954dbc4b inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="aaac1a05e68a2de13e54e71e7954dbc4b"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#aaac1a05e68a2de13e54e71e7954dbc4b">getContextId</a> () const</td></tr>
<tr class="memdesc:aaac1a05e68a2de13e54e71e7954dbc4b inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the context id that identifies the specific key set used by this context. <br /></td></tr>
<tr class="separator:aaac1a05e68a2de13e54e71e7954dbc4b inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2e72891205f4e7af739a3c29dd1a3b inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#aae2e72891205f4e7af739a3c29dd1a3b">setAutomaticBootstrapping</a> (bool val)</td></tr>
<tr class="memdesc:aae2e72891205f4e7af739a3c29dd1a3b inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <em>automaticBootstrapping</em> flag to the given <code>val</code>.  <a href="classhelayers_1_1HeContext.html#aae2e72891205f4e7af739a3c29dd1a3b">More...</a><br /></td></tr>
<tr class="separator:aae2e72891205f4e7af739a3c29dd1a3b inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594d6d49c4b165088a8fec086245b55a inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a594d6d49c4b165088a8fec086245b55a">getAutomaticBootstrapping</a> () const</td></tr>
<tr class="memdesc:a594d6d49c4b165088a8fec086245b55a inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the <em>automaticBootstrapping</em> flag.  <a href="classhelayers_1_1HeContext.html#a594d6d49c4b165088a8fec086245b55a">More...</a><br /></td></tr>
<tr class="separator:a594d6d49c4b165088a8fec086245b55a inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063e8d989d5f7632edf74f5a45e1504b inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="a063e8d989d5f7632edf74f5a45e1504b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a063e8d989d5f7632edf74f5a45e1504b">getMinChainIndexForBootstrapping</a> () const</td></tr>
<tr class="memdesc:a063e8d989d5f7632edf74f5a45e1504b inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> is bootstrappable, returns the minimum level in which ciphertexts can be bootstrapped. <br /></td></tr>
<tr class="separator:a063e8d989d5f7632edf74f5a45e1504b inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b9f5110208e8a1589ccdf82591350d inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="aa4b9f5110208e8a1589ccdf82591350d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#aa4b9f5110208e8a1589ccdf82591350d">getChainIndexAfterBootstrapping</a> () const</td></tr>
<tr class="memdesc:aa4b9f5110208e8a1589ccdf82591350d inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> is bootstrappable, returns the level of ciphertexts after bootstrapping. <br /></td></tr>
<tr class="separator:aa4b9f5110208e8a1589ccdf82591350d inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf46a9758475bfb919f4d9b1680311e inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhelayers_1_1BootstrapConfig.html">BootstrapConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a3bf46a9758475bfb919f4d9b1680311e">getBootstrapChainIndexes</a> (const <a class="el" href="structhelayers_1_1HeConfigRequirement.html">HeConfigRequirement</a> &amp;req) const</td></tr>
<tr class="memdesc:a3bf46a9758475bfb919f4d9b1680311e inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bootstrap config object with two chain index values: the minimum level in which ciphertexts can be bootstrapped and the level of ciphertexts after bootstrapping.  <a href="classhelayers_1_1HeContext.html#a3bf46a9758475bfb919f4d9b1680311e">More...</a><br /></td></tr>
<tr class="separator:a3bf46a9758475bfb919f4d9b1680311e inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8547d50b33523eac309b1c70069163e inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ad8547d50b33523eac309b1c70069163e">getMinSupportedNumSlots</a> () const</td></tr>
<tr class="memdesc:ad8547d50b33523eac309b1c70069163e inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimal number of slots supported by this HE context.  <a href="classhelayers_1_1HeContext.html#ad8547d50b33523eac309b1c70069163e">More...</a><br /></td></tr>
<tr class="separator:ad8547d50b33523eac309b1c70069163e inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af266eb0940cfc6ff24416b0ae690650e inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#af266eb0940cfc6ff24416b0ae690650e">getMaxSupportedNumSlots</a> () const</td></tr>
<tr class="memdesc:af266eb0940cfc6ff24416b0ae690650e inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal number of slots supported by this HE context.  <a href="classhelayers_1_1HeContext.html#af266eb0940cfc6ff24416b0ae690650e">More...</a><br /></td></tr>
<tr class="separator:af266eb0940cfc6ff24416b0ae690650e inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b68a66bdb92a0afa7b0938a70738be inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="aa6b68a66bdb92a0afa7b0938a70738be"></a>
const <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#aa6b68a66bdb92a0afa7b0938a70738be">getPublicFunctions</a> () const</td></tr>
<tr class="memdesc:aa6b68a66bdb92a0afa7b0938a70738be inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> object specifying the functionalities that are supported by the public keys of this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a>. <br /></td></tr>
<tr class="separator:aa6b68a66bdb92a0afa7b0938a70738be inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2aad384a688295561535b44f607be4 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top"><a id="abb2aad384a688295561535b44f607be4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#abb2aad384a688295561535b44f607be4">isInitialized</a> () const</td></tr>
<tr class="memdesc:abb2aad384a688295561535b44f607be4 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> is initialized. <br /></td></tr>
<tr class="separator:abb2aad384a688295561535b44f607be4 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614fae5da96a3b8bfbbbbc260a3582c5 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a614fae5da96a3b8bfbbbbc260a3582c5">assertSavePublicFunctionsSupported</a> (const <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> &amp;publicFunctions) const</td></tr>
<tr class="memdesc:a614fae5da96a3b8bfbbbbc260a3582c5 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> supports calling <a class="el" href="classhelayers_1_1HeContext.html#ab2e1d99e56388ada120637a7420112cb" title="Saves this HeContext to a stream in binary form.">save()</a> method with the given <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> object.  <a href="classhelayers_1_1HeContext.html#a614fae5da96a3b8bfbbbbc260a3582c5">More...</a><br /></td></tr>
<tr class="separator:a614fae5da96a3b8bfbbbbc260a3582c5 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18469200f1224570653822ad41e34bf inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#af18469200f1224570653822ad41e34bf">saveToFile</a> (const std::string &amp;fileName) const</td></tr>
<tr class="memdesc:af18469200f1224570653822ad41e34bf inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> object to a file in binary form.  <a href="classhelayers_1_1HeContext.html#af18469200f1224570653822ad41e34bf">More...</a><br /></td></tr>
<tr class="separator:af18469200f1224570653822ad41e34bf inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1994e8b1b80e74816f26ed4affc18ac5 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a1994e8b1b80e74816f26ed4affc18ac5">saveToFile</a> (const std::string &amp;fileName, const <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> &amp;publicFunctions) const</td></tr>
<tr class="memdesc:a1994e8b1b80e74816f26ed4affc18ac5 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> to a file in binary form.  <a href="classhelayers_1_1HeContext.html#a1994e8b1b80e74816f26ed4affc18ac5">More...</a><br /></td></tr>
<tr class="separator:a1994e8b1b80e74816f26ed4affc18ac5 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1b17d75d3e19dba584893ccf56733f inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a4b1b17d75d3e19dba584893ccf56733f">loadFromFile</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a4b1b17d75d3e19dba584893ccf56733f inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads this <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object from a file saved by <a class="el" href="classhelayers_1_1HeContext.html#af18469200f1224570653822ad41e34bf" title="Saves this HeContext object to a file in binary form.">saveToFile()</a>.  <a href="classhelayers_1_1HeContext.html#a4b1b17d75d3e19dba584893ccf56733f">More...</a><br /></td></tr>
<tr class="separator:a4b1b17d75d3e19dba584893ccf56733f inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e1d99e56388ada120637a7420112cb inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ab2e1d99e56388ada120637a7420112cb">save</a> (std::ostream &amp;stream) const</td></tr>
<tr class="memdesc:ab2e1d99e56388ada120637a7420112cb inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> to a stream in binary form.  <a href="classhelayers_1_1HeContext.html#ab2e1d99e56388ada120637a7420112cb">More...</a><br /></td></tr>
<tr class="separator:ab2e1d99e56388ada120637a7420112cb inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47a696ab0bf375d2fd838ee832c3202 inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ad47a696ab0bf375d2fd838ee832c3202">save</a> (std::ostream &amp;stream, const <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> &amp;publicFunctions) const</td></tr>
<tr class="memdesc:ad47a696ab0bf375d2fd838ee832c3202 inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> to a stream in binary form.  <a href="classhelayers_1_1HeContext.html#ad47a696ab0bf375d2fd838ee832c3202">More...</a><br /></td></tr>
<tr class="separator:ad47a696ab0bf375d2fd838ee832c3202 inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ff00d1e9c67a6b87f89d6aac9c188f inherit pub_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ac1ff00d1e9c67a6b87f89d6aac9c188f">load</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:ac1ff00d1e9c67a6b87f89d6aac9c188f inherit pub_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads this object from the given stream.  <a href="classhelayers_1_1HeContext.html#ac1ff00d1e9c67a6b87f89d6aac9c188f">More...</a><br /></td></tr>
<tr class="separator:ac1ff00d1e9c67a6b87f89d6aac9c188f inherit pub_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classhelayers_1_1HeContext"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classhelayers_1_1HeContext')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classhelayers_1_1HeContext.html">helayers::HeContext</a></td></tr>
<tr class="memitem:ae94b018d5c12d45c0a19988f5f5dde08 inherit pub_static_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ae94b018d5c12d45c0a19988f5f5dde08">create</a> (const std::string &amp;contextName, const <a class="el" href="structhelayers_1_1HeConfigRequirement.html">HeConfigRequirement</a> &amp;req)</td></tr>
<tr class="memdesc:ae94b018d5c12d45c0a19988f5f5dde08 inherit pub_static_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns an initialized HE context given a context name and config requirement.  <a href="classhelayers_1_1HeContext.html#ae94b018d5c12d45c0a19988f5f5dde08">More...</a><br /></td></tr>
<tr class="separator:ae94b018d5c12d45c0a19988f5f5dde08 inherit pub_static_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02ea23b9c18c52a440b6b2f5acd59a3 inherit pub_static_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#aa02ea23b9c18c52a440b6b2f5acd59a3">internalRegisterContext</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> *context)</td></tr>
<tr class="memdesc:aa02ea23b9c18c52a440b6b2f5acd59a3 inherit pub_static_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a context object for the purpose of dynamic loading.  <a href="classhelayers_1_1HeContext.html#aa02ea23b9c18c52a440b6b2f5acd59a3">More...</a><br /></td></tr>
<tr class="separator:aa02ea23b9c18c52a440b6b2f5acd59a3 inherit pub_static_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab261f39017124d667c72b1bdb81cd79d inherit pub_static_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#ab261f39017124d667c72b1bdb81cd79d">getRegisteredHeContext</a> (const std::string &amp;contextName)</td></tr>
<tr class="memdesc:ab261f39017124d667c72b1bdb81cd79d inherit pub_static_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns registered context given a context name.  <a href="classhelayers_1_1HeContext.html#ab261f39017124d667c72b1bdb81cd79d">More...</a><br /></td></tr>
<tr class="separator:ab261f39017124d667c72b1bdb81cd79d inherit pub_static_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41387aaa1c7a79e63d945cad866d362a inherit pub_static_methods_classhelayers_1_1HeContext"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1HeContext.html#a41387aaa1c7a79e63d945cad866d362a">isRegisteredHeContext</a> (const std::string &amp;contextName)</td></tr>
<tr class="memdesc:a41387aaa1c7a79e63d945cad866d362a inherit pub_static_methods_classhelayers_1_1HeContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns indication to whether a registered context exists under a given context name.  <a href="classhelayers_1_1HeContext.html#a41387aaa1c7a79e63d945cad866d362a">More...</a><br /></td></tr>
<tr class="separator:a41387aaa1c7a79e63d945cad866d362a inherit pub_static_methods_classhelayers_1_1HeContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a65106509f94dd23c05edaf69dc39a41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65106509f94dd23c05edaf69dc39a41c">&#9670;&nbsp;</a></span>debugPrint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::debugPrint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints detailed information for debug purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">title</td><td>Title to print along with the information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>Verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>Output stream to print to </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1HeContext.html#ad0efb7aa6c697c679d676152c74aa950">helayers::HeContext</a>.</p>

</div>
</div>
<a id="a1444b31ed32939dc2b6a0b8e15a2760c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1444b31ed32939dc2b6a0b8e15a2760c">&#9670;&nbsp;</a></span>hasSecretKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helayers::CircuitContext::hasSecretKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this context contains a secret key. </p>
<p>If not, decryption and other operations relying on decryption will not be available (will throw an exception). </p>

<p>Implements <a class="el" href="classhelayers_1_1HeContext.html#aa25367c2b12a671cc26ec1bb5b30b802">helayers::HeContext</a>.</p>

</div>
</div>
<a id="ab83953539362546d47e5e8591c5077b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83953539362546d47e5e8591c5077b7">&#9670;&nbsp;</a></span>loadSecretKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::loadSecretKey </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>seedOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load secret key from the given istream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The binary stream to load from. </td></tr>
    <tr><td class="paramname">seedOnly</td><td>If true, the seed of the secret key will be loaded from the given binary stream and the secret key will be generated using this seed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> already has a secret key. i.e. <a class="el" href="classhelayers_1_1CircuitContext.html#a1444b31ed32939dc2b6a0b8e15a2760c" title="Returns whether this context contains a secret key.">hasSecretKey()</a> is ture. </td></tr>
    <tr><td class="paramname">runtime_error</td><td>If seedOnly is true but the underlying <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> does not support secret key I/O using seeds. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhelayers_1_1HeContext.html#a63947a7175957fdadfa1da50b97278f1">helayers::HeContext</a>.</p>

</div>
</div>
<a id="ab700312cbfb9c82e4c03c35c686aaf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab700312cbfb9c82e4c03c35c686aaf72">&#9670;&nbsp;</a></span>log() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::log </td>
          <td>(</td>
          <td class="paramtype">circuit::OpType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log operations with a single input ctxt (e.g. </p>
<p>NEG, CONJUGATE) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Type of operation </td></tr>
    <tr><td class="paramname">in</td><td>Id of in ciphertext </td></tr>
    <tr><td class="paramname">out</td><td>Id of out ciphertext </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aece07911d8ffa9f71f5088a3c31848dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece07911d8ffa9f71f5088a3c31848dd">&#9670;&nbsp;</a></span>log() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::log </td>
          <td>(</td>
          <td class="paramtype">circuit::OpType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log operations with a two input ctxts (e.g. </p>
<p>ADD, MUL, SUB) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Type of operation </td></tr>
    <tr><td class="paramname">out</td><td>Id of out ciphertext </td></tr>
    <tr><td class="paramname">in1</td><td>Id of first input ciphertext </td></tr>
    <tr><td class="paramname">in2</td><td>Id of second input ciphertext </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe890c7a4c3ca8be86c662bacc27a738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe890c7a4c3ca8be86c662bacc27a738">&#9670;&nbsp;</a></span>log() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::log </td>
          <td>(</td>
          <td class="paramtype">circuit::OpType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CircuitPlaintext.html">CircuitPlaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log operations with a input ptxts (e.g. </p>
<p>ADD, MUL, SUB) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Type of operation </td></tr>
    <tr><td class="paramname">out</td><td>Id of out ciphertext </td></tr>
    <tr><td class="paramname">in1</td><td>Id of first input ciphertext </td></tr>
    <tr><td class="paramname">in2</td><td>Id of second input ciphertext </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ce3abcfe95565597c48ee09c1df7ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce3abcfe95565597c48ee09c1df7ae5">&#9670;&nbsp;</a></span>log() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::log </td>
          <td>(</td>
          <td class="paramtype">circuit::OpType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log operations with a integer ptxts (e.g. </p>
<p>ROTATIONS) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Type of operation </td></tr>
    <tr><td class="paramname">out</td><td>Id of out ciphertext </td></tr>
    <tr><td class="paramname">in1</td><td>Id of first input ciphertext </td></tr>
    <tr><td class="paramname">n</td><td>Integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3e5942f6d58c563d93cd1fe814a3499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e5942f6d58c563d93cd1fe814a3499">&#9670;&nbsp;</a></span>log() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::log </td>
          <td>(</td>
          <td class="paramtype">circuit::OpType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CircuitCiphertext.html">CircuitCiphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log operations with no input ctxts (e.g. </p>
<p>READ) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Type of operation </td></tr>
    <tr><td class="paramname">out</td><td>Id of ciphertext </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0a9472207aaddb9c58abbb1a2a074f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a9472207aaddb9c58abbb1a2a074f3">&#9670;&nbsp;</a></span>printSignature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::printSignature </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a summary of library details and configuration params. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>output stream to write to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhelayers_1_1HeContext.html#afaca4a4acec27f32dd37e8e6a5d836bc">helayers::HeContext</a>.</p>

</div>
</div>
<a id="a804748ea74a4ed1a76501d3b2ae44da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804748ea74a4ed1a76501d3b2ae44da9">&#9670;&nbsp;</a></span>publicFunctionsSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helayers::CircuitContext::publicFunctionsSupported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> &amp;&#160;</td>
          <td class="paramname"><em>publicFunctions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> object is supported by this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a>. </p>
<p>The given <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> object is assumed to be valid (see also <a class="el" href="structhelayers_1_1PublicFunctions.html#ad6186e0076c2f8431c8b330a094785f1" title="Validates that the flags specifying the supported public functions are consistent.">PublicFunctions::validate()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">publicFunctions</td><td>The <a class="el" href="structhelayers_1_1PublicFunctions.html">PublicFunctions</a> object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1HeContext.html#a7652b97ca06d2ad85e0a9049d643e0f0">helayers::HeContext</a>.</p>

</div>
</div>
<a id="ad149553a08a9a8084d0ad8025c38e140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad149553a08a9a8084d0ad8025c38e140">&#9670;&nbsp;</a></span>saveSecretKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::saveSecretKey </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>seedOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save secret key to the given ostream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The binary stream to save to. </td></tr>
    <tr><td class="paramname">seedOnly</td><td>If true, only the seed used to control the secret key's randomness will be saved, rather than the whole secret key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If this <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> doesn't have a secret key. i.e. <a class="el" href="classhelayers_1_1CircuitContext.html#a1444b31ed32939dc2b6a0b8e15a2760c" title="Returns whether this context contains a secret key.">hasSecretKey()</a> is false. </td></tr>
    <tr><td class="paramname">runtime_error</td><td>If seedOnly is true but the underlying <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> does not support secret key I/O using seeds. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhelayers_1_1HeContext.html#a9c5b7290a690379a58be426d4d021435">helayers::HeContext</a>.</p>

</div>
</div>
<a id="add3989bbbe4999b52b3576fc838de40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3989bbbe4999b52b3576fc838de40d">&#9670;&nbsp;</a></span>saveUnlabeledInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::saveUnlabeledInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1circuit_1_1AbstractIo.html">circuit::AbstractIo</a> *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record all unlabeled ctxt the circuit encountered. </p>
<p>Since ctxt that were not labeled are not input it must mean they are encrypted parameters of the circuit. With this function these ctxts can be saved to an Io to be later encrypted and be used when running the circuit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An Io to write the unlabeled ctxts to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3001ad6913087d63d6601374a333a655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3001ad6913087d63d6601374a333a655">&#9670;&nbsp;</a></span>setUnlabeledInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::setUnlabeledInput </td>
          <td>(</td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const circuit::RawValues &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chainIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record a ctxt we encounter. </p>
<p>The ctxt is added to a database of ctxts that were not labeled yet. The database include (1) the id of the ctxt; (2) the raw values of the ctxt and (3) the chain index of the ctxt. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ctxt id. </td></tr>
    <tr><td class="paramname">v</td><td>The raw values of the ctxt. </td></tr>
    <tr><td class="paramname">chainIndex</td><td>The chainIndex in which the ctxt was encrypted in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3ffe728fca48357fc913a0f79b4a932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ffe728fca48357fc913a0f79b4a932">&#9670;&nbsp;</a></span>unsetUnlabeledInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CircuitContext::unsetUnlabeledInput </td>
          <td>(</td>
          <td class="paramtype">const circuit::CtxtId &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a ctxt from the unlabeled database. </p>
<p>This typically happens when a ctxt is given a label. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the ctxt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/helayers/hebase/mockup/<a class="el" href="CircuitContext_8h_source.html">CircuitContext.h</a></li>
<li>src/helayers/hebase/mockup/CircuitContext.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
