<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17" />
    <title>HElayers SDK: helayers::CTileTensor Class Reference</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;1,700&family=Merriweather&family=Merriweather+Sans&family=Open+Sans&family=Poppins:ital@1&family=Roboto:ital,wght@0,400;1,300;1,900&display=swap"
        rel="stylesheet">
    <script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/latest/ui-shell.min.js"></script>
</head>
<body style="font-family: 'Merriweather', serif;">
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand">HElayers SDK 1.5.2.0</a>
            </div>
        </div>
    </nav>
    <div id="top">
        <bx-header aria-label="IBM Platform Name">
            <bx-header-menu-button button-label-active="Close menu" button-label-inactive="Open menu">
            </bx-header-menu-button>
            <bx-header-name href="index.html" prefix="IBM">HElayers</bx-header-name>
            <bx-header-nav menu-bar-label="IBM HElayers">
                <bx-header-nav-item href="index.html">Overview
                </bx-header-nav-item>
                <bx-header-menu menu-label="Namespaces" trigger-content="Namespaces">
                    <bx-header-menu-item href="namespaces.html">Namespace List
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Namespace Members" trigger-content="Namespace  Members">
                        <bx-header-menu-item href="namespacemembers.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_enum.html">Enumerations
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_eval.html">Enumerator
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Classes" trigger-content="Classes">
                    <bx-header-menu-item href="annotated.html">Class List
                    </bx-header-menu-item>
                    <bx-header-menu-item href="classes.html">Class Index
                    </bx-header-menu-item>
                    <bx-header-menu-item href="inherits.html">Class Hierarchy
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Class Members" trigger-content="Class Members">
                        <bx-header-menu-item href="functions.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Variables
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_enum.html">Enumerations
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Files" trigger-content="Files">
                    <bx-header-menu-item href="files.html">File List</bx-header-menu-item>
                </bx-header-menu>
            </bx-header-nav>
        </bx-header>
        <!-- do not remove this div, it is closed by doxygen! -->
        <!-- end header part --><!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehelayers.html">helayers</a></li><li class="navelem"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhelayers_1_1CTileTensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">helayers::CTileTensor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An encrypted tile tensor.  
 <a href="classhelayers_1_1CTileTensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CTileTensor_8h_source.html">CTileTensor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for helayers::CTileTensor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhelayers_1_1CTileTensor.png" usemap="#helayers::CTileTensor_map" alt=""/>
  <map id="helayers::CTileTensor_map" name="helayers::CTileTensor_map">
<area href="classhelayers_1_1TileTensor.html" title="A tile tensor object." alt="helayers::TileTensor" shape="rect" coords="0,168,151,192"/>
<area href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load." alt="helayers::Saveable" shape="rect" coords="0,112,151,136"/>
<area href="classhelayers_1_1SaveableBasic.html" title="Parent class to all objects that can be saved/loaded." alt="helayers::SaveableBasic" shape="rect" coords="0,56,151,80"/>
<area href="classhelayers_1_1Printable.html" title="An abstract class for objects that can be printed to text in a human readable way." alt="helayers::Printable" shape="rect" coords="0,0,151,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1a02ba90336ca52f1c2a38c2ad094d49"><td class="memItemLeft" align="right" valign="top"><a id="a1a02ba90336ca52f1c2a38c2ad094d49"></a>
typedef boost::numeric::ublas::tensor&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a>, <a class="el" href="classhelayers_1_1PTileTensor.html#a33079a54d3d02ac395cf76f4777d4770">PTileTensor::tensorFormat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a1a02ba90336ca52f1c2a38c2ad094d49">ExternalTensorType</a></td></tr>
<tr class="memdesc:a1a02ba90336ca52f1c2a38c2ad094d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying type used to store the external tensor. <br /></td></tr>
<tr class="separator:a1a02ba90336ca52f1c2a38c2ad094d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b927244b5c0459ec5816ce38d7616fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a0b927244b5c0459ec5816ce38d7616fa">BitwiseEvaluatorMethod</a> = <a class="el" href="classhelayers_1_1CTile.html">CTile</a>(BitwiseEvaluator::*)(const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;, const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;) const</td></tr>
<tr class="memdesc:a0b927244b5c0459ec5816ce38d7616fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies bitwise operation on each two corresponding tiles.  <a href="classhelayers_1_1CTileTensor.html#a0b927244b5c0459ec5816ce38d7616fa">More...</a><br /></td></tr>
<tr class="separator:a0b927244b5c0459ec5816ce38d7616fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0df6fd3457838c1b134acb75c2bb9395"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a0df6fd3457838c1b134acb75c2bb9395">CTileTensor</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;he)</td></tr>
<tr class="memdesc:a0df6fd3457838c1b134acb75c2bb9395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty object.  <a href="classhelayers_1_1CTileTensor.html#a0df6fd3457838c1b134acb75c2bb9395">More...</a><br /></td></tr>
<tr class="separator:a0df6fd3457838c1b134acb75c2bb9395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c05280d0717c9e5d572b6fbadd1890"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a29c05280d0717c9e5d572b6fbadd1890">CTileTensor</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;src)</td></tr>
<tr class="memdesc:a29c05280d0717c9e5d572b6fbadd1890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classhelayers_1_1CTileTensor.html#a29c05280d0717c9e5d572b6fbadd1890">More...</a><br /></td></tr>
<tr class="separator:a29c05280d0717c9e5d572b6fbadd1890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330c6496748bf9d6a6dc87c0e67e34e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a330c6496748bf9d6a6dc87c0e67e34e1">CTileTensor</a> (<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a330c6496748bf9d6a6dc87c0e67e34e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classhelayers_1_1CTileTensor.html#a330c6496748bf9d6a6dc87c0e67e34e1">More...</a><br /></td></tr>
<tr class="separator:a330c6496748bf9d6a6dc87c0e67e34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af916198c2ff2248b8f02c7d07a23213a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#af916198c2ff2248b8f02c7d07a23213a">CTileTensor</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;he, const <a class="el" href="classhelayers_1_1TTShape.html">TTShape</a> &amp;s)</td></tr>
<tr class="memdesc:af916198c2ff2248b8f02c7d07a23213a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object of a certain chape.  <a href="classhelayers_1_1CTileTensor.html#af916198c2ff2248b8f02c7d07a23213a">More...</a><br /></td></tr>
<tr class="separator:af916198c2ff2248b8f02c7d07a23213a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeeaa7805aa33ce63df7d763d0b7008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#abeeeaa7805aa33ce63df7d763d0b7008">operator=</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;src)</td></tr>
<tr class="memdesc:abeeeaa7805aa33ce63df7d763d0b7008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy other tile tensor to this one.  <a href="classhelayers_1_1CTileTensor.html#abeeeaa7805aa33ce63df7d763d0b7008">More...</a><br /></td></tr>
<tr class="separator:abeeeaa7805aa33ce63df7d763d0b7008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65a2abaeaa742f87b421b5646f4d9c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ae65a2abaeaa742f87b421b5646f4d9c7">operator=</a> (<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ae65a2abaeaa742f87b421b5646f4d9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move other tile tensor to this one.  <a href="classhelayers_1_1CTileTensor.html#ae65a2abaeaa742f87b421b5646f4d9c7">More...</a><br /></td></tr>
<tr class="separator:ae65a2abaeaa742f87b421b5646f4d9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c4ffd49112274f861d92dfabe3d259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a59c4ffd49112274f861d92dfabe3d259">add</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other)</td></tr>
<tr class="memdesc:a59c4ffd49112274f861d92dfabe3d259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise add with other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a59c4ffd49112274f861d92dfabe3d259">More...</a><br /></td></tr>
<tr class="separator:a59c4ffd49112274f861d92dfabe3d259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ffcf9913cd6f8c125b38031f08f748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a74ffcf9913cd6f8c125b38031f08f748">addRaw</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other)</td></tr>
<tr class="memdesc:a74ffcf9913cd6f8c125b38031f08f748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise add with other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a74ffcf9913cd6f8c125b38031f08f748">More...</a><br /></td></tr>
<tr class="separator:a74ffcf9913cd6f8c125b38031f08f748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bed0df245a7dc959d978f6daa91bd8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a2bed0df245a7dc959d978f6daa91bd8b">sub</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other)</td></tr>
<tr class="memdesc:a2bed0df245a7dc959d978f6daa91bd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise subtract other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> from this.  <a href="classhelayers_1_1CTileTensor.html#a2bed0df245a7dc959d978f6daa91bd8b">More...</a><br /></td></tr>
<tr class="separator:a2bed0df245a7dc959d978f6daa91bd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fa6cc58d19c1265fbdbcf276bad365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a26fa6cc58d19c1265fbdbcf276bad365">subRaw</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other)</td></tr>
<tr class="memdesc:a26fa6cc58d19c1265fbdbcf276bad365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise subtract other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> from this.  <a href="classhelayers_1_1CTileTensor.html#a26fa6cc58d19c1265fbdbcf276bad365">More...</a><br /></td></tr>
<tr class="separator:a26fa6cc58d19c1265fbdbcf276bad365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b06535811531f62a30b3a2afe6deff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a8b06535811531f62a30b3a2afe6deff1">multiply</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other)</td></tr>
<tr class="memdesc:a8b06535811531f62a30b3a2afe6deff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply with other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a8b06535811531f62a30b3a2afe6deff1">More...</a><br /></td></tr>
<tr class="separator:a8b06535811531f62a30b3a2afe6deff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2512ac1acc7f298c6cbc5e6d883338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#abf2512ac1acc7f298c6cbc5e6d883338">multiplyRaw</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other)</td></tr>
<tr class="memdesc:abf2512ac1acc7f298c6cbc5e6d883338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply with other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#abf2512ac1acc7f298c6cbc5e6d883338">More...</a><br /></td></tr>
<tr class="separator:abf2512ac1acc7f298c6cbc5e6d883338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c53d1fc6c4088a062d2194862f9349e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a8c53d1fc6c4088a062d2194862f9349e">addPlain</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain)</td></tr>
<tr class="memdesc:a8c53d1fc6c4088a062d2194862f9349e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise add with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a8c53d1fc6c4088a062d2194862f9349e">More...</a><br /></td></tr>
<tr class="separator:a8c53d1fc6c4088a062d2194862f9349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50de667923a796295b2ab64833f89d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ab50de667923a796295b2ab64833f89d7">addPlainRaw</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain)</td></tr>
<tr class="memdesc:ab50de667923a796295b2ab64833f89d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise add with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#ab50de667923a796295b2ab64833f89d7">More...</a><br /></td></tr>
<tr class="separator:ab50de667923a796295b2ab64833f89d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1311af6a0f5b4437fca29e3d7906d787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a1311af6a0f5b4437fca29e3d7906d787">subPlain</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain)</td></tr>
<tr class="memdesc:a1311af6a0f5b4437fca29e3d7906d787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise subtract other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> from this.  <a href="classhelayers_1_1CTileTensor.html#a1311af6a0f5b4437fca29e3d7906d787">More...</a><br /></td></tr>
<tr class="separator:a1311af6a0f5b4437fca29e3d7906d787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679b9b40771527c7e46d031ba8ca5b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a679b9b40771527c7e46d031ba8ca5b99">subPlainRaw</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain)</td></tr>
<tr class="memdesc:a679b9b40771527c7e46d031ba8ca5b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise subtract other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> from this.  <a href="classhelayers_1_1CTileTensor.html#a679b9b40771527c7e46d031ba8ca5b99">More...</a><br /></td></tr>
<tr class="separator:a679b9b40771527c7e46d031ba8ca5b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad832ac89738d3981cf1deaa28cc12ec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ad832ac89738d3981cf1deaa28cc12ec7">multiplyPlain</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain)</td></tr>
<tr class="memdesc:ad832ac89738d3981cf1deaa28cc12ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#ad832ac89738d3981cf1deaa28cc12ec7">More...</a><br /></td></tr>
<tr class="separator:ad832ac89738d3981cf1deaa28cc12ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4581af26329517a1e8f7a3b5e52eb12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ae4581af26329517a1e8f7a3b5e52eb12">multiplyPlainRaw</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain)</td></tr>
<tr class="memdesc:ae4581af26329517a1e8f7a3b5e52eb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#ae4581af26329517a1e8f7a3b5e52eb12">More...</a><br /></td></tr>
<tr class="separator:ae4581af26329517a1e8f7a3b5e52eb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1f5d0fa725bec4db3e735b6811ef1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a4a1f5d0fa725bec4db3e735b6811ef1b">addScalar</a> (double val, bool keepUnknownsClear=false)</td></tr>
<tr class="memdesc:a4a1f5d0fa725bec4db3e735b6811ef1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structhelayers_1_1Add.html" title="Structure to hold specification of a binary add layer in an NN.">Add</a> scalar to all tensor elements.  <a href="classhelayers_1_1CTileTensor.html#a4a1f5d0fa725bec4db3e735b6811ef1b">More...</a><br /></td></tr>
<tr class="separator:a4a1f5d0fa725bec4db3e735b6811ef1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501865ac8849faa90ca7d2c4bf84e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a7501865ac8849faa90ca7d2c4bf84e50">multiplyScalar</a> (double val)</td></tr>
<tr class="memdesc:a7501865ac8849faa90ca7d2c4bf84e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all used tensor elements by a given scalar.  <a href="classhelayers_1_1CTileTensor.html#a7501865ac8849faa90ca7d2c4bf84e50">More...</a><br /></td></tr>
<tr class="separator:a7501865ac8849faa90ca7d2c4bf84e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdbb4d944d1b8549707cdcaee715791"><td class="memItemLeft" align="right" valign="top"><a id="acbdbb4d944d1b8549707cdcaee715791"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#acbdbb4d944d1b8549707cdcaee715791">square</a> ()</td></tr>
<tr class="memdesc:acbdbb4d944d1b8549707cdcaee715791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise square. Relies on <a class="el" href="classhelayers_1_1CTile.html#a8b09a659ab979a6a2964d7ecd5245c72" title="Square content of this ciphertext, elementwise.">CTile::square</a>. <br /></td></tr>
<tr class="separator:acbdbb4d944d1b8549707cdcaee715791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6f42608dcab2430110ed727fb894bc"><td class="memItemLeft" align="right" valign="top"><a id="aea6f42608dcab2430110ed727fb894bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aea6f42608dcab2430110ed727fb894bc">squareRaw</a> ()</td></tr>
<tr class="memdesc:aea6f42608dcab2430110ed727fb894bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise squareRaw. Relies on <a class="el" href="classhelayers_1_1CTile.html#a437a7fe2eed628412eecc8220e4ae2c5" title="See square()">CTile::squareRaw</a>. <br /></td></tr>
<tr class="separator:aea6f42608dcab2430110ed727fb894bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6e40e1cca847af73e8f6095eb45889"><td class="memItemLeft" align="right" valign="top"><a id="a4e6e40e1cca847af73e8f6095eb45889"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a4e6e40e1cca847af73e8f6095eb45889">negate</a> ()</td></tr>
<tr class="memdesc:a4e6e40e1cca847af73e8f6095eb45889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise negate. Relies on <a class="el" href="classhelayers_1_1CTile.html#a29c218f241930de4c65f476c7a46ee2b" title="Negates content of this ciphertext.">CTile::negate</a>. <br /></td></tr>
<tr class="separator:a4e6e40e1cca847af73e8f6095eb45889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac392a9e935b419d4de4c8e9f2fe5976d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ac392a9e935b419d4de4c8e9f2fe5976d">multiplyAndSum</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other, int sumDim)</td></tr>
<tr class="memdesc:ac392a9e935b419d4de4c8e9f2fe5976d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs elementwise multiplication between this and other, then sums over specified dim.  <a href="classhelayers_1_1CTileTensor.html#ac392a9e935b419d4de4c8e9f2fe5976d">More...</a><br /></td></tr>
<tr class="separator:ac392a9e935b419d4de4c8e9f2fe5976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9982b8f6c7c8a2d23f6b35efa64fd634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a9982b8f6c7c8a2d23f6b35efa64fd634">multiplyPlainAndSum</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;other, int sumDim)</td></tr>
<tr class="memdesc:a9982b8f6c7c8a2d23f6b35efa64fd634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs elementwise multiplication between this and other, then sums over specified dim.  <a href="classhelayers_1_1CTileTensor.html#a9982b8f6c7c8a2d23f6b35efa64fd634">More...</a><br /></td></tr>
<tr class="separator:a9982b8f6c7c8a2d23f6b35efa64fd634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723fb7a38e1704848337ceabff8528c0"><td class="memItemLeft" align="right" valign="top"><a id="a723fb7a38e1704848337ceabff8528c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyBitwiseMethod</b> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other, const <a class="el" href="classhelayers_1_1BitwiseEvaluator.html">BitwiseEvaluator</a> &amp;be, <a class="el" href="classhelayers_1_1CTileTensor.html#a0b927244b5c0459ec5816ce38d7616fa">BitwiseEvaluatorMethod</a> method, <a class="el" href="namespacehelayers.html#a0cbe507b11499d9d4471459e936386fa">ActionType</a> actionType=<a class="el" href="namespacehelayers.html#a0cbe507b11499d9d4471459e936386faa8cdf6647a5be7fe13d227306e251ecb7">OTHER_ACTION_TYPE</a>)</td></tr>
<tr class="separator:a723fb7a38e1704848337ceabff8528c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324a02932eac74b926be33c28e553fd3"><td class="memItemLeft" align="right" valign="top"><a id="a324a02932eac74b926be33c28e553fd3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a324a02932eac74b926be33c28e553fd3">relinearize</a> ()</td></tr>
<tr class="memdesc:a324a02932eac74b926be33c28e553fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls corresponding function for every <a class="el" href="classhelayers_1_1CTile.html" title="A class representing a ciphertext.">CTile</a>. <br /></td></tr>
<tr class="separator:a324a02932eac74b926be33c28e553fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991937b6c6054b6763403eb518df164c"><td class="memItemLeft" align="right" valign="top"><a id="a991937b6c6054b6763403eb518df164c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a991937b6c6054b6763403eb518df164c">rescale</a> ()</td></tr>
<tr class="memdesc:a991937b6c6054b6763403eb518df164c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls corresponding function for every <a class="el" href="classhelayers_1_1CTile.html" title="A class representing a ciphertext.">CTile</a>. <br /></td></tr>
<tr class="separator:a991937b6c6054b6763403eb518df164c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b1ca120f864fa1eb00f05f088843f"><td class="memItemLeft" align="right" valign="top"><a id="afb4b1ca120f864fa1eb00f05f088843f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#afb4b1ca120f864fa1eb00f05f088843f">relinearizeAndRescale</a> ()</td></tr>
<tr class="memdesc:afb4b1ca120f864fa1eb00f05f088843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls corresponding functions for every <a class="el" href="classhelayers_1_1CTile.html" title="A class representing a ciphertext.">CTile</a>. <br /></td></tr>
<tr class="separator:afb4b1ca120f864fa1eb00f05f088843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ac59ce1f3866e4c8a2a921cc534343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ad4ac59ce1f3866e4c8a2a921cc534343">sumOverDim</a> (int dim)</td></tr>
<tr class="memdesc:ad4ac59ce1f3866e4c8a2a921cc534343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums over a dimension.  <a href="classhelayers_1_1CTileTensor.html#ad4ac59ce1f3866e4c8a2a921cc534343">More...</a><br /></td></tr>
<tr class="separator:ad4ac59ce1f3866e4c8a2a921cc534343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438974bc169e1ed17374bf8b64e2d76"><td class="memItemLeft" align="right" valign="top"><a id="ad438974bc169e1ed17374bf8b64e2d76"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ad438974bc169e1ed17374bf8b64e2d76">sumTilesOverDim</a> (int dim)</td></tr>
<tr class="memdesc:ad438974bc169e1ed17374bf8b64e2d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums tile over a dimension. <br /></td></tr>
<tr class="separator:ad438974bc169e1ed17374bf8b64e2d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82dc764f72f9e0093fd511d31522f28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ac82dc764f72f9e0093fd511d31522f28">sumInTilesOverDim</a> (int dim)</td></tr>
<tr class="memdesc:ac82dc764f72f9e0093fd511d31522f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum inside tiles.  <a href="classhelayers_1_1CTileTensor.html#ac82dc764f72f9e0093fd511d31522f28">More...</a><br /></td></tr>
<tr class="separator:ac82dc764f72f9e0093fd511d31522f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c375f14f9072873fc182bff1b47457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a50c375f14f9072873fc182bff1b47457">multiplyOverDim</a> (int dim)</td></tr>
<tr class="memdesc:a50c375f14f9072873fc182bff1b47457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies over a dimension.  <a href="classhelayers_1_1CTileTensor.html#a50c375f14f9072873fc182bff1b47457">More...</a><br /></td></tr>
<tr class="separator:a50c375f14f9072873fc182bff1b47457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1062f5e2a7516c155c85ab85c2ae6a0"><td class="memItemLeft" align="right" valign="top"><a id="af1062f5e2a7516c155c85ab85c2ae6a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#af1062f5e2a7516c155c85ab85c2ae6a0">multiplyTilesOverDim</a> (int dim)</td></tr>
<tr class="memdesc:af1062f5e2a7516c155c85ab85c2ae6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies tile over a dimension. <br /></td></tr>
<tr class="separator:af1062f5e2a7516c155c85ab85c2ae6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d65fc0c3ba66a5d4f580e7e3cc00aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#af1d65fc0c3ba66a5d4f580e7e3cc00aa">duplicateOverDim</a> (int dim)</td></tr>
<tr class="memdesc:af1d65fc0c3ba66a5d4f580e7e3cc00aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a dimension to become duplicated.  <a href="classhelayers_1_1CTileTensor.html#af1d65fc0c3ba66a5d4f580e7e3cc00aa">More...</a><br /></td></tr>
<tr class="separator:af1d65fc0c3ba66a5d4f580e7e3cc00aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c678a73026ddd48d97a3293d70e979"><td class="memItemLeft" align="right" valign="top"><a id="a25c678a73026ddd48d97a3293d70e979"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a25c678a73026ddd48d97a3293d70e979">clearUnknowns</a> ()</td></tr>
<tr class="memdesc:a25c678a73026ddd48d97a3293d70e979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all unknowns from this tile tensor. <br /></td></tr>
<tr class="separator:a25c678a73026ddd48d97a3293d70e979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad616f2905402805f02f6d448f5fb8822"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ad616f2905402805f02f6d448f5fb8822">flatten</a> (int startDim, int endDim)</td></tr>
<tr class="memdesc:ad616f2905402805f02f6d448f5fb8822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens consecutive fully-duplicated dimensions into a single fully-duplicated dimension.  <a href="classhelayers_1_1CTileTensor.html#ad616f2905402805f02f6d448f5fb8822">More...</a><br /></td></tr>
<tr class="separator:ad616f2905402805f02f6d448f5fb8822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e32e665c51c4fba8149b91935bf4db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a44e32e665c51c4fba8149b91935bf4db">reorderDims</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;dimOrder)</td></tr>
<tr class="memdesc:a44e32e665c51c4fba8149b91935bf4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the dimensions of this tensor.  <a href="classhelayers_1_1CTileTensor.html#a44e32e665c51c4fba8149b91935bf4db">More...</a><br /></td></tr>
<tr class="separator:a44e32e665c51c4fba8149b91935bf4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed236424d4b1aa848b16b90c6ff98fcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aed236424d4b1aa848b16b90c6ff98fcd">addDim</a> (int place=-1)</td></tr>
<tr class="memdesc:aed236424d4b1aa848b16b90c6ff98fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dim with original size and tile size 1 to this tensor at given place.  <a href="classhelayers_1_1CTileTensor.html#aed236424d4b1aa848b16b90c6ff98fcd">More...</a><br /></td></tr>
<tr class="separator:aed236424d4b1aa848b16b90c6ff98fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83b9cebc3e0d7cbfa5756b6fdc4dc45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ab83b9cebc3e0d7cbfa5756b6fdc4dc45">removeDim</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim)</td></tr>
<tr class="memdesc:ab83b9cebc3e0d7cbfa5756b6fdc4dc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a dim from this tensor.  <a href="classhelayers_1_1CTileTensor.html#ab83b9cebc3e0d7cbfa5756b6fdc4dc45">More...</a><br /></td></tr>
<tr class="separator:ab83b9cebc3e0d7cbfa5756b6fdc4dc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa198fe7856e66009ca055e83ebdfb8d2"><td class="memItemLeft" align="right" valign="top"><a id="aa198fe7856e66009ca055e83ebdfb8d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aa198fe7856e66009ca055e83ebdfb8d2">reduceChainIndex</a> ()</td></tr>
<tr class="memdesc:aa198fe7856e66009ca055e83ebdfb8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls reduceChainIndex function for every <a class="el" href="classhelayers_1_1CTile.html" title="A class representing a ciphertext.">CTile</a>. <br /></td></tr>
<tr class="separator:aa198fe7856e66009ca055e83ebdfb8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cccf16dca8b4b277692ecffe42c027"><td class="memItemLeft" align="right" valign="top"><a id="aa2cccf16dca8b4b277692ecffe42c027"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aa2cccf16dca8b4b277692ecffe42c027">setChainIndex</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other)</td></tr>
<tr class="memdesc:aa2cccf16dca8b4b277692ecffe42c027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls corresponding function for every <a class="el" href="classhelayers_1_1CTile.html" title="A class representing a ciphertext.">CTile</a>. <br /></td></tr>
<tr class="separator:aa2cccf16dca8b4b277692ecffe42c027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d588f22a5c5f45b218f6707d0dcab1"><td class="memItemLeft" align="right" valign="top"><a id="a25d588f22a5c5f45b218f6707d0dcab1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a25d588f22a5c5f45b218f6707d0dcab1">setChainIndex</a> (int chainIndex)</td></tr>
<tr class="memdesc:a25d588f22a5c5f45b218f6707d0dcab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls corresponding function for every <a class="el" href="classhelayers_1_1CTile.html" title="A class representing a ciphertext.">CTile</a>. <br /></td></tr>
<tr class="separator:a25d588f22a5c5f45b218f6707d0dcab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c908d26e8190ce6a563cba737638e5"><td class="memItemLeft" align="right" valign="top"><a id="aa4c908d26e8190ce6a563cba737638e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aa4c908d26e8190ce6a563cba737638e5">adjustChainIndex</a> (int chainIndex)</td></tr>
<tr class="memdesc:aa4c908d26e8190ce6a563cba737638e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls corresponding function for every <a class="el" href="classhelayers_1_1CTile.html" title="A class representing a ciphertext.">CTile</a>. <br /></td></tr>
<tr class="separator:aa4c908d26e8190ce6a563cba737638e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed9eaecb511e3a36a492809a79513da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aeed9eaecb511e3a36a492809a79513da">getChainIndex</a> () const override</td></tr>
<tr class="memdesc:aeed9eaecb511e3a36a492809a79513da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns chain index of tiles.  <a href="classhelayers_1_1CTileTensor.html#aeed9eaecb511e3a36a492809a79513da">More...</a><br /></td></tr>
<tr class="separator:aeed9eaecb511e3a36a492809a79513da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d0b2968f137f1a547868f20b86ca82"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a37d0b2968f137f1a547868f20b86ca82">getScale</a> () const</td></tr>
<tr class="memdesc:a37d0b2968f137f1a547868f20b86ca82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scale of the tiles.  <a href="classhelayers_1_1CTileTensor.html#a37d0b2968f137f1a547868f20b86ca82">More...</a><br /></td></tr>
<tr class="separator:a37d0b2968f137f1a547868f20b86ca82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e61da00b0ca3abb87af0716fd318103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a9e61da00b0ca3abb87af0716fd318103">reEncrypt</a> ()</td></tr>
<tr class="memdesc:a9e61da00b0ca3abb87af0716fd318103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt the <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> and encrypts it again to bring it to top chain index.  <a href="classhelayers_1_1CTileTensor.html#a9e61da00b0ca3abb87af0716fd318103">More...</a><br /></td></tr>
<tr class="separator:a9e61da00b0ca3abb87af0716fd318103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5072c3046ba78dccb605462de3f7dfc4"><td class="memItemLeft" align="right" valign="top"><a id="a5072c3046ba78dccb605462de3f7dfc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a5072c3046ba78dccb605462de3f7dfc4">fakeBootstrap</a> ()</td></tr>
<tr class="memdesc:a5072c3046ba78dccb605462de3f7dfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A testing method. <br /></td></tr>
<tr class="separator:a5072c3046ba78dccb605462de3f7dfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09829b14c896b01816604dfc752c78d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ab09829b14c896b01816604dfc752c78d">bootstrap</a> ()</td></tr>
<tr class="memdesc:ab09829b14c896b01816604dfc752c78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bootstrap on all the tiles of this tile tensor.  <a href="classhelayers_1_1CTileTensor.html#ab09829b14c896b01816604dfc752c78d">More...</a><br /></td></tr>
<tr class="separator:ab09829b14c896b01816604dfc752c78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae388f3c19d55cef33a54190a0e4daad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aae388f3c19d55cef33a54190a0e4daad">getTileAt</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;inds) const override</td></tr>
<tr class="memdesc:aae388f3c19d55cef33a54190a0e4daad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tile specified by the given indices.  <a href="classhelayers_1_1CTileTensor.html#aae388f3c19d55cef33a54190a0e4daad">More...</a><br /></td></tr>
<tr class="separator:aae388f3c19d55cef33a54190a0e4daad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aa686dda27c6780181758557a3ad71"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a41aa686dda27c6780181758557a3ad71">getTileByFlatIndex</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> i) const override</td></tr>
<tr class="memdesc:a41aa686dda27c6780181758557a3ad71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the i'th tile in a flattened order according to the first-order convention.  <a href="classhelayers_1_1CTileTensor.html#a41aa686dda27c6780181758557a3ad71">More...</a><br /></td></tr>
<tr class="separator:a41aa686dda27c6780181758557a3ad71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e48797a9f6e854d572fa17e0ec410b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a34e48797a9f6e854d572fa17e0ec410b">getAdd</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:a34e48797a9f6e854d572fa17e0ec410b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise add of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a34e48797a9f6e854d572fa17e0ec410b">More...</a><br /></td></tr>
<tr class="separator:a34e48797a9f6e854d572fa17e0ec410b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06632d5aeec7be9c0effa648ad39b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ad06632d5aeec7be9c0effa648ad39b61">getAddRaw</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:ad06632d5aeec7be9c0effa648ad39b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise add of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#ad06632d5aeec7be9c0effa648ad39b61">More...</a><br /></td></tr>
<tr class="separator:ad06632d5aeec7be9c0effa648ad39b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada756c185f80f44d85069abccae55625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ada756c185f80f44d85069abccae55625">addTo</a> (<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:ada756c185f80f44d85069abccae55625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to other.add(*this)  <a href="classhelayers_1_1CTileTensor.html#ada756c185f80f44d85069abccae55625">More...</a><br /></td></tr>
<tr class="separator:ada756c185f80f44d85069abccae55625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0d05401a154e60aa9b928e19acac2a"><td class="memItemLeft" align="right" valign="top"><a id="aae0d05401a154e60aa9b928e19acac2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aae0d05401a154e60aa9b928e19acac2a">addToRaw</a> (<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:aae0d05401a154e60aa9b928e19acac2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classhelayers_1_1CTileTensor.html#ada756c185f80f44d85069abccae55625" title="Equivalent to other.add(*this)">addTo()</a> <br /></td></tr>
<tr class="separator:aae0d05401a154e60aa9b928e19acac2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb919b20c7f70eb6d738ff1dd5db3e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#abb919b20c7f70eb6d738ff1dd5db3e36">subFrom</a> (<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:abb919b20c7f70eb6d738ff1dd5db3e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to other.sub(*this)  <a href="classhelayers_1_1CTileTensor.html#abb919b20c7f70eb6d738ff1dd5db3e36">More...</a><br /></td></tr>
<tr class="separator:abb919b20c7f70eb6d738ff1dd5db3e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10d8f8f284a0833a7eef94a7861170b"><td class="memItemLeft" align="right" valign="top"><a id="ae10d8f8f284a0833a7eef94a7861170b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ae10d8f8f284a0833a7eef94a7861170b">subFromRaw</a> (<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:ae10d8f8f284a0833a7eef94a7861170b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classhelayers_1_1CTileTensor.html#abb919b20c7f70eb6d738ff1dd5db3e36" title="Equivalent to other.sub(*this)">subFrom()</a> <br /></td></tr>
<tr class="separator:ae10d8f8f284a0833a7eef94a7861170b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dbcc88b927f45536ff66401fc4769b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a68dbcc88b927f45536ff66401fc4769b">multiplyTo</a> (<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:a68dbcc88b927f45536ff66401fc4769b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to other.multiply(*this)  <a href="classhelayers_1_1CTileTensor.html#a68dbcc88b927f45536ff66401fc4769b">More...</a><br /></td></tr>
<tr class="separator:a68dbcc88b927f45536ff66401fc4769b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af008532901d66bd19ee42da445437015"><td class="memItemLeft" align="right" valign="top"><a id="af008532901d66bd19ee42da445437015"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#af008532901d66bd19ee42da445437015">multiplyToRaw</a> (<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:af008532901d66bd19ee42da445437015"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classhelayers_1_1CTileTensor.html#a68dbcc88b927f45536ff66401fc4769b" title="Equivalent to other.multiply(*this)">multiplyTo()</a> <br /></td></tr>
<tr class="separator:af008532901d66bd19ee42da445437015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f73d3be48eea7a440480af27cc353b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a25f73d3be48eea7a440480af27cc353b">getSub</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const</td></tr>
<tr class="memdesc:a25f73d3be48eea7a440480af27cc353b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise sub of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a25f73d3be48eea7a440480af27cc353b">More...</a><br /></td></tr>
<tr class="separator:a25f73d3be48eea7a440480af27cc353b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056ab52a34fa0d5c74c50b8a86d6a727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a056ab52a34fa0d5c74c50b8a86d6a727">getSubRaw</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const</td></tr>
<tr class="memdesc:a056ab52a34fa0d5c74c50b8a86d6a727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise sub of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a056ab52a34fa0d5c74c50b8a86d6a727">More...</a><br /></td></tr>
<tr class="separator:a056ab52a34fa0d5c74c50b8a86d6a727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a06b0025e698854acbc57105976838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aa6a06b0025e698854acbc57105976838">getMultiply</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:aa6a06b0025e698854acbc57105976838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise multiplication of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#aa6a06b0025e698854acbc57105976838">More...</a><br /></td></tr>
<tr class="separator:aa6a06b0025e698854acbc57105976838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f38c177590088b40594959e7c07c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a65f38c177590088b40594959e7c07c35">getMultiplyRaw</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const override</td></tr>
<tr class="memdesc:a65f38c177590088b40594959e7c07c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise multiplication of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a65f38c177590088b40594959e7c07c35">More...</a><br /></td></tr>
<tr class="separator:a65f38c177590088b40594959e7c07c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44ff0d4db9027a65274a9593906ce60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#af44ff0d4db9027a65274a9593906ce60">getAddPlain</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain) const</td></tr>
<tr class="memdesc:af44ff0d4db9027a65274a9593906ce60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise add with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#af44ff0d4db9027a65274a9593906ce60">More...</a><br /></td></tr>
<tr class="separator:af44ff0d4db9027a65274a9593906ce60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d34fdc0d156bb9fe9ee58355fed504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a75d34fdc0d156bb9fe9ee58355fed504">getAddPlainRaw</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain) const</td></tr>
<tr class="memdesc:a75d34fdc0d156bb9fe9ee58355fed504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise add with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a75d34fdc0d156bb9fe9ee58355fed504">More...</a><br /></td></tr>
<tr class="separator:a75d34fdc0d156bb9fe9ee58355fed504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8869231b0b833dc3587f892fb246f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ac8869231b0b833dc3587f892fb246f82">getSubPlain</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain) const</td></tr>
<tr class="memdesc:ac8869231b0b833dc3587f892fb246f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise subtract with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#ac8869231b0b833dc3587f892fb246f82">More...</a><br /></td></tr>
<tr class="separator:ac8869231b0b833dc3587f892fb246f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6196f7e3bdcf2bba8bf6c8ace2fd8cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a6196f7e3bdcf2bba8bf6c8ace2fd8cf0">getSubPlainRaw</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain) const</td></tr>
<tr class="memdesc:a6196f7e3bdcf2bba8bf6c8ace2fd8cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise subtract with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a6196f7e3bdcf2bba8bf6c8ace2fd8cf0">More...</a><br /></td></tr>
<tr class="separator:a6196f7e3bdcf2bba8bf6c8ace2fd8cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0e9a7f591ed04cf952e11b0bb46c15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a7a0e9a7f591ed04cf952e11b0bb46c15">getMultiplyPlain</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain) const</td></tr>
<tr class="memdesc:a7a0e9a7f591ed04cf952e11b0bb46c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise multiplication with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a7a0e9a7f591ed04cf952e11b0bb46c15">More...</a><br /></td></tr>
<tr class="separator:a7a0e9a7f591ed04cf952e11b0bb46c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d35aa4ecd620ed7f2b70a92e819de61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a9d35aa4ecd620ed7f2b70a92e819de61">getMultiplyPlainRaw</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;plain) const</td></tr>
<tr class="memdesc:a9d35aa4ecd620ed7f2b70a92e819de61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise multiplication with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a9d35aa4ecd620ed7f2b70a92e819de61">More...</a><br /></td></tr>
<tr class="separator:a9d35aa4ecd620ed7f2b70a92e819de61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ff86191c3f1746f38b272049d457ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a81ff86191c3f1746f38b272049d457ad">getAddScalar</a> (double val) const</td></tr>
<tr class="memdesc:a81ff86191c3f1746f38b272049d457ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of addition with a scalar.  <a href="classhelayers_1_1CTileTensor.html#a81ff86191c3f1746f38b272049d457ad">More...</a><br /></td></tr>
<tr class="separator:a81ff86191c3f1746f38b272049d457ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e0739521474034fa55b872007ef37a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a43e0739521474034fa55b872007ef37a">getMultiplyScalar</a> (double val) const</td></tr>
<tr class="memdesc:a43e0739521474034fa55b872007ef37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplication with a scalar.  <a href="classhelayers_1_1CTileTensor.html#a43e0739521474034fa55b872007ef37a">More...</a><br /></td></tr>
<tr class="separator:a43e0739521474034fa55b872007ef37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65069ed04409536fe087afd4197e616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#af65069ed04409536fe087afd4197e616">getSquare</a> () const</td></tr>
<tr class="memdesc:af65069ed04409536fe087afd4197e616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise squaring.  <a href="classhelayers_1_1CTileTensor.html#af65069ed04409536fe087afd4197e616">More...</a><br /></td></tr>
<tr class="separator:af65069ed04409536fe087afd4197e616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a4abea2d7260c9184282706b31b8d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a44a4abea2d7260c9184282706b31b8d5">getSquareRaw</a> () const</td></tr>
<tr class="memdesc:a44a4abea2d7260c9184282706b31b8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise squaring.  <a href="classhelayers_1_1CTileTensor.html#a44a4abea2d7260c9184282706b31b8d5">More...</a><br /></td></tr>
<tr class="separator:a44a4abea2d7260c9184282706b31b8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61af122891134443a00f07d9bdc433ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a61af122891134443a00f07d9bdc433ca">getMultiplyAndSum</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other, int dim) const override</td></tr>
<tr class="memdesc:a61af122891134443a00f07d9bdc433ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise multiplication of this and other and summing over specified dim.  <a href="classhelayers_1_1CTileTensor.html#a61af122891134443a00f07d9bdc433ca">More...</a><br /></td></tr>
<tr class="separator:a61af122891134443a00f07d9bdc433ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a881bb3b7c5d563c8f738aee1c629a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a92a881bb3b7c5d563c8f738aee1c629a">getMultiplyPlainAndSum</a> (const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;other, int dim) const</td></tr>
<tr class="memdesc:a92a881bb3b7c5d563c8f738aee1c629a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of elementwise multiplication of this and other and summing over specified dim.  <a href="classhelayers_1_1CTileTensor.html#a92a881bb3b7c5d563c8f738aee1c629a">More...</a><br /></td></tr>
<tr class="separator:a92a881bb3b7c5d563c8f738aee1c629a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0ce4f4e7f89cda19890c8b17715226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a7a0ce4f4e7f89cda19890c8b17715226">multiplyAndSumTo</a> (<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other, int dim) const override</td></tr>
<tr class="memdesc:a7a0ce4f4e7f89cda19890c8b17715226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to other.multiplyAndSum(*this, dim)  <a href="classhelayers_1_1CTileTensor.html#a7a0ce4f4e7f89cda19890c8b17715226">More...</a><br /></td></tr>
<tr class="separator:a7a0ce4f4e7f89cda19890c8b17715226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b84124018d727d2b3247d752141979f"><td class="memItemLeft" align="right" valign="top"><a id="a5b84124018d727d2b3247d752141979f"></a>
<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a5b84124018d727d2b3247d752141979f">getRelinearize</a> () const</td></tr>
<tr class="memdesc:a5b84124018d727d2b3247d752141979f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns result with applying <a class="el" href="classhelayers_1_1CTile.html#ae80bfade41cccccc34d71273fc803570" title="Performs a relinearize operation (reducing ciphertext size after multiplication) The non-raw version ...">CTile::relinearize</a> to all tiles. <br /></td></tr>
<tr class="separator:a5b84124018d727d2b3247d752141979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28729dc73dce6c4ad60f702a7176de38"><td class="memItemLeft" align="right" valign="top"><a id="a28729dc73dce6c4ad60f702a7176de38"></a>
<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a28729dc73dce6c4ad60f702a7176de38">getRescale</a> () const</td></tr>
<tr class="memdesc:a28729dc73dce6c4ad60f702a7176de38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns result with applying <a class="el" href="classhelayers_1_1CTile.html#a9fbc95ca2869ec7cca604e6df1d2384b" title="Performs a rescale operation (reducing ciphertext modulus bits and attached meta data scale).">CTile::rescale</a> to all tiles. <br /></td></tr>
<tr class="separator:a28729dc73dce6c4ad60f702a7176de38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40124473831df17ee72b25cffb38366e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a40124473831df17ee72b25cffb38366e">getSumOverDim</a> (int dim) const</td></tr>
<tr class="memdesc:a40124473831df17ee72b25cffb38366e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns result of summing over a dimension.  <a href="classhelayers_1_1CTileTensor.html#a40124473831df17ee72b25cffb38366e">More...</a><br /></td></tr>
<tr class="separator:a40124473831df17ee72b25cffb38366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55eb019689755afc1b29c3ef88a7541d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a55eb019689755afc1b29c3ef88a7541d">getSumTilesOverDim</a> (int dim) const</td></tr>
<tr class="memdesc:a55eb019689755afc1b29c3ef88a7541d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns results of summing tiles over a dimension.  <a href="classhelayers_1_1CTileTensor.html#a55eb019689755afc1b29c3ef88a7541d">More...</a><br /></td></tr>
<tr class="separator:a55eb019689755afc1b29c3ef88a7541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679d674fbda7d82efaaf09ab90720b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a679d674fbda7d82efaaf09ab90720b5b">getSumInTilesOverDim</a> (int dim) const</td></tr>
<tr class="memdesc:a679d674fbda7d82efaaf09ab90720b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns results of summing inside tiles over a dimension.  <a href="classhelayers_1_1CTileTensor.html#a679d674fbda7d82efaaf09ab90720b5b">More...</a><br /></td></tr>
<tr class="separator:a679d674fbda7d82efaaf09ab90720b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2dedb43272f4953bcb09a5921a2ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a9c2dedb43272f4953bcb09a5921a2ce6">getDuplicateOverDim</a> (int dim) const</td></tr>
<tr class="memdesc:a9c2dedb43272f4953bcb09a5921a2ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns results of duplicating a dimension.  <a href="classhelayers_1_1CTileTensor.html#a9c2dedb43272f4953bcb09a5921a2ce6">More...</a><br /></td></tr>
<tr class="separator:a9c2dedb43272f4953bcb09a5921a2ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98630282b16c85e7969c49ba076a2413"><td class="memItemLeft" align="right" valign="top"><a id="a98630282b16c85e7969c49ba076a2413"></a>
<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a98630282b16c85e7969c49ba076a2413">getClearUnknowns</a> () const</td></tr>
<tr class="memdesc:a98630282b16c85e7969c49ba076a2413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns results after multiplying with a mask to clear unkonwns. <br /></td></tr>
<tr class="separator:a98630282b16c85e7969c49ba076a2413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbdaa7573efeb80879414ca2f66942d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a5cbdaa7573efeb80879414ca2f66942d">getFlatten</a> (int startDim, int endDim) const</td></tr>
<tr class="memdesc:a5cbdaa7573efeb80879414ca2f66942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the results after flatting some dimensions.  <a href="classhelayers_1_1CTileTensor.html#a5cbdaa7573efeb80879414ca2f66942d">More...</a><br /></td></tr>
<tr class="separator:a5cbdaa7573efeb80879414ca2f66942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc8a888a3980ff733990c093d262cdf"><td class="memItemLeft" align="right" valign="top"><a id="a3fc8a888a3980ff733990c093d262cdf"></a>
<a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a3fc8a888a3980ff733990c093d262cdf">getReduceChainIndex</a> () const</td></tr>
<tr class="memdesc:a3fc8a888a3980ff733990c093d262cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns results after applying <a class="el" href="classhelayers_1_1CTile.html#a2f1c7f4a6852c3dd7adc6982b34247d8" title="Reduces the chain-index property of the ciphertext by 1.">CTile::reduceChainIndex</a> to all tiles. <br /></td></tr>
<tr class="separator:a3fc8a888a3980ff733990c093d262cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee51df40b78f388755733001991c31e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aee51df40b78f388755733001991c31e3">getSetChainIndex</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other) const</td></tr>
<tr class="memdesc:aee51df40b78f388755733001991c31e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the results after setting chain index to equal other object.  <a href="classhelayers_1_1CTileTensor.html#aee51df40b78f388755733001991c31e3">More...</a><br /></td></tr>
<tr class="separator:aee51df40b78f388755733001991c31e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d5fe437d239be17a06ca9c08983d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ae5d5fe437d239be17a06ca9c08983d2a">getSetChainIndex</a> (int chainIndex) const</td></tr>
<tr class="memdesc:ae5d5fe437d239be17a06ca9c08983d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the results after setting chain index.  <a href="classhelayers_1_1CTileTensor.html#ae5d5fe437d239be17a06ca9c08983d2a">More...</a><br /></td></tr>
<tr class="separator:ae5d5fe437d239be17a06ca9c08983d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e8db42f19c668794eac926b79f2f89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a98e8db42f19c668794eac926b79f2f89">getConvolution</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;filters, const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> *biases, int strideRows, int strideCols) const</td></tr>
<tr class="memdesc:a98e8db42f19c668794eac926b79f2f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of convolution between this and filters, with specified strides.  <a href="classhelayers_1_1CTileTensor.html#a98e8db42f19c668794eac926b79f2f89">More...</a><br /></td></tr>
<tr class="separator:a98e8db42f19c668794eac926b79f2f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d6aa5258222498a600d9f7ac5b3f68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ac4d6aa5258222498a600d9f7ac5b3f68">getConcatenate</a> (const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;other, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim) const</td></tr>
<tr class="memdesc:ac4d6aa5258222498a600d9f7ac5b3f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the concatenation of this and other along the provided dimension.  <a href="classhelayers_1_1CTileTensor.html#ac4d6aa5258222498a600d9f7ac5b3f68">More...</a><br /></td></tr>
<tr class="separator:ac4d6aa5258222498a600d9f7ac5b3f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e9bf7d596c23c7117ee69e5035940f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ab4e9bf7d596c23c7117ee69e5035940f">getReorderDims</a> (const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;dimOrder) const</td></tr>
<tr class="memdesc:ab4e9bf7d596c23c7117ee69e5035940f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tile tensor resulted by re-ordering the dimensions of this tile tensor.  <a href="classhelayers_1_1CTileTensor.html#ab4e9bf7d596c23c7117ee69e5035940f">More...</a><br /></td></tr>
<tr class="separator:ab4e9bf7d596c23c7117ee69e5035940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bca789e587f35d57d72610a0156bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ab3bca789e587f35d57d72610a0156bca">getSlice</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> startIndex, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> sliceDepth=1) const</td></tr>
<tr class="memdesc:ab3bca789e587f35d57d72610a0156bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of the tensor in specific dimension.  <a href="classhelayers_1_1CTileTensor.html#ab3bca789e587f35d57d72610a0156bca">More...</a><br /></td></tr>
<tr class="separator:ab3bca789e587f35d57d72610a0156bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7380707120d59b1db414b09b756da050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a7380707120d59b1db414b09b756da050">setDimInterleaved</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, bool isInterleaved)</td></tr>
<tr class="memdesc:a7380707120d59b1db414b09b756da050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns interleave flag on or off for specific dim without changing the underlying tiling.  <a href="classhelayers_1_1CTileTensor.html#a7380707120d59b1db414b09b756da050">More...</a><br /></td></tr>
<tr class="separator:a7380707120d59b1db414b09b756da050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c34ea08303f3b1ab1b4418f57f212b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aa4c34ea08303f3b1ab1b4418f57f212b">rotateAlongDim</a> (int dim, int rot)</td></tr>
<tr class="memdesc:aa4c34ea08303f3b1ab1b4418f57f212b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates this <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> along the specified dimension (index (i+rot) % originalSize moves to i).  <a href="classhelayers_1_1CTileTensor.html#aa4c34ea08303f3b1ab1b4418f57f212b">More...</a><br /></td></tr>
<tr class="separator:aa4c34ea08303f3b1ab1b4418f57f212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad30f647d3d0a720db62f11215836f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#aad30f647d3d0a720db62f11215836f68">shiftAlongDim</a> (int dim, int shift)</td></tr>
<tr class="memdesc:aad30f647d3d0a720db62f11215836f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts this <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> along the specified dimension (index i+shift moves to i).  <a href="classhelayers_1_1CTileTensor.html#aad30f647d3d0a720db62f11215836f68">More...</a><br /></td></tr>
<tr class="separator:aad30f647d3d0a720db62f11215836f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c74cd6e1f943f178b93691c3d78851"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a14c74cd6e1f943f178b93691c3d78851">assertIntegrity</a> (double epsilon=1e-6) const override</td></tr>
<tr class="memdesc:a14c74cd6e1f943f178b93691c3d78851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the integrity of the tile tensor.  <a href="classhelayers_1_1CTileTensor.html#a14c74cd6e1f943f178b93691c3d78851">More...</a><br /></td></tr>
<tr class="separator:a14c74cd6e1f943f178b93691c3d78851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfffcb12a3d2f60e3ef200d322f5b301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#abfffcb12a3d2f60e3ef200d322f5b301">debugPrint</a> (const std::string &amp;title=&quot;&quot;, <a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0a">Verbosity</a> verbosity=<a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0aa9a86dd20fce918c63f5475acbd48bdfb">VERBOSITY_REGULAR</a>, std::ostream &amp;out=std::cout) const override</td></tr>
<tr class="memdesc:abfffcb12a3d2f60e3ef200d322f5b301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the content of this object.  <a href="classhelayers_1_1CTileTensor.html#abfffcb12a3d2f60e3ef200d322f5b301">More...</a><br /></td></tr>
<tr class="separator:abfffcb12a3d2f60e3ef200d322f5b301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da8b2cfcb05355d2b579f936f0bfaf3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a4da8b2cfcb05355d2b579f936f0bfaf3">getContextId</a> () const override</td></tr>
<tr class="memdesc:a4da8b2cfcb05355d2b579f936f0bfaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contextId of the <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> this object was initialized with.  <a href="classhelayers_1_1CTileTensor.html#a4da8b2cfcb05355d2b579f936f0bfaf3">More...</a><br /></td></tr>
<tr class="separator:a4da8b2cfcb05355d2b579f936f0bfaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab18f6439fec121f46d7f8325234594"><td class="memItemLeft" align="right" valign="top"><a id="a1ab18f6439fec121f46d7f8325234594"></a>
const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getHeContext</b> () const</td></tr>
<tr class="separator:a1ab18f6439fec121f46d7f8325234594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e56b4d65089681b35f28efbb28aabfc"><td class="memItemLeft" align="right" valign="top"><a id="a2e56b4d65089681b35f28efbb28aabfc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a2e56b4d65089681b35f28efbb28aabfc">sleep</a> () override</td></tr>
<tr class="memdesc:a2e56b4d65089681b35f28efbb28aabfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Ptiles, if lazyMode is LAZY_ENCODING, clear all the tiles. <br /></td></tr>
<tr class="separator:a2e56b4d65089681b35f28efbb28aabfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e6f52b035aa32474b8e315815d048e"><td class="memItemLeft" align="right" valign="top"><a id="ab8e6f52b035aa32474b8e315815d048e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ab8e6f52b035aa32474b8e315815d048e">wakeup</a> () override</td></tr>
<tr class="memdesc:ab8e6f52b035aa32474b8e315815d048e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Ptiles, encodes data if lazyMode is LAZY_ENCODING, and does nothing else. <br /></td></tr>
<tr class="separator:ab8e6f52b035aa32474b8e315815d048e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhelayers_1_1TileTensor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhelayers_1_1TileTensor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhelayers_1_1TileTensor.html">helayers::TileTensor</a></td></tr>
<tr class="memitem:afc3de565a916bd37a5a62147269bea86 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="afc3de565a916bd37a5a62147269bea86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#afc3de565a916bd37a5a62147269bea86">TileTensor</a> ()</td></tr>
<tr class="memdesc:afc3de565a916bd37a5a62147269bea86 inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty object. <br /></td></tr>
<tr class="separator:afc3de565a916bd37a5a62147269bea86 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add78ef6609db630ea852f7953616b9ad inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#add78ef6609db630ea852f7953616b9ad">TileTensor</a> (const <a class="el" href="classhelayers_1_1TTShape.html">TTShape</a> &amp;sh)</td></tr>
<tr class="memdesc:add78ef6609db630ea852f7953616b9ad inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classhelayers_1_1Tile.html" title="A class representing a tile: a vector of numbers, either encrypted or encoded.">Tile</a> Tensor object.  <a href="classhelayers_1_1TileTensor.html#add78ef6609db630ea852f7953616b9ad">More...</a><br /></td></tr>
<tr class="separator:add78ef6609db630ea852f7953616b9ad inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edb10548828bc16119a8595e795ff51 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#a1edb10548828bc16119a8595e795ff51">TileTensor</a> (<a class="el" href="classhelayers_1_1TTShape.html">TTShape</a> &amp;&amp;sh)</td></tr>
<tr class="memdesc:a1edb10548828bc16119a8595e795ff51 inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classhelayers_1_1Tile.html" title="A class representing a tile: a vector of numbers, either encrypted or encoded.">Tile</a> Tensor object.  <a href="classhelayers_1_1TileTensor.html#a1edb10548828bc16119a8595e795ff51">More...</a><br /></td></tr>
<tr class="separator:a1edb10548828bc16119a8595e795ff51 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce47f08c12628fc5a86b91b5621e4f8 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#adce47f08c12628fc5a86b91b5621e4f8">validatePacked</a> () const</td></tr>
<tr class="memdesc:adce47f08c12628fc5a86b91b5621e4f8 inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that object is packed (filled with content).  <a href="classhelayers_1_1TileTensor.html#adce47f08c12628fc5a86b91b5621e4f8">More...</a><br /></td></tr>
<tr class="separator:adce47f08c12628fc5a86b91b5621e4f8 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbe077ced76095599f35524eee32568 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="a1fbe077ced76095599f35524eee32568"></a>
const <a class="el" href="classhelayers_1_1TTShape.html">TTShape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#a1fbe077ced76095599f35524eee32568">getShape</a> () const</td></tr>
<tr class="memdesc:a1fbe077ced76095599f35524eee32568 inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this object tile tensor shape. <br /></td></tr>
<tr class="separator:a1fbe077ced76095599f35524eee32568 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd89176fae7953841b62e28192e6f9f inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="a9bd89176fae7953841b62e28192e6f9f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#a9bd89176fae7953841b62e28192e6f9f">getIsPacked</a> () const</td></tr>
<tr class="memdesc:a9bd89176fae7953841b62e28192e6f9f inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this object was packed with a tensor. <br /></td></tr>
<tr class="separator:a9bd89176fae7953841b62e28192e6f9f inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee99d8f90fce4f2a03d6cd9572f8531 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="a5ee99d8f90fce4f2a03d6cd9572f8531"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#a5ee99d8f90fce4f2a03d6cd9572f8531">getNumUsedTiles</a> () const</td></tr>
<tr class="memdesc:a5ee99d8f90fce4f2a03d6cd9572f8531 inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of tiles this tile tensor uses. <br /></td></tr>
<tr class="separator:a5ee99d8f90fce4f2a03d6cd9572f8531 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893f627d59a3d5fac25cf6f3ad5d2ba8 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="a893f627d59a3d5fac25cf6f3ad5d2ba8"></a>
<a class="el" href="classhelayers_1_1TensorIterator.html">TensorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#a893f627d59a3d5fac25cf6f3ad5d2ba8">getExternalIterator</a> () const</td></tr>
<tr class="memdesc:a893f627d59a3d5fac25cf6f3ad5d2ba8 inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for iterating over the external tensor. <br /></td></tr>
<tr class="separator:a893f627d59a3d5fac25cf6f3ad5d2ba8 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07c6a7dde2d52c28c9a03992e28812c inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#aa07c6a7dde2d52c28c9a03992e28812c">toDevice</a> (<a class="el" href="namespacehelayers.html#a3d097427c2c9f7801dd419a53571fc3f">DeviceType</a> device)</td></tr>
<tr class="memdesc:aa07c6a7dde2d52c28c9a03992e28812c inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move this <a class="el" href="classhelayers_1_1TileTensor.html" title="A tile tensor object.">TileTensor</a> to another device.  <a href="classhelayers_1_1TileTensor.html#aa07c6a7dde2d52c28c9a03992e28812c">More...</a><br /></td></tr>
<tr class="separator:aa07c6a7dde2d52c28c9a03992e28812c inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d688380d55c7c57bbd29aeb2a757259 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="a1d688380d55c7c57bbd29aeb2a757259"></a>
virtual <a class="el" href="namespacehelayers.html#a3d097427c2c9f7801dd419a53571fc3f">DeviceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#a1d688380d55c7c57bbd29aeb2a757259">getCurrentDevice</a> () const</td></tr>
<tr class="memdesc:a1d688380d55c7c57bbd29aeb2a757259 inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current device of this <a class="el" href="classhelayers_1_1TileTensor.html" title="A tile tensor object.">TileTensor</a>. <br /></td></tr>
<tr class="separator:a1d688380d55c7c57bbd29aeb2a757259 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6a3dade0eb3c3953789702e4dcc499 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="aeb6a3dade0eb3c3953789702e4dcc499"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#aeb6a3dade0eb3c3953789702e4dcc499">getEstimatedMemoryUsageBytes</a> () const</td></tr>
<tr class="memdesc:aeb6a3dade0eb3c3953789702e4dcc499 inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an estimation of the memory usage, or -1 if not supported. <br /></td></tr>
<tr class="separator:aeb6a3dade0eb3c3953789702e4dcc499 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f6e812e4124fe17c9ece7cc43f9e3d inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="ac3f6e812e4124fe17c9ece7cc43f9e3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLazyMode</b> (LazyMode lazyMode)</td></tr>
<tr class="separator:ac3f6e812e4124fe17c9ece7cc43f9e3d inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d9b18bfbb240a780b2f4b90051bf5a inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="ab9d9b18bfbb240a780b2f4b90051bf5a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setLazyChainIndex</b> (int newChainIndex)</td></tr>
<tr class="separator:ab9d9b18bfbb240a780b2f4b90051bf5a inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d11225e20713b15ccd977bb66f08b10 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top"><a id="a5d11225e20713b15ccd977bb66f08b10"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSleeping</b> () const</td></tr>
<tr class="separator:a5d11225e20713b15ccd977bb66f08b10 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a7262091cac6058ac7e54b44310944 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1TileTensor.html#aa3a7262091cac6058ac7e54b44310944">reinterpretOriginalSize</a> (<a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> dim, <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> newSize)</td></tr>
<tr class="memdesc:aa3a7262091cac6058ac7e54b44310944 inherit pub_methods_classhelayers_1_1TileTensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret a given dimension by increasing or decreasing its original size.  <a href="classhelayers_1_1TileTensor.html#aa3a7262091cac6058ac7e54b44310944">More...</a><br /></td></tr>
<tr class="separator:aa3a7262091cac6058ac7e54b44310944 inherit pub_methods_classhelayers_1_1TileTensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhelayers_1_1Saveable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhelayers_1_1Saveable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhelayers_1_1Saveable.html">helayers::Saveable</a></td></tr>
<tr class="memitem:a421c6146e25417dd661f020624d3c755 inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a421c6146e25417dd661f020624d3c755">saveToFile</a> (const std::string &amp;fileName) const</td></tr>
<tr class="memdesc:a421c6146e25417dd661f020624d3c755 inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves this <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object to a file in binary form.  <a href="classhelayers_1_1Saveable.html#a421c6146e25417dd661f020624d3c755">More...</a><br /></td></tr>
<tr class="separator:a421c6146e25417dd661f020624d3c755 inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8195b8a738a02ea66bcfb901ecc04e inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a4b8195b8a738a02ea66bcfb901ecc04e">loadFromFile</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a4b8195b8a738a02ea66bcfb901ecc04e inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads this <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object from a file saved by <a class="el" href="classhelayers_1_1Saveable.html#a421c6146e25417dd661f020624d3c755" title="Saves this Saveable object to a file in binary form.">saveToFile()</a>.  <a href="classhelayers_1_1Saveable.html#a4b8195b8a738a02ea66bcfb901ecc04e">More...</a><br /></td></tr>
<tr class="separator:a4b8195b8a738a02ea66bcfb901ecc04e inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053ff0046f989c53553c1407ba4256b2 inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top"><a id="a053ff0046f989c53553c1407ba4256b2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a053ff0046f989c53553c1407ba4256b2">getClassName</a> () const</td></tr>
<tr class="memdesc:a053ff0046f989c53553c1407ba4256b2 inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this class. <br /></td></tr>
<tr class="separator:a053ff0046f989c53553c1407ba4256b2 inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17467eaaf833680e38aba29bf6700875 inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a17467eaaf833680e38aba29bf6700875">save</a> (std::ostream &amp;stream) const</td></tr>
<tr class="memdesc:a17467eaaf833680e38aba29bf6700875 inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves this <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object to the given stream.  <a href="classhelayers_1_1Saveable.html#a17467eaaf833680e38aba29bf6700875">More...</a><br /></td></tr>
<tr class="separator:a17467eaaf833680e38aba29bf6700875 inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df02a1f94b5a11636b1611eb1829104 inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a9df02a1f94b5a11636b1611eb1829104">load</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a9df02a1f94b5a11636b1611eb1829104 inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads this <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object from the given stream.  <a href="classhelayers_1_1Saveable.html#a9df02a1f94b5a11636b1611eb1829104">More...</a><br /></td></tr>
<tr class="separator:a9df02a1f94b5a11636b1611eb1829104 inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b5202d7d5d0e88bc036a0df3bea8bf inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#ab5b5202d7d5d0e88bc036a0df3bea8bf">loadAfterLoadingHeader</a> (std::istream &amp;stream, const <a class="el" href="structhelayers_1_1SaveableHeader.html">SaveableHeader</a> &amp;header)</td></tr>
<tr class="memdesc:ab5b5202d7d5d0e88bc036a0df3bea8bf inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads this <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object from the given stream, assuming its header has already been loaded.  <a href="classhelayers_1_1Saveable.html#ab5b5202d7d5d0e88bc036a0df3bea8bf">More...</a><br /></td></tr>
<tr class="separator:ab5b5202d7d5d0e88bc036a0df3bea8bf inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b1f88194dc8ee39348356cbcd9b8c6 inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a81b1f88194dc8ee39348356cbcd9b8c6">attachInputStorage</a> (std::shared_ptr&lt; <a class="el" href="classhelayers_1_1Storage.html">Storage</a> &gt; storage)</td></tr>
<tr class="memdesc:a81b1f88194dc8ee39348356cbcd9b8c6 inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches an input <a class="el" href="classhelayers_1_1Storage.html" title="A class implementing a storage system for large objects.">Storage</a> to this object.  <a href="classhelayers_1_1Saveable.html#a81b1f88194dc8ee39348356cbcd9b8c6">More...</a><br /></td></tr>
<tr class="separator:a81b1f88194dc8ee39348356cbcd9b8c6 inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5131d0369c4f47366faa28207ac26879 inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a5131d0369c4f47366faa28207ac26879">attachOutputStorage</a> (std::shared_ptr&lt; <a class="el" href="classhelayers_1_1Storage.html">Storage</a> &gt; storage)</td></tr>
<tr class="memdesc:a5131d0369c4f47366faa28207ac26879 inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches an output <a class="el" href="classhelayers_1_1Storage.html" title="A class implementing a storage system for large objects.">Storage</a> to this object.  <a href="classhelayers_1_1Saveable.html#a5131d0369c4f47366faa28207ac26879">More...</a><br /></td></tr>
<tr class="separator:a5131d0369c4f47366faa28207ac26879 inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86712dca1adc4b08030499ddfaab4da2 inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a86712dca1adc4b08030499ddfaab4da2">flushToStorage</a> ()</td></tr>
<tr class="memdesc:a86712dca1adc4b08030499ddfaab4da2 inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">For object that is attached to an output storage, flushes some remaining data into the storage.  <a href="classhelayers_1_1Saveable.html#a86712dca1adc4b08030499ddfaab4da2">More...</a><br /></td></tr>
<tr class="separator:a86712dca1adc4b08030499ddfaab4da2 inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9b95dc6d909a6e0a1cc4eff963b5c2 inherit pub_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top"><a id="a7f9b95dc6d909a6e0a1cc4eff963b5c2"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a7f9b95dc6d909a6e0a1cc4eff963b5c2">allowsStorage</a> () const</td></tr>
<tr class="memdesc:a7f9b95dc6d909a6e0a1cc4eff963b5c2 inherit pub_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this object supports being attached to a <a class="el" href="classhelayers_1_1Storage.html" title="A class implementing a storage system for large objects.">Storage</a>. <br /></td></tr>
<tr class="separator:a7f9b95dc6d909a6e0a1cc4eff963b5c2 inherit pub_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhelayers_1_1Printable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhelayers_1_1Printable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhelayers_1_1Printable.html">helayers::Printable</a></td></tr>
<tr class="memitem:a367c7b06f92c6c5997b462c55be6e3d1 inherit pub_methods_classhelayers_1_1Printable"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Printable.html#a367c7b06f92c6c5997b462c55be6e3d1">toString</a> (<a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0a">Verbosity</a> verbosity=<a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0aa9a86dd20fce918c63f5475acbd48bdfb">VERBOSITY_REGULAR</a>) const</td></tr>
<tr class="memdesc:a367c7b06f92c6c5997b462c55be6e3d1 inherit pub_methods_classhelayers_1_1Printable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert object to string.  <a href="classhelayers_1_1Printable.html#a367c7b06f92c6c5997b462c55be6e3d1">More...</a><br /></td></tr>
<tr class="separator:a367c7b06f92c6c5997b462c55be6e3d1 inherit pub_methods_classhelayers_1_1Printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4c666dd3900b57431fb2d153a76c47c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a4c666dd3900b57431fb2d153a76c47c7">createSingleTile</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;he, const <a class="el" href="classhelayers_1_1TTShape.html">TTShape</a> &amp;shape, const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;tile)</td></tr>
<tr class="memdesc:a4c666dd3900b57431fb2d153a76c47c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> with one tile.  <a href="classhelayers_1_1CTileTensor.html#a4c666dd3900b57431fb2d153a76c47c7">More...</a><br /></td></tr>
<tr class="separator:a4c666dd3900b57431fb2d153a76c47c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67f55a394988b5f4ab43a1bb52e93bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#ad67f55a394988b5f4ab43a1bb52e93bc">createFromCTileVector</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;he, const <a class="el" href="classhelayers_1_1TTShape.html">TTShape</a> &amp;shape, const std::vector&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt; &amp;tilesVec)</td></tr>
<tr class="memdesc:ad67f55a394988b5f4ab43a1bb52e93bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> from the given vector of CTiles.  <a href="classhelayers_1_1CTileTensor.html#ad67f55a394988b5f4ab43a1bb52e93bc">More...</a><br /></td></tr>
<tr class="separator:ad67f55a394988b5f4ab43a1bb52e93bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271eb9b5096dba7d49b13e55712f51e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1CTileTensor.html#a271eb9b5096dba7d49b13e55712f51e1">combine</a> (const std::vector&lt; std::vector&lt; std::vector&lt; <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &gt;&gt;&gt; &amp;cts)</td></tr>
<tr class="memdesc:a271eb9b5096dba7d49b13e55712f51e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the given CTileTensors into one <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.  <a href="classhelayers_1_1CTileTensor.html#a271eb9b5096dba7d49b13e55712f51e1">More...</a><br /></td></tr>
<tr class="separator:a271eb9b5096dba7d49b13e55712f51e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classhelayers_1_1Saveable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classhelayers_1_1Saveable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classhelayers_1_1Saveable.html">helayers::Saveable</a></td></tr>
<tr class="memitem:a5e55c8c346a5ab0e67dcbbacc56cccc9 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">static std::ofstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a5e55c8c346a5ab0e67dcbbacc56cccc9">openBinaryOfstream</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a5e55c8c346a5ab0e67dcbbacc56cccc9 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file output stream.  <a href="classhelayers_1_1Saveable.html#a5e55c8c346a5ab0e67dcbbacc56cccc9">More...</a><br /></td></tr>
<tr class="separator:a5e55c8c346a5ab0e67dcbbacc56cccc9 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38940f830f510f3be93baafcc0cb461f inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">static std::ifstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a38940f830f510f3be93baafcc0cb461f">openBinaryIfstream</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a38940f830f510f3be93baafcc0cb461f inherit pub_static_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file input stream.  <a href="classhelayers_1_1Saveable.html#a38940f830f510f3be93baafcc0cb461f">More...</a><br /></td></tr>
<tr class="separator:a38940f830f510f3be93baafcc0cb461f inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706433ee0946120aff5e3cd873fbde50 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a706433ee0946120aff5e3cd873fbde50">internalRegisterSaveable</a> (const std::string &amp;className, LoadFunction loadFunction)</td></tr>
<tr class="memdesc:a706433ee0946120aff5e3cd873fbde50 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object for the purpose of dynamic loading.  <a href="classhelayers_1_1Saveable.html#a706433ee0946120aff5e3cd873fbde50">More...</a><br /></td></tr>
<tr class="separator:a706433ee0946120aff5e3cd873fbde50 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ffa5c0dc50d9c13feb7dcd785e3ffa inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classhelayers_1_1Saveable.html">Saveable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#af4ffa5c0dc50d9c13feb7dcd785e3ffa">load</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;context, std::istream &amp;stream)</td></tr>
<tr class="memdesc:af4ffa5c0dc50d9c13feb7dcd785e3ffa inherit pub_static_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object stored in the given stream.  <a href="classhelayers_1_1Saveable.html#af4ffa5c0dc50d9c13feb7dcd785e3ffa">More...</a><br /></td></tr>
<tr class="separator:af4ffa5c0dc50d9c13feb7dcd785e3ffa inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e9ad5cac53a5d7a4f05fff5de3707c inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classhelayers_1_1Saveable.html">Saveable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#ad0e9ad5cac53a5d7a4f05fff5de3707c">loadFromFile</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;context, const std::string &amp;fileName)</td></tr>
<tr class="memdesc:ad0e9ad5cac53a5d7a4f05fff5de3707c inherit pub_static_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object stored in the given file.  <a href="classhelayers_1_1Saveable.html#ad0e9ad5cac53a5d7a4f05fff5de3707c">More...</a><br /></td></tr>
<tr class="separator:ad0e9ad5cac53a5d7a4f05fff5de3707c inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622697cf6188058d5c0bac65d0088226 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a622697cf6188058d5c0bac65d0088226 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a622697cf6188058d5c0bac65d0088226">loadAndVerifyClass</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;context, std::istream &amp;stream, const std::string &amp;className)</td></tr>
<tr class="memdesc:a622697cf6188058d5c0bac65d0088226 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an object stored in the given stream, verifying the result is a class T object.  <a href="classhelayers_1_1Saveable.html#a622697cf6188058d5c0bac65d0088226">More...</a><br /></td></tr>
<tr class="separator:a622697cf6188058d5c0bac65d0088226 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4becce47199312a7a0399729014513f1 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memTemplParams" colspan="2"><a id="a4becce47199312a7a0399729014513f1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4becce47199312a7a0399729014513f1 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhelayers_1_1Saveable.html#a4becce47199312a7a0399729014513f1">loadFromFileAndVerifyClass</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;context, const std::string &amp;fileName, const std::string &amp;className)</td></tr>
<tr class="memdesc:a4becce47199312a7a0399729014513f1 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classhelayers_1_1Saveable.html#a622697cf6188058d5c0bac65d0088226" title="Loads an object stored in the given stream, verifying the result is a class T object.">loadAndVerifyClass()</a> <br /></td></tr>
<tr class="separator:a4becce47199312a7a0399729014513f1 inherit pub_static_methods_classhelayers_1_1Saveable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad74b119eea8fbf86ad1340cc6edb89b3"><td class="memItemLeft" align="right" valign="top"><a id="ad74b119eea8fbf86ad1340cc6edb89b3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MinMaxEvaluator</b></td></tr>
<tr class="separator:ad74b119eea8fbf86ad1340cc6edb89b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f37fc7ee897607dd9874cffeafc411"><td class="memItemLeft" align="right" valign="top"><a id="aa7f37fc7ee897607dd9874cffeafc411"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TTEncoder</b></td></tr>
<tr class="separator:aa7f37fc7ee897607dd9874cffeafc411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfe3016e7108d40a090145f05ad4d13"><td class="memItemLeft" align="right" valign="top"><a id="a6dfe3016e7108d40a090145f05ad4d13"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TTConvolution</b></td></tr>
<tr class="separator:a6dfe3016e7108d40a090145f05ad4d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5d8eec567d4ec5ffecbf7a5f38d87d"><td class="memItemLeft" align="right" valign="top"><a id="a3c5d8eec567d4ec5ffecbf7a5f38d87d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TTConvolutionInterleaved</b></td></tr>
<tr class="separator:a3c5d8eec567d4ec5ffecbf7a5f38d87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaa0ca3e3c952fbb0d42c1a66e3d9a5"><td class="memItemLeft" align="right" valign="top"><a id="afbaa0ca3e3c952fbb0d42c1a66e3d9a5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TTFunctionEvaluator</b></td></tr>
<tr class="separator:afbaa0ca3e3c952fbb0d42c1a66e3d9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7728a5dafbc28f3f4bd1a645ff40e2b6"><td class="memItemLeft" align="right" valign="top"><a id="a7728a5dafbc28f3f4bd1a645ff40e2b6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TTPermutator</b></td></tr>
<tr class="separator:a7728a5dafbc28f3f4bd1a645ff40e2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6f95e59452e130f2865a08368f9ff5"><td class="memItemLeft" align="right" valign="top"><a id="a0a6f95e59452e130f2865a08368f9ff5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AesTtPacker</b></td></tr>
<tr class="separator:a0a6f95e59452e130f2865a08368f9ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2491fa957ff0a7a5aa63aba7853768"><td class="memItemLeft" align="right" valign="top"><a id="ace2491fa957ff0a7a5aa63aba7853768"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>circuit::Runner</b></td></tr>
<tr class="separator:ace2491fa957ff0a7a5aa63aba7853768"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An encrypted tile tensor. </p>
<p>A tile tensor is a data structure for storing tensors (multipy dimensional arrays, e.g., vectors, matrices, or higher dimensional arrays) in a set of fixed size tiles, in this case ciphertexts. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0b927244b5c0459ec5816ce38d7616fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b927244b5c0459ec5816ce38d7616fa">&#9670;&nbsp;</a></span>BitwiseEvaluatorMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhelayers_1_1CTileTensor.html#a0b927244b5c0459ec5816ce38d7616fa">helayers::CTileTensor::BitwiseEvaluatorMethod</a> =  <a class="el" href="classhelayers_1_1CTile.html">CTile</a> (BitwiseEvaluator::*)(const <a class="el" href="classhelayers_1_1CTile.html">CTile</a>&amp;, const <a class="el" href="classhelayers_1_1CTile.html">CTile</a>&amp;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies bitwise operation on each two corresponding tiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other encrypted tile tensor </td></tr>
    <tr><td class="paramname">be</td><td><a class="el" href="classhelayers_1_1BitwiseEvaluator.html" title="Used to perform operations on bitwise CTiles.">BitwiseEvaluator</a> of the <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> corresponding to this <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> </td></tr>
    <tr><td class="paramname">method</td><td>A <a class="el" href="classhelayers_1_1BitwiseEvaluator.html" title="Used to perform operations on bitwise CTiles.">BitwiseEvaluator</a> method to apply. The method must receive two CTiles as input and return a <a class="el" href="classhelayers_1_1CTile.html" title="A class representing a ciphertext.">CTile</a> </td></tr>
    <tr><td class="paramname">actionType</td><td>Indication whether this is an ADDITIVE_ACTION_TYPE, a MULTIPLICATIVE_ACTION_TYPE, or OTHER_ACTION_TYPE. The default is OTHER_ACTION_TYPE, the most restrictive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0df6fd3457838c1b134acb75c2bb9395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df6fd3457838c1b134acb75c2bb9395">&#9670;&nbsp;</a></span>CTileTensor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::CTileTensor::CTileTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">he</td><td>the context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29c05280d0717c9e5d572b6fbadd1890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c05280d0717c9e5d572b6fbadd1890">&#9670;&nbsp;</a></span>CTileTensor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::CTileTensor::CTileTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>object to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a330c6496748bf9d6a6dc87c0e67e34e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330c6496748bf9d6a6dc87c0e67e34e1">&#9670;&nbsp;</a></span>CTileTensor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::CTileTensor::CTileTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>object to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af916198c2ff2248b8f02c7d07a23213a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af916198c2ff2248b8f02c7d07a23213a">&#9670;&nbsp;</a></span>CTileTensor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::CTileTensor::CTileTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1TTShape.html">TTShape</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an object of a certain chape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">he</td><td>the context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>shape of new object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isPacked</td><td>TRUE if this tensor is filled with value, FALSE otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a59c4ffd49112274f861d92dfabe3d259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c4ffd49112274f861d92dfabe3d259">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise add with other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a053bdc6712b1f0d66064d16c35039889" title="Add content of another ciphertext to this one, elementwise.">CTile::add</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed236424d4b1aa848b16b90c6ff98fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed236424d4b1aa848b16b90c6ff98fcd">&#9670;&nbsp;</a></span>addDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::addDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>place</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a dim with original size and tile size 1 to this tensor at given place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">place</td><td>Place of the new dimension, default is last. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c53d1fc6c4088a062d2194862f9349e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c53d1fc6c4088a062d2194862f9349e">&#9670;&nbsp;</a></span>addPlain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::addPlain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise add with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a4d21e30fd9e7574fbabc53c5f00854ad" title="Add content of another PTile to this one, elementwise.">CTile::addPlain</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50de667923a796295b2ab64833f89d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50de667923a796295b2ab64833f89d7">&#9670;&nbsp;</a></span>addPlainRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::addPlainRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise add with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a2e32f155938ebbd99967df53140501d1" title="See addPlain()">CTile::addPlainRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74ffcf9913cd6f8c125b38031f08f748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ffcf9913cd6f8c125b38031f08f748">&#9670;&nbsp;</a></span>addRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::addRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise add with other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a6ccd08a025528918680a33a439aed432" title="See add()">CTile::addRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a1f5d0fa725bec4db3e735b6811ef1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1f5d0fa725bec4db3e735b6811ef1b">&#9670;&nbsp;</a></span>addScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::addScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepUnknownsClear</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structhelayers_1_1Add.html" title="Structure to hold specification of a binary add layer in an NN.">Add</a> scalar to all tensor elements. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a2c7e42ad421978e6c25f50f75c92309d" title="Adds an int scalar value to all slots in this ciphertext.">CTile::addScalar</a>. Will add unknowns to unused slots, unless the keepUnknownsClear is set, which causes a more costly operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepUnknownsClear</td><td>If set and current shape has no unknowns, it will keep it that way. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada756c185f80f44d85069abccae55625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada756c185f80f44d85069abccae55625">&#9670;&nbsp;</a></span>addTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::addTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to other.add(*this) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#a7eaba15a4638b5323138176cbda9bdc4">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="a14c74cd6e1f943f178b93691c3d78851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c74cd6e1f943f178b93691c3d78851">&#9670;&nbsp;</a></span>assertIntegrity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double helayers::CTileTensor::assertIntegrity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-6</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the integrity of the tile tensor. </p>
<p>Used for internal checks only. Returns the maximal diff found. If uninitialized, returns 0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>Tolerance for diffs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if test fails </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#ac0338c9b6d25dd89a4d305d4363546d7">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="ab09829b14c896b01816604dfc752c78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09829b14c896b01816604dfc752c78d">&#9670;&nbsp;</a></span>bootstrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::bootstrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs bootstrap on all the tiles of this tile tensor. </p>

</div>
</div>
<a id="a271eb9b5096dba7d49b13e55712f51e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271eb9b5096dba7d49b13e55712f51e1">&#9670;&nbsp;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::combine </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines the given CTileTensors into one <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>All of the given CTileTensors must have the same shape and chain index. Let cts be of dimensions [d0,d1,d2]. The shape of the combined <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> is given by adding the dimensions [d0/1,d1/2,d2/1] to the shape of the given CTileTensors. cts[i][j][k][...] will be copied into indexes [i,j,k,...] of the combined <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cts</td><td>A 3D tensor of CTileTensors to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_Argument</td><td>If "cts" does not represent a 3D tensor (e.g. if cts[i].size() != cts[j].size() for some i,j). </td></tr>
    <tr><td class="paramname">invalid_argument</td><td>If one of cts, cts[0] or cts[0][0] is an empty vector. </td></tr>
    <tr><td class="paramname">invalid_arugment</td><td>If the given CTileTensors don't have different shapes or different chain indexes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad67f55a394988b5f4ab43a1bb52e93bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67f55a394988b5f4ab43a1bb52e93bc">&#9670;&nbsp;</a></span>createFromCTileVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::createFromCTileVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1TTShape.html">TTShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tilesVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> from the given vector of CTiles. </p>
<p>"tilesVec" vector is expected to have a first-order orientation. The created <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> will have the given shape, which is assumed to be complete (i.e. with all original sizes set), not to contain any duplicated dims and to have all unused slots unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">he</td><td>The <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> to initialize the created <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> with. </td></tr>
    <tr><td class="paramname">shape</td><td>The shape of the resulting <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </td></tr>
    <tr><td class="paramname">tilesVec</td><td>The vector of CTiles, in first-order orientation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>If "shape" doesn't satisfy the above assumptions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c666dd3900b57431fb2d153a76c47c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c666dd3900b57431fb2d153a76c47c7">&#9670;&nbsp;</a></span>createSingleTile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::createSingleTile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1TTShape.html">TTShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> with one tile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">he</td><td>The <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a>. </td></tr>
    <tr><td class="paramname">shape</td><td>The shape of the <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to create. Each dimension of this shape must be either incomplete, t_i/t_i or n_i?/t_i for n_i &lt; t_i. If a dimension is incomplete, it will be replaced with t_i/t_i in the resulting <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </td></tr>
    <tr><td class="paramname">tile</td><td>The only tile of the created CTileTesnor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>If the given shape does not satisfy the requirement above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfffcb12a3d2f60e3ef200d322f5b301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfffcb12a3d2f60e3ef200d322f5b301">&#9670;&nbsp;</a></span>debugPrint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::debugPrint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0a">Verbosity</a>&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code><a class="el" href="namespacehelayers.html#a0b1d384996d0750615cff777874cac0aa9a86dd20fce918c63f5475acbd48bdfb">VERBOSITY_REGULAR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the content of this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td>Text to add to the print </td></tr>
    <tr><td class="paramname">verbosity</td><td>Verbosity level </td></tr>
    <tr><td class="paramname">out</td><td>Output stream </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhelayers_1_1SaveableBasic.html#a358d2b3c4d78745ad008490663c49201">helayers::SaveableBasic</a>.</p>

</div>
</div>
<a id="af1d65fc0c3ba66a5d4f580e7e3cc00aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d65fc0c3ba66a5d4f580e7e3cc00aa">&#9670;&nbsp;</a></span>duplicateOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::duplicateOverDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause a dimension to become duplicated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension to duplicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad616f2905402805f02f6d448f5fb8822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad616f2905402805f02f6d448f5fb8822">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::flatten </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens consecutive fully-duplicated dimensions into a single fully-duplicated dimension. </p>
<p>The Flattened dimension will have tile size equals to the product of tile sizes of all the flattened dimensions, and will be considered interleaved if and only if all the flattened dimensions are. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startDim</td><td>The first dimension to be flattened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endDim</td><td>The dimension in which to end the flattening (exclusive). Flatten(a, b) will flatten dimensions [a,b). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If the specified dimensions do not exist, or are not fully duplicated, or if startDim &gt;= endDim. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34e48797a9f6e854d572fa17e0ec410b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e48797a9f6e854d572fa17e0ec410b">&#9670;&nbsp;</a></span>getAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of elementwise add of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a053bdc6712b1f0d66064d16c35039889" title="Add content of another ciphertext to this one, elementwise.">CTile::add</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#a7e2ed32551bdec00d942b1a41a6eb792">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="af44ff0d4db9027a65274a9593906ce60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44ff0d4db9027a65274a9593906ce60">&#9670;&nbsp;</a></span>getAddPlain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getAddPlain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise add with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a4d21e30fd9e7574fbabc53c5f00854ad" title="Add content of another PTile to this one, elementwise.">CTile::addPlain</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75d34fdc0d156bb9fe9ee58355fed504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d34fdc0d156bb9fe9ee58355fed504">&#9670;&nbsp;</a></span>getAddPlainRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getAddPlainRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise add with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a2e32f155938ebbd99967df53140501d1" title="See addPlain()">CTile::addPlainRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad06632d5aeec7be9c0effa648ad39b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06632d5aeec7be9c0effa648ad39b61">&#9670;&nbsp;</a></span>getAddRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getAddRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of elementwise add of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a6ccd08a025528918680a33a439aed432" title="See add()">CTile::addRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#aaccaee11d5ac01047a4ab6b118fb7474">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="a81ff86191c3f1746f38b272049d457ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ff86191c3f1746f38b272049d457ad">&#9670;&nbsp;</a></span>getAddScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getAddScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of addition with a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Scalar to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeed9eaecb511e3a36a492809a79513da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed9eaecb511e3a36a492809a79513da">&#9670;&nbsp;</a></span>getChainIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int helayers::CTileTensor::getChainIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns chain index of tiles. </p>
<p>They are maintained to have equal chain index. </p>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#a6e0c806e241d55a77fc31b9bbebdec36">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="ac4d6aa5258222498a600d9f7ac5b3f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d6aa5258222498a600d9f7ac5b3f68">&#9670;&nbsp;</a></span>getConcatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getConcatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the concatenation of this and other along the provided dimension. </p>
<p>This operation may consume one chain index, and may clear unknown values as a side effect. The shapes of this and other must: (1) have the same number of dimensions. (2) for every dimention other than the concatenation dimention, dimention must be equal on original slots (same tile size, original size, interleaved mode, interleaved external size). (3) the concatenation dimention must have the same tile sizes, with no duplicaited values and not in interleaved mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other tile tensor to concatenate to this. </td></tr>
    <tr><td class="paramname">dim</td><td>The dimension to concatenate along. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4da8b2cfcb05355d2b579f936f0bfaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da8b2cfcb05355d2b579f936f0bfaf3">&#9670;&nbsp;</a></span>getContextId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t helayers::CTileTensor::getContextId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contextId of the <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> this object was initialized with. </p>
<p>This contextId can be used, for example, to verify heContext match when loading a saved <a class="el" href="classhelayers_1_1Saveable.html" title="Parent class to all object that the user can save/load.">Saveable</a> object. </p>

<p>Implements <a class="el" href="classhelayers_1_1Saveable.html">helayers::Saveable</a>.</p>

</div>
</div>
<a id="a98e8db42f19c668794eac926b79f2f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e8db42f19c668794eac926b79f2f89">&#9670;&nbsp;</a></span>getConvolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getConvolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> *&#160;</td>
          <td class="paramname"><em>biases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strideRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strideCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of convolution between this and filters, with specified strides. </p>
<p>Assumes all tensors are packed in SIMD fashion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Convolution filters </td></tr>
    <tr><td class="paramname">biases</td><td>Biases to add (optional) </td></tr>
    <tr><td class="paramname">strideRows</td><td>Filter strides on rows </td></tr>
    <tr><td class="paramname">strideCols</td><td>Filter strides on cols </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c2dedb43272f4953bcb09a5921a2ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2dedb43272f4953bcb09a5921a2ce6">&#9670;&nbsp;</a></span>getDuplicateOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getDuplicateOverDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns results of duplicating a dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension duplicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cbdaa7573efeb80879414ca2f66942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbdaa7573efeb80879414ca2f66942d">&#9670;&nbsp;</a></span>getFlatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getFlatten </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results after flatting some dimensions. </p>
<p>See <a class="el" href="classhelayers_1_1CTileTensor.html#ad616f2905402805f02f6d448f5fb8822" title="Flattens consecutive fully-duplicated dimensions into a single fully-duplicated dimension.">flatten()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startDim</td><td>The first dimension to be flattened. </td></tr>
    <tr><td class="paramname">endDim</td><td>The dimension in which to end the flattening (exclusive). Flatten(a, b) will flatten dimensions [a,b). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6a06b0025e698854acbc57105976838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a06b0025e698854acbc57105976838">&#9670;&nbsp;</a></span>getMultiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of elementwise multiplication of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a023053439f5f41d904fc8d68f2d9482e" title="Multiply another ciphertext with this one, elementwise.">CTile::multiply</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to multiply. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#ab1bff4ad15b0f9926006068b92ebc4d9">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="a61af122891134443a00f07d9bdc433ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61af122891134443a00f07d9bdc433ca">&#9670;&nbsp;</a></span>getMultiplyAndSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getMultiplyAndSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of elementwise multiplication of this and other and summing over specified dim. </p>
<p>See <a class="el" href="classhelayers_1_1CTileTensor.html#ac392a9e935b419d4de4c8e9f2fe5976d" title="Performs elementwise multiplication between this and other, then sums over specified dim.">CTileTensor::multiplyAndSum</a> for usage examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other encrypted tile tensor </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension to sum over </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#aba8d6cd3181454e889b54fe0c150efab">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="a7a0e9a7f591ed04cf952e11b0bb46c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0e9a7f591ed04cf952e11b0bb46c15">&#9670;&nbsp;</a></span>getMultiplyPlain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getMultiplyPlain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise multiplication with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a11eb3f7c2e9f2c637b6b0d3e09de8bad" title="Multiply a PTile with this CTile, elementwise.">CTile::multiplyPlain</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to multiply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92a881bb3b7c5d563c8f738aee1c629a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a881bb3b7c5d563c8f738aee1c629a">&#9670;&nbsp;</a></span>getMultiplyPlainAndSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getMultiplyPlainAndSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of elementwise multiplication of this and other and summing over specified dim. </p>
<p>See <a class="el" href="classhelayers_1_1CTileTensor.html#ac392a9e935b419d4de4c8e9f2fe5976d" title="Performs elementwise multiplication between this and other, then sums over specified dim.">CTileTensor::multiplyAndSum</a> for usage examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other encoded tile tensor </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension to sum over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d35aa4ecd620ed7f2b70a92e819de61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d35aa4ecd620ed7f2b70a92e819de61">&#9670;&nbsp;</a></span>getMultiplyPlainRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getMultiplyPlainRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise multiplication with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a4aa7e1c8e0d46abd1f5bfaa16895952e" title="See multiplyPlain()">CTile::multiplyPlainRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to multiply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65f38c177590088b40594959e7c07c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f38c177590088b40594959e7c07c35">&#9670;&nbsp;</a></span>getMultiplyRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getMultiplyRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of elementwise multiplication of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a014dec959e475c1f7f9e5bdd3438bc37" title="see multiply()">CTile::multiplyRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to multiply. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#af92cd30887a4eb3ad7881f73c461a7b2">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="a43e0739521474034fa55b872007ef37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e0739521474034fa55b872007ef37a">&#9670;&nbsp;</a></span>getMultiplyScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getMultiplyScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of multiplication with a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Scalar to multiply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4e9bf7d596c23c7117ee69e5035940f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e9bf7d596c23c7117ee69e5035940f">&#9670;&nbsp;</a></span>getReorderDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getReorderDims </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimOrder</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tile tensor resulted by re-ordering the dimensions of this tile tensor. </p>
<p>This operation may consume one chain index, and may clear unknown values as a side effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimOrder</td><td>The new order of dimensions, must include all the dimensions of the tile tensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d0b2968f137f1a547868f20b86ca82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d0b2968f137f1a547868f20b86ca82">&#9670;&nbsp;</a></span>getScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helayers::CTileTensor::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the scale of the tiles. </p>
<p>They are maintained to have equal scales. </p>

</div>
</div>
<a id="aee51df40b78f388755733001991c31e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee51df40b78f388755733001991c31e3">&#9670;&nbsp;</a></span>getSetChainIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSetChainIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results after setting chain index to equal other object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other object to take chain index from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d5fe437d239be17a06ca9c08983d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d5fe437d239be17a06ca9c08983d2a">&#9670;&nbsp;</a></span>getSetChainIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSetChainIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chainIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results after setting chain index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chainIndex</td><td>Chain index to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3bca789e587f35d57d72610a0156bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bca789e587f35d57d72610a0156bca">&#9670;&nbsp;</a></span>getSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>sliceDepth</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a slice of the tensor in specific dimension. </p>
<p>Result has the same number of dimensions as the original tensor. For dim with tile size of 1, getSlice is supported for every valid startIndex and sliceDepth. For a non-interleaved dim with tile size &gt; 1, getSlice is supported only for startIndex which is a multiple of the tile size. For interleaved dim with tile size &gt; 1, getSlice is supported only for startIndex 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The dimension to slice along. Specifying negative value will count from the last dim backwards (-1 for the last dim, -2 for the previoud one etc.). </td></tr>
    <tr><td class="paramname">startIndex</td><td>The index to start slicing at along the dimension </td></tr>
    <tr><td class="paramname">sliceDepth</td><td>The depth/size of the slice along the dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>If the given dimension is greater or equal to the total number of dimensions in this <a class="el" href="classhelayers_1_1TileTensor.html" title="A tile tensor object.">TileTensor</a> </td></tr>
    <tr><td class="paramname">invalid_argument</td><td>If startIndex + sliceDepth is greater than the original size of the given dimension. </td></tr>
    <tr><td class="paramname">invalid_argument</td><td>If the tile size of the given dimension is different than 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af65069ed04409536fe087afd4197e616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65069ed04409536fe087afd4197e616">&#9670;&nbsp;</a></span>getSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSquare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise squaring. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a8b09a659ab979a6a2964d7ecd5245c72" title="Square content of this ciphertext, elementwise.">CTile::square</a>. </p>

</div>
</div>
<a id="a44a4abea2d7260c9184282706b31b8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a4abea2d7260c9184282706b31b8d5">&#9670;&nbsp;</a></span>getSquareRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSquareRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise squaring. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a437a7fe2eed628412eecc8220e4ae2c5" title="See square()">CTile::squareRaw</a>. </p>

</div>
</div>
<a id="a25f73d3be48eea7a440480af27cc353b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f73d3be48eea7a440480af27cc353b">&#9670;&nbsp;</a></span>getSub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise sub of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a47ee8fdfb7373fe357dd11d8158a8683" title="Subtract content of another ciphertext from this one, elementwise.">CTile::sub</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to sub. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8869231b0b833dc3587f892fb246f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8869231b0b833dc3587f892fb246f82">&#9670;&nbsp;</a></span>getSubPlain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSubPlain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise subtract with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a58f4ca21f819eaf447eb8698d1c446ec" title="Subtract content of another PTile from this one, elementwise.">CTile::subPlain</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to subtract. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6196f7e3bdcf2bba8bf6c8ace2fd8cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6196f7e3bdcf2bba8bf6c8ace2fd8cf0">&#9670;&nbsp;</a></span>getSubPlainRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSubPlainRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise subtract with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a4b1f0d344509b0f54367b1eb53e344d5" title="See subPlain()">CTile::subPlainRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to subtract. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a056ab52a34fa0d5c74c50b8a86d6a727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056ab52a34fa0d5c74c50b8a86d6a727">&#9670;&nbsp;</a></span>getSubRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSubRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of elementwise sub of this and other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a76da694be5e95438a8fe545112574666" title="See sub()">CTile::subRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to sub. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a679d674fbda7d82efaaf09ab90720b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679d674fbda7d82efaaf09ab90720b5b">&#9670;&nbsp;</a></span>getSumInTilesOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSumInTilesOverDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns results of summing inside tiles over a dimension. </p>
<p>Note this is function is used as an intermediate step when summing over dim. Most users should call <a class="el" href="classhelayers_1_1CTileTensor.html#a40124473831df17ee72b25cffb38366e" title="Returns result of summing over a dimension.">getSumOverDim()</a> directly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to sum over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40124473831df17ee72b25cffb38366e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40124473831df17ee72b25cffb38366e">&#9670;&nbsp;</a></span>getSumOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSumOverDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns result of summing over a dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to sum over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55eb019689755afc1b29c3ef88a7541d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55eb019689755afc1b29c3ef88a7541d">&#9670;&nbsp;</a></span>getSumTilesOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> helayers::CTileTensor::getSumTilesOverDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns results of summing tiles over a dimension. </p>
<p>Note this is function is used as an intermediate step when summing over dim. Most users should call <a class="el" href="classhelayers_1_1CTileTensor.html#a40124473831df17ee72b25cffb38366e" title="Returns result of summing over a dimension.">getSumOverDim()</a> directly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to sum over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae388f3c19d55cef33a54190a0e4daad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae388f3c19d55cef33a54190a0e4daad">&#9670;&nbsp;</a></span>getTileAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a>&amp; helayers::CTileTensor::getTileAt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tile specified by the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inds</td><td>Indices of tiles. Their number should match the number of dimensions, except trailing trivial dimensions where the external size is 1 which may be omitted. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#a6e55bbea9c87c76da51030eaa4ae73d7">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="a41aa686dda27c6780181758557a3ad71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41aa686dda27c6780181758557a3ad71">&#9670;&nbsp;</a></span>getTileByFlatIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a>&amp; helayers::CTileTensor::getTileByFlatIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the i'th tile in a flattened order according to the first-order convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of tile </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#a6404731b660d8b308809100bc852a9df">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="a8b06535811531f62a30b3a2afe6deff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b06535811531f62a30b3a2afe6deff1">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise multiply with other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a023053439f5f41d904fc8d68f2d9482e" title="Multiply another ciphertext with this one, elementwise.">CTile::multiply</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to multiply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac392a9e935b419d4de4c8e9f2fe5976d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac392a9e935b419d4de4c8e9f2fe5976d">&#9670;&nbsp;</a></span>multiplyAndSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiplyAndSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sumDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs elementwise multiplication between this and other, then sums over specified dim. </p>
<p>Example usages: If both are vectors of same length, sum over dim 0 to get inner product If this is a matrix [a/t1,b/t2] and other is a vector [a/t1,*&zwj;/t2], sum over dim 0 will produce the matrix-vector multiplication. Similarly for matrix [a/t1,b/t2] and vector [*&zwj;/t1,b/t2], sum over dim 1.</p>
<p>For matrix-matrix multiplication use for example: Matrix1 [ a/t1,b/t2,* /t3] and Matrix2 [a/t1,* / t2, c/t3], sum over dim 0. or: Matrix1 [ a/t1,b/t2,* /t3] and Matrix2 [* / t1,b / t2, c/t3], sum over dim 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other encrypted tile tensor </td></tr>
    <tr><td class="paramname">sumDim</td><td>Dimension to sum over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a0ce4f4e7f89cda19890c8b17715226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0ce4f4e7f89cda19890c8b17715226">&#9670;&nbsp;</a></span>multiplyAndSumTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiplyAndSumTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to other.multiplyAndSum(*this, dim) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other encrypted tile tensor </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension to sum over </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#a7e2318c783f4c8ecd9d905b3656c2b6f">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="a50c375f14f9072873fc182bff1b47457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c375f14f9072873fc182bff1b47457">&#9670;&nbsp;</a></span>multiplyOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiplyOverDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies over a dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension to multiply over. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad832ac89738d3981cf1deaa28cc12ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad832ac89738d3981cf1deaa28cc12ec7">&#9670;&nbsp;</a></span>multiplyPlain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiplyPlain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise multiply with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a11eb3f7c2e9f2c637b6b0d3e09de8bad" title="Multiply a PTile with this CTile, elementwise.">CTile::multiplyPlain</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to multiply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9982b8f6c7c8a2d23f6b35efa64fd634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9982b8f6c7c8a2d23f6b35efa64fd634">&#9670;&nbsp;</a></span>multiplyPlainAndSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiplyPlainAndSum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sumDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs elementwise multiplication between this and other, then sums over specified dim. </p>
<p>See <a class="el" href="classhelayers_1_1CTileTensor.html#ac392a9e935b419d4de4c8e9f2fe5976d" title="Performs elementwise multiplication between this and other, then sums over specified dim.">CTileTensor::multiplyAndSum</a> for usage examples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other encoded tile tensor </td></tr>
    <tr><td class="paramname">sumDim</td><td>Dimension to sum over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4581af26329517a1e8f7a3b5e52eb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4581af26329517a1e8f7a3b5e52eb12">&#9670;&nbsp;</a></span>multiplyPlainRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiplyPlainRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise multiply with other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a4aa7e1c8e0d46abd1f5bfaa16895952e" title="See multiplyPlain()">CTile::multiplyPlainRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to multiply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf2512ac1acc7f298c6cbc5e6d883338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2512ac1acc7f298c6cbc5e6d883338">&#9670;&nbsp;</a></span>multiplyRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiplyRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise multiply with other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a>. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a014dec959e475c1f7f9e5bdd3438bc37" title="see multiply()">CTile::multiplyRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to multiply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7501865ac8849faa90ca7d2c4bf84e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7501865ac8849faa90ca7d2c4bf84e50">&#9670;&nbsp;</a></span>multiplyScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiplyScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies all used tensor elements by a given scalar. </p>
<p>Consumes one chain index. As a side effect, unused elements will be zeroed, thus unknown unused elements will be eliminated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to multiply by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68dbcc88b927f45536ff66401fc4769b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dbcc88b927f45536ff66401fc4769b">&#9670;&nbsp;</a></span>multiplyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::multiplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to other.multiply(*this) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to multiply to </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#aaa3af50c8ddf7866c91bf30071fa9fa2">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="abeeeaa7805aa33ce63df7d763d0b7008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeeeaa7805aa33ce63df7d763d0b7008">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&amp; helayers::CTileTensor::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy other tile tensor to this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>object to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae65a2abaeaa742f87b421b5646f4d9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65a2abaeaa742f87b421b5646f4d9c7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a>&amp; helayers::CTileTensor::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move other tile tensor to this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>object to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e61da00b0ca3abb87af0716fd318103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e61da00b0ca3abb87af0716fd318103">&#9670;&nbsp;</a></span>reEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::reEncrypt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt the <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> and encrypts it again to bring it to top chain index. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> doesn't have the secret key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab83b9cebc3e0d7cbfa5756b6fdc4dc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83b9cebc3e0d7cbfa5756b6fdc4dc45">&#9670;&nbsp;</a></span>removeDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::removeDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a dim from this tensor. </p>
<p>Only for dim with original size 1 and tile size 1. Number of dims before calling the function must be at least 3. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dim to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If dim doesn't exists </td></tr>
    <tr><td class="paramname">runtime_error</td><td>If dim is not of size 1 </td></tr>
    <tr><td class="paramname">runtime_error</td><td>If number of dims is less than 3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44e32e665c51c4fba8149b91935bf4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e32e665c51c4fba8149b91935bf4db">&#9670;&nbsp;</a></span>reorderDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::reorderDims </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the dimensions of this tensor. </p>
<p>The relative order of dimensions with tile size &gt; 1 must be kept. For example, given {1,2,0}, the current second dimension will become first, the current third dimension will become second, and the current first dimension will become last. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimOrder</td><td>New order of dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>If dimOrder size doesn't match number of dims. </td></tr>
    <tr><td class="paramname">runtime_error</td><td>If the relative order of dimensions with tile size &gt; 1 is not the same as in dimOrder. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4c34ea08303f3b1ab1b4418f57f212b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c34ea08303f3b1ab1b4418f57f212b">&#9670;&nbsp;</a></span>rotateAlongDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::rotateAlongDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> along the specified dimension (index (i+rot) % originalSize moves to i). </p>
<p>The elements that fall out of one end cycle back in the other end. If the external size of "dim" is not 1, then "dim" must be interleaved. If the external size of "dim" is 1, the rotation works and will have the same effect regardless of the interleaved flag being on or off. For the rotation to succeed, "dim" must be the first non-trivial" dimension, and it must not contain any unused slots. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The dimension to rotate along. </td></tr>
    <tr><td class="paramname">rot</td><td>The rotation offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>If the rotated dimension does not satisfy the above requirements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7380707120d59b1db414b09b756da050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7380707120d59b1db414b09b756da050">&#9670;&nbsp;</a></span>setDimInterleaved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::setDimInterleaved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelayers.html#ac27f77e6ca5c7331ca51331aae96838d">DimInt</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInterleaved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns interleave flag on or off for specific dim without changing the underlying tiling. </p>
<p>Can be used only if dim original size is 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Which dimension to set </td></tr>
    <tr><td class="paramname">isInterleaved</td><td>Whether this dimension is interleaved </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>If dim doesn't exists </td></tr>
    <tr><td class="paramname">invalid_argument</td><td>If dim original size &gt; 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad30f647d3d0a720db62f11215836f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad30f647d3d0a720db62f11215836f68">&#9670;&nbsp;</a></span>shiftAlongDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::shiftAlongDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts this <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> along the specified dimension (index i+shift moves to i). </p>
<p>The elements that fall out of one end do not cycle back in the other end. If the external size of "dim" is not 1, then "dim" must be interleaved. If the external size of "dim" is 1, the shift works and will have the same effect regardless of the interleaved flag being on or off. "shift" must be positive and smaller than the original size of "dim". Following the shift, the original size of dim will be reduced by the given "shift" value, and the unused slots will be marked unkown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The dimension to shift along. </td></tr>
    <tr><td class="paramname">shift</td><td>The shift offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>If the shifted dimension does not satisfy the above requirements. </td></tr>
    <tr><td class="paramname">invalid_argument</td><td>If "shift" is negative or greater than the original size of "dim". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bed0df245a7dc959d978f6daa91bd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bed0df245a7dc959d978f6daa91bd8b">&#9670;&nbsp;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise subtract other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> from this. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a47ee8fdfb7373fe357dd11d8158a8683" title="Subtract content of another ciphertext from this one, elementwise.">CTile::sub</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to subtract. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb919b20c7f70eb6d738ff1dd5db3e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb919b20c7f70eb6d738ff1dd5db3e36">&#9670;&nbsp;</a></span>subFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::subFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to other.sub(*this) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to subtract from. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhelayers_1_1TileTensor.html#a1a4f6d2d9ea402b9cd9720b74ce488ae">helayers::TileTensor</a>.</p>

</div>
</div>
<a id="a1311af6a0f5b4437fca29e3d7906d787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1311af6a0f5b4437fca29e3d7906d787">&#9670;&nbsp;</a></span>subPlain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::subPlain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise subtract other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> from this. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a58f4ca21f819eaf447eb8698d1c446ec" title="Subtract content of another PTile from this one, elementwise.">CTile::subPlain</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to subtract. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a679b9b40771527c7e46d031ba8ca5b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679b9b40771527c7e46d031ba8ca5b99">&#9670;&nbsp;</a></span>subPlainRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::subPlainRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise subtract other (plaintext) <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> from this. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a4b1f0d344509b0f54367b1eb53e344d5" title="See subPlain()">CTile::subPlainRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>other <a class="el" href="classhelayers_1_1PTileTensor.html" title="An encoded tile tensor.">PTileTensor</a> to subtract. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26fa6cc58d19c1265fbdbcf276bad365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fa6cc58d19c1265fbdbcf276bad365">&#9670;&nbsp;</a></span>subRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::subRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise subtract other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> from this. </p>
<p>Relies on <a class="el" href="classhelayers_1_1CTile.html#a76da694be5e95438a8fe545112574666" title="See sub()">CTile::subRaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>other <a class="el" href="classhelayers_1_1CTileTensor.html" title="An encrypted tile tensor.">CTileTensor</a> to subtract. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac82dc764f72f9e0093fd511d31522f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82dc764f72f9e0093fd511d31522f28">&#9670;&nbsp;</a></span>sumInTilesOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::sumInTilesOverDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum inside tiles. </p>
<p>This method assumes the external size along this dimension is 1. It reduces the original size to 1 by summing inside the remaining tile.</p>
<p>The result will be duplicated if this is the first non-trivial dimension. Note if the originalSize is 1, this call will still incur rotations if this is the first non-trivial dim, to satisfy the duplicated result requirement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to sum over. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4ac59ce1f3866e4c8a2a921cc534343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ac59ce1f3866e4c8a2a921cc534343">&#9670;&nbsp;</a></span>sumOverDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::CTileTensor::sumOverDim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums over a dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension to sum over. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/helayers/math/<a class="el" href="CTileTensor_8h_source.html">CTileTensor.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
