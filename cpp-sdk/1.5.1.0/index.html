<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17" />
    <title>HElayers SDK: HELAYERS SDK Documentation</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;1,700&family=Merriweather&family=Merriweather+Sans&family=Open+Sans&family=Poppins:ital@1&family=Roboto:ital,wght@0,400;1,300;1,900&display=swap"
        rel="stylesheet">
    <script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/latest/ui-shell.min.js"></script>
</head>
<body style="font-family: 'Merriweather', serif;">
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand">HElayers SDK 1.5.1.0</a>
            </div>
        </div>
    </nav>
    <div id="top">
        <bx-header aria-label="IBM Platform Name">
            <bx-header-menu-button button-label-active="Close menu" button-label-inactive="Open menu">
            </bx-header-menu-button>
            <bx-header-name href="index.html" prefix="IBM">HElayers</bx-header-name>
            <bx-header-nav menu-bar-label="IBM HElayers">
                <bx-header-nav-item href="index.html">Overview
                </bx-header-nav-item>
                <bx-header-menu menu-label="Namespaces" trigger-content="Namespaces">
                    <bx-header-menu-item href="namespaces.html">Namespace List
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Namespace Members" trigger-content="Namespace  Members">
                        <bx-header-menu-item href="namespacemembers.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_enum.html">Enumerations
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_eval.html">Enumerator
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Classes" trigger-content="Classes">
                    <bx-header-menu-item href="annotated.html">Class List
                    </bx-header-menu-item>
                    <bx-header-menu-item href="classes.html">Class Index
                    </bx-header-menu-item>
                    <bx-header-menu-item href="inherits.html">Class Hierarchy
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Class Members" trigger-content="Class Members">
                        <bx-header-menu-item href="functions.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Variables
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_enum.html">Enumerations
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Files" trigger-content="Files">
                    <bx-header-menu-item href="files.html">File List</bx-header-menu-item>
                </bx-header-menu>
            </bx-header-nav>
        </bx-header>
        <!-- do not remove this div, it is closed by doxygen! -->
        <!-- end header part --><!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">HELAYERS SDK Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md26"></a>
Goals</h1>
<p>The main goals of this SDK are...</p>
<ul>
<li>To provide a smooth transition from a non-encrypted environment to a privacy preserving one</li>
<li>Optimize processes that would otherwise require cryptographic and specific library knowledge to run efficiently</li>
<li>Enable HE-based computations without dependence on a specific homomorphic encryption library</li>
</ul>
<h1><a class="anchor" id="autotoc_md27"></a>
Overview</h1>
<p>The helayers SDK uses low-level HE cryptographic libraries such as HElib or SEAL, and adds functionality on top of it in a layered structure as follows:</p>
<p>The SDK is structured into different layers. The layers are setup for different uses depending on how you would like to interact with the SDK.</p>
<ul>
<li><b>HEBase:</b> This layer contains abstract interfaces that can wrap an underlying HE library, providing a uniform API to access different libraries, thus allowing to write library agnostic and scheme-oblivious code (as much as possible). <br  />
 <br  />
</li>
<li><b>Packing Algorithms and Math:</b> This layer contains tools for doing high-level operations such as matrix multiplication and polynomial evaluation. Central to this layer is the concept of a tile tensor: an innovative data structure that allows packing arbitrary tensors (multi-dimensional arrays widely used in AI) in a variety of ways. In addition, this layer contains a generic bootstrapping algorithm for the CKKS scheme. It can work with any CKKS implementation, though currently tested only with SEAL. The layer further contains innovative algorithms for computing functions not directly supported by the underlying HE libraries, such as <code>sign(x)</code>, <code>abs(x)</code>, and <code>compare(x,y)</code>. <br  />
 <br  />
</li>
<li><b>AI and Query Tools:</b> This layer contains AI tools, can inference over multiple types of models, neural networks, decision trees, logistic regression, linear regression, and kmeans. This layer includes an innovative optimizer, that optimizes the use of a specific model. It will adjust the underlying HE library parameters as well as some high level packing details and other parameters, in accordance with user constraints and optimization preferences regarding time and memory usage, either on the client or server side. Also included (in the next release) are logistic regression training, and basic neural network training capabilities, that can be deployed to be used in interactive mode, and in the future also non-interactively. In addition, there are tools for querying an encrypted database with an encrypted query. I.e., such that the database server can’t see what is being queried or the result. <br  />
 <br  />
</li>
<li>All layers contain research and debug tools, allowing to test algorithms in mockup settings, get detailed trace data, compare approaches, and more. <br  />
 <br  />
</li>
</ul>
<p>An additional mltoolbox module contains tools for helping data scientists convert their models to be FHE friendly. The mltoolbox module is available through the Python APIs only.</p>
<p>Helayers contains some additional tools based on other cryptographic techniques besides FHE:</p>
<ul>
<li>The Accord submodule: Multi-party computation (MPC) and Zero-knowledge proofs (ZKP). (Note: available through Python APIs only, and not available on IBM Z platforms).</li>
<li>Privacy preserving record linkage protocol. The protocol is similar to the Private-Set-Intersection (PSI) protocol, except that it allowes for similarities rather than requiring exact equivalence of the reported candidate pairs. The similarity of the records is measured in terms of the Jaccard similarity index of the two records.</li>
</ul>
<div class="image">
<img src="ai_chart.jpg" alt=""/>
</div>
   <h3><a class="anchor" id="autotoc_md28"></a>
Python API</h3>
<p>There is a C++ API as well as Python API. The Python API contains most of the functionality, and in future versions will cover all the API. The tutorials are available both in C++ and in Python as Jupyter notebooks.</p>
<p>Further included is the pyhelayersext API which allows easily converting existing python scripts to FHE. A python script for training and/or testing models with Scikit-learn or Keras can be converted to perform predictions under FHE by adding a single import statement. See the two demos with the <code>_pyhelayersext_</code> term in their titles.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
Underlying HE Library Support</h3>
<p>The following schemes and libraries are currently supported:</p>
<ul>
<li>Full support (entire available API of the underlying library is covered and used):<ul>
<li>HElib-CKKS</li>
<li>SEAL-CKKS</li>
<li>HEaaN-CKKS</li>
</ul>
</li>
<li>Basic API support:<ul>
<li>HElib-BGV</li>
<li>HElib-BGV in bitwise mode</li>
</ul>
</li>
</ul>
<p>It is possible to compile the SDK with only some of the supported libraries, allowing it to run without dependence on the unused ones. (Premium Edition Only)</p>
<h3><a class="anchor" id="autotoc_md30"></a>
Approach For Providing an Abstraction of Multiple Libraries and Schemes</h3>
<p>Most Homomorphic Encyption computations are basically a series of additions and multiplications, supported by all underlying HE libraries. Hence most of the code written in the HElayers SDK will be library and scheme agnostic. However, some libraries and schemes offer unique functionalities that can be exploited for specific use cases. The HElayers SDK API provides all the functionality of the supported schemes and libraries, to maximize the use of each to its fullest extent.</p>
<p>To maintain scheme and library abstraction as much as possible, the following steps are taken:</p>
<ul>
<li>The HELayers SDK attempts to compensate internally for missing functionality where possible. E.g., the “power” operator is directed to the library’s native power operator if it exists, or otherwise a generic algorithm inside helayers for evaluation of powers using multiplication is used.</li>
<li>A “traits” class <a class="el" href="classhelayers_1_1HeTraits.html">HeTraits</a> can be queried by the user to detect which functionality is supported by the underlying library. The user can use this information in one of two ways:<ul>
<li>Assert that mandatory functions are present. This will provide immediate clear diagnostics, if choice of library and scheme mismatches required computation.</li>
<li>Condition on underlying traits, to choose one algorithm or another based on available functionality. This will take advantage of useful functionality where available, while maintaining general library and scheme obliviousness.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md31"></a>
Class Overview</h1>
<p>Both C++ and Python APIs offer the same list of classes detailed below.</p>
<h3><a class="anchor" id="autotoc_md32"></a>
HEBase</h3>
<p>Main classes:</p>
<ul>
<li><a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> – The main access point to the underlying cryptographic library. Initialized during startup to a specific library and scheme. Most other classes receive a reference to it in their constructors.</li>
<li><a class="el" href="classhelayers_1_1HeTraits.html">HeTraits</a> – A list of flags indicating the available functionality of the underlying library and scheme: floating point numbers, complex numbers, the bootstrapping operation, bitwise manipulation, automatic rescaling, and others. This class can be used in asserts to make sure the chosen library and scheme provides a minimal set of requirements for a given computation. Or, different algorithm choices can be made based on these traits.</li>
<li><a class="el" href="classhelayers_1_1CTile.html">CTile</a> – A ciphertext object. Supports basic operators such as add, multiply, rotate, and others.</li>
<li><a class="el" href="classhelayers_1_1PTile.html">PTile</a> – A plaintext object in encoded form (a preprocessing stage prior to encryption).</li>
<li><a class="el" href="classhelayers_1_1Encoder.html">Encoder</a> – A class for performing encryption, decryption, encode, and decode.</li>
</ul>
<p>This layer contains further specific implementations of the above abstract classes for the supported underlying libraries.</p>
<p>Research and debug classes:</p>
<ul>
<li><a class="el" href="classhelayers_1_1MockupContext.html">MockupContext</a> – A mockup implementation of HeContext without any cryptography. It allows fast runs for testing.</li>
<li><a class="el" href="classhelayers_1_1DebugContext.html">DebugContext</a> – An implementation of HeContext that allows comparing other HeContexts. It is configured with two other pre-initialized HeContext objects (e.g., one for a cryptographic library and one for the mockup), delegates all calls to both of them, and compares the results. Useful for example for tracing CKKS noise, to see which steps cause it to build up the most, or to detect problems in the HE system configuration, pinpointing where the computation goes wrong.</li>
</ul>
<h3><a class="anchor" id="autotoc_md33"></a>
Packing Algorithms and Math</h3>
<p>Main classes:</p>
<ul>
<li><a class="el" href="classhelayers_1_1BootstrapEvaluator.html">BootstrapEvaluator</a> – Compute the bootstrapping operation. Currently supports only CKKS scheme in SEAL (implementation in helayers), and HEaaN (native).</li>
<li><a class="el" href="classhelayers_1_1CTileTensor.html">CTileTensor</a> – A tile tensor object. Representing an encrypted tensor (multi-dimensional array, e.g., a matrix, or array of matrices). Supports high level operators such as matrix multiplication, sum over a dimension, replicate a dimension, elementwise operators, and others.</li>
<li><a class="el" href="classhelayers_1_1PTileTensor.html">PTileTensor</a> – A tile tensor in encoded (not encrypted) form. Useful for elementwise operators with CTileTensor.</li>
<li><a class="el" href="classhelayers_1_1TTEncoder.html">TTEncoder</a> – A class for performing encryption, decryption, encode, and decode for tile tensors.</li>
<li><a class="el" href="classhelayers_1_1FunctionEvaluator.html">FunctionEvaluator</a> – Efficient algorithms for evaluation of powers, polynomial evaluation, and some approximations for useful functions such as sigmoid, absolute, sign, and others. Note: If the underlying HE library supports some of these functions, and the library’s implementation is more efficient than the SDK’s, the calls will be delegated to the library’s functions.</li>
<li><a class="el" href="classhelayers_1_1BitwiseEvaluator.html">BitwiseEvaluator</a> – Some libraries and scheme support manipulation on individual bits of the encrypted numbers. This class contains API based on such manipulation: extract MSB, split to bits, and others. When using a library/scheme that does not support bit level manipulation, an exception will be thrown. The HeTraits class can be queried for the availability of this functionality.</li>
</ul>
<h3><a class="anchor" id="autotoc_md34"></a>
AI</h3>
<p>The layer is designed to allow easy migration from working with AI using standard libraries to working with the same models under HE. It supports the use case inference over an encrypted input and encrypted model, or encrypted input and non-encrypted model. The user can import models trained using standard AI tools via standard file formats, and start performing inference under encryption with only a few lines of code.</p>
<p>Main classes:</p>
<ul>
<li><a class="el" href="classhelayers_1_1HeModel.html">HeModel</a>: An abstract class representing a model for performing inference under encryption. Current subclasses: <a class="el" href="classhelayers_1_1NeuralNet.html">NeuralNet</a>, <a class="el" href="classhelayers_1_1XGBoost.html">XGBoost</a>, <a class="el" href="classhelayers_1_1LogisticRegression.html">LogisticRegression</a> (also supports linear regression), <a class="el" href="classhelayers_1_1KMeans.html">KMeans</a>, <a class="el" href="classhelayers_1_1Arima.html">Arima</a>, <a class="el" href="classhelayers_1_1DTree.html">DTree</a>.</li>
<li><a class="el" href="classhelayers_1_1PlainModel.html">PlainModel</a>: An abstract class representing a plain model imported from standard AI libraries. It stores the model data, and for some subclasses it can perform inference as well (for testing purposes). Every model class has an accompanying plain class, e.g. <a class="el" href="classhelayers_1_1NeuralNetPlain.html">NeuralNetPlain</a> for NeuralNet, and <a class="el" href="classhelayers_1_1LogisticRegressionPlain.html">LogisticRegressionPlain</a> for LogisticRegression.</li>
</ul>
<p>The models currently only support inference. Upcoming future versions will support limited training capabilities: For logistic regression, and for some types of neural networks. The HE models support binary I/O to allow transferring to a server. The plain models support reading from standard file formats.</p>
<p>The neural network capabilities currently include any combination of fully connected layers, convolutional layers, mean-pooling, and batch normalization. Activation functions include square, sigmoid polynomial approximation, and user defined (or trained) polynomials. Upcoming training will include a dropout layer, and support for stochastic gradient descent with momentum.</p>
<ul>
<li><a class="el" href="classhelayers_1_1HeProfileOptimizer.html">HeProfileOptimizer</a>: The optimizer object for generating a profile for a given model.</li>
<li>HeProfile: The results of optimizing a given model. This object contains all relevant parameters for efficiently encrypting and using a given model.</li>
<li><a class="el" href="classhelayers_1_1Table.html">Table</a>: An encrypted database table. Supports querying it with unique select, count, sum, and average, optionally conditioned on another column using equality or less-than or greater-than operators. The condition threshold value can be encrypted as well.</li>
<li><a class="el" href="classhelayers_1_1DTree.html">DTree</a>: An encrypted decision tree model. Supports prediction over encrpyted data. This class is planned to be integrated with (<a class="el" href="classhelayers_1_1HeModel.html">helayers::HeModel</a>).</li>
<li><a class="el" href="classhelayers_1_1Crf.html">Crf</a>: A class supporting the training of a Completely Random Forest (CRF) [18] over encrypted data. The class also supports binary I/O to allow transferring the trained model from a server to a client. The encrypted trained model can be decrypted to get a (helyaers::CrfPlain) class, which supports the prediction of plain samples. This class is planned to be integrated with (<a class="el" href="classhelayers_1_1HeModel.html">helayers::HeModel</a>).</li>
<li><a class="el" href="classhelayers_1_1XGBoost.html">XGBoost</a> An encrypted XGBoost model. Supports prediction over encrypted data. This class is planned to be integrated with (<a class="el" href="classhelayers_1_1HeModel.html">helayers::HeModel</a>). For now, the XGBoost class is programmed to maximize throughput, which may come at the account of higher latency. A latency minimization support may be added in future versions.</li>
<li><a class="el" href="classhelayers_1_1LogisticRegression.html">LogisticRegression</a> Training and inference for logistic regression models. The activation function can be approximated to various degrees, or turned off to obtain lineaer regression.</li>
<li><a class="el" href="classhelayers_1_1KMeans.html">KMeans</a> Find the nearest centroid for each sample in a given batch.</li>
<li><a class="el" href="classhelayers_1_1Arima.html">Arima</a> Training and inference of ARIMA models for time series analysis.</li>
<li><a class="el" href="classhelayers_1_1DTree.html">DTree</a> Inference over a decision tree.</li>
</ul>
<h1><a class="anchor" id="autotoc_md35"></a>
Tutorial Overview</h1>
<p>The SDK demostrates several end-to-end use cases that are implemented through a series of different tutorials. In order to make the tutorials more educational, we simplify the examples by running the client and server objects on the same machine. While they are both running on the same machine, they communicate via files. It’s easy to pull them apart, and load onto different machines. There would still be a need to implement a mechanism for sending files over, or replace the I/O api to write to sockets or other communication means instead of files.</p>
<p>Most demos are available in two forms: as C++ code using the library’s C++ API (helayers-lab docker image), or a Jupyter notebook using the library’s Python API (helayers-pylab docker image).</p>
<p>The demos are:</p>
<ol type="1">
<li>FHE basics. A tutorial for the HEBase layer in HeLayers.</li>
<li>Credit card fraud detection using neural network inference. The network’s architecture is based on a notebook implemented by the Kaggle community (<a href="https://www.kaggle.com/omkarsabnis/credit-card-fraud-detection-using-neural-networks">https://www.kaggle.com/omkarsabnis/credit-card-fraud-detection-using-neural-networks</a> see references [1-9]), while some changes was applied to make the network's architecture FHE friendly. The network was trained using a realistic dataset taken from Credit Card Fraud Detection. This dataset contains actual anonymized transactions made by credit card holders from September 2013, and is labeled for transactions being fraudulent or genuine. The server works with both network and incoming data encrypted. Can be configured for throughput or latency, reaching a maximum of 4000 samples per second throughput on a benchmark machine (see below), or minimal latency of 0.5 second (including I/O and encrypt/decrypt time).</li>
<li>Logistic regression inference: compute a logistic regression model inference over a batch of input vectors.</li>
<li>Text classification: This demo is based on the 20-newsgroups dataset (see reference [16]) and classifies a text snippet to its relevant category. The demo includes training the neural network model in the clear, then perform inference under encryption. For the demo, we used only 4 out of 20 available categories.</li>
<li>Image classification using an HE friendly modified version of AlexNet (See reference [17]), SqueezeNet or ResNet-18. It computes inference over a single 50K RGB pixel encrypted image in 3.5 minutes (AlexNet) with a non-encrypted model on a 88-CPU machine.</li>
<li>Database query: Several demonstrations of various techniques to query an encrypted database. We show a unique select demo over a database encrypted with BGV, and more general tools for doing encrypted queries for count, sum, average and standard deviation, conditioned on either equality or greater-than operators, using the CKKS scheme (the CKKS demo is in C++ only). The server sees nothing except the names of the columns being queried and the type of condition (equality or greater-than, etc…).</li>
<li>Kmeans inference: compute the nearest centroid for a set of input vector. The Euclidean distances are computed under encryption, and the final arg-min computation is done in post-processing on the client side.</li>
<li>Linear regression inference: compute a linear regression model inference over a batch of input vectors.</li>
<li>MNIST classification (See reference [10]): A known HE network inference benchmark architecture CryptoNets (See reference [11]), used for classifying images of digits. The network has a convolution layer, followed by two fully connected ones. The server works with both network and incoming data encrypted. Can be configured for throughput or latency, reaching a maximum of 4400 samples per second throughput on a benchmark machine (see below), or minimal latency of 0.7 second.</li>
<li>Heart disease detection using neural network inference. (See references [12-15])</li>
<li>Tile tensor API tutorial.</li>
</ol>
<p>12-13. Two demos demonstrating the pyhelayersext api, which offers easy integration with scikit-learn/keras libraries. We add a single import instruction to a regular training and testing script, and it replaces scikit-learn/keras predictions with the FHE implementation. The FHE configuration details are taken from fhe.json configuration file.</p>
<ol type="1">
<li>COVID-19 predictions using encrypted CT scans. Each image is 224x244x3 pixels, and the prediction is done using a 5 layer convolutional neural network.</li>
<li>Logistic Regression Training on a Credit Card Fraud Detection Dataset: A demo demonstrating the training of a logistic regression encrypted model under HE using an encrypted dataset of credit card transactions. The trained model is used to run inference on encrypted samples.</li>
<li>Completely Random Forest training over encrypted data: A demo demonstrating the training process of a Completely Random Forest [18] model with encrypted samples from UCI's Adult dataset [19].</li>
<li>Entity resolution: (ER for short) identifying different records that refer to the same entity, and then handling the identified records as needed. The example demonstrates a specific case of ER, namely Record-Linkage (RL), that deals with identifying records in different databases which refer to the same entity. Our ER library performs such Record-Linkage in a privacy-preserving manner (PPRL).</li>
<li>ARIMA prediction: ARIMA model training and prediction on encrypted data.</li>
<li>MLToolbox demonstration: Using MLToolbox to convert a general NN model into an FHE-Friendly NN model with nearly the same performance, that can later be encrypted and used for prediction on encrypted data.</li>
<li>Prediction over the iris dataset [20] using an XGBoost model. First, an XGBoost model is trained in the clear. Then, the trained model is encrypted and used to run prediction over encrypted test samples from the iris dataset. For now, the FHE XGBoost model is programmed to maximize throughput, which may come at the account of higher latency. A latency minimization support may be added in future versions.</li>
<li>Calculation of one-hot encoding under homomorphic encryption. One-hot encoding converts a number 1-n to a vector of n 0-1 indicators. Given an encrypted input vector of numbers and a vector of possible values that the input vector might contain, we calculate a set of encrypted indicator vectors. Each indicator vector corresponds to a different possible value and contains 1 in the slots where that value appears in the original vector.</li>
<li>A demo of Private Set Intersection process between three parties to be used for Vertical Federated Learning. Private Set Intersection is the process of finding common entries in two datasets or more without disclosing any information about the data. In Vertical Federated Learning the dataset is paritioned "vertically" between the parties, meaning that each party holds different features of some subset of the samples, while each sample is identified by a unique UID. Given list of UIDs and the partial dataset of one of the parties, the objective is to calculate an encrypted dataset that contains only the samples that appear also in the datasets of the other parties, and do so without disclosing any information to each of the parties.</li>
</ol>
<p>C++ Only tutorials:</p>
<ol type="1">
<li>CircLayer tutorial - a demo of low level optimization achievable by examining the computation circuit.</li>
<li>Bitwise tutorial - A tutorial of HEbase's API for bitwise scheme.</li>
<li>Credit card fraud detection using a decision tree. The decision tree was trained in the clear on the same data set as above. The server performs classification when both tree and incoming data are encrypted.</li>
</ol>
<p>Training: In subsequent version we’ll add tools for interactive training of small networks, including convolutional layer (as first layer), mean-pooling, dropout and fully connected layers. Activation layer and loss functions are limited to simple squaring and Euclidean loss. Optimization algorithm restricted to stochastic gradient descent or stochastic gradient descent with momentum (but not ADAM).</p>
<p>Measurement reported above are on a 24 CPUs, Intel(R) Xeon(R) CPU E5-2620 v3 @ 2.40GHz machine with 384 GB memory.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
References</h1>
<ol type="1">
<li>Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015</li>
<li>Dal Pozzolo, Andrea; Caelen, Olivier; Le Borgne, Yann-Ael; Waterschoot, Serge; Bontempi, Gianluca. Learned lessons in credit card fraud detection from a practitioner perspective, Expert systems with applications,41,10,4915-4928,2014, Pergamon</li>
<li>Dal Pozzolo, Andrea; Boracchi, Giacomo; Caelen, Olivier; Alippi, Cesare; Bontempi, Gianluca. Credit card fraud detection: a realistic modeling and a novel learning strategy, IEEE transactions on neural networks and learning systems,29,8,3784-3797,2018,IEEE</li>
<li>Dal Pozzolo, Andrea Adaptive Machine learning for credit card fraud detection ULB MLG PhD thesis (supervised by G. Bontempi)</li>
<li>Carcillo, Fabrizio; Dal Pozzolo, Andrea; Le Borgne, Yann-Aël; Caelen, Olivier; Mazzer, Yannis; Bontempi, Gianluca. Scarff: a scalable framework for streaming credit card fraud detection with Spark, Information fusion,41, 182-194,2018,Elsevier</li>
<li>Carcillo, Fabrizio; Le Borgne, Yann-Aël; Caelen, Olivier; Bontempi, Gianluca. Streaming active learning strategies for real-life credit card fraud detection: assessment and visualization, International Journal of Data Science and Analytics, 5,4,285-300,2018,Springer International Publishing</li>
<li>Bertrand Lebichot, Yann-Aël Le Borgne, Liyun He, Frederic Oblé, Gianluca Bontempi Deep-Learning Domain Adaptation Techniques for Credit Cards Fraud Detection, INNSBDDL 2019: Recent Advances in Big Data and Deep Learning, pp 78-88, 2019</li>
<li>Fabrizio Carcillo, Yann-Aël Le Borgne, Olivier Caelen, Frederic Oblé, Gianluca Bontempi Combining Unsupervised and Supervised Learning in Credit Card Fraud Detection Information Sciences, 2019</li>
<li>Yann-Aël Le Borgne, Gianluca Bontempi Machine Learning for Credit Card Fraud Detection - Practical Handbook</li>
<li>LeCun, Yann and Cortes, Corinna. "MNIST handwritten digit database." (2010): .</li>
<li>Gilad-Bachrach, R., Dowlin, N., Laine, K., Lauter, K., Naehrig, M. &amp; Wernsing, J.. (2016). CryptoNets: Applying Neural Networks to Encrypted Data with High Throughput and Accuracy. Proceedings of The 33rd International Conference on Machine Learning, in Proceedings of Machine Learning Research 48:201-210 Available from <a href="https://proceedings.mlr.press/v48/gilad-bachrach16.html">https://proceedings.mlr.press/v48/gilad-bachrach16.html</a>.</li>
<li><a href="https://archive.ics.uci.edu/ml/datasets/Heart+Disease">https://archive.ics.uci.edu/ml/datasets/Heart+Disease</a></li>
<li>Detrano, R., Janosi, A., Steinbrunn, W., Pfisterer, M., Schmid, J., Sandhu, S., Guppy, K., Lee, S., &amp; Froelicher, V. (1989). International application of a new probability algorithm for the diagnosis of coronary artery disease. American Journal of Cardiology, 64,304&ndash;310.</li>
<li>David W. Aha &amp; Dennis Kibler. "Instance-based prediction of heart-disease presence with the Cleveland database."</li>
<li>Gennari, J.H., Langley, P, &amp; Fisher, D. (1989). Models of incremental concept formation. Artificial Intelligence, 40, 11&ndash;61.</li>
<li><a href="http://kdd.ics.uci.edu/databases/20newsgroups/20newsgroups.html">http://kdd.ics.uci.edu/databases/20newsgroups/20newsgroups.html</a></li>
<li>Krizhevsky, Alex and Sutskever, Ilya and Hinton, Geoffrey E. "Imagenet classification with deep convolutional neural networks", Advances in neural information processing systems 25, 2012.</li>
<li>Aslett, Louis JM, Pedro M. Esperança, and Chris C. Holmes. "Encrypted statistical machine learning: new privacy preserving methods." arXiv preprint arXiv:1508.06845 (2015).</li>
<li>Kohavi, R., Becker, B.: Uci machine learning repository - adult dataset (1996), <a href="https://archive.ics.uci.edu/ml/datasets/adult18">https://archive.ics.uci.edu/ml/datasets/adult18</a>.</li>
<li>C. L. Blake and C. J. Merz, UCI Repository of machine learning databases - iris dataset <a href="https://archive.ics.uci.edu/ml/datasets/iris">https://archive.ics.uci.edu/ml/datasets/iris</a> </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
