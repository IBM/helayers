<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17" />
    <title>HElayers SDK: helayers::SealBootstrapUtils Class Reference</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;1,700&family=Merriweather&family=Merriweather+Sans&family=Open+Sans&family=Poppins:ital@1&family=Roboto:ital,wght@0,400;1,300;1,900&display=swap"
        rel="stylesheet">
    <script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/latest/ui-shell.min.js"></script>
</head>
<body style="font-family: 'Merriweather', serif;">
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand">HElayers SDK 1.5.1.0</a>
            </div>
        </div>
    </nav>
    <div id="top">
        <bx-header aria-label="IBM Platform Name">
            <bx-header-menu-button button-label-active="Close menu" button-label-inactive="Open menu">
            </bx-header-menu-button>
            <bx-header-name href="index.html" prefix="IBM">HElayers</bx-header-name>
            <bx-header-nav menu-bar-label="IBM HElayers">
                <bx-header-nav-item href="index.html">Overview
                </bx-header-nav-item>
                <bx-header-menu menu-label="Namespaces" trigger-content="Namespaces">
                    <bx-header-menu-item href="namespaces.html">Namespace List
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Namespace Members" trigger-content="Namespace  Members">
                        <bx-header-menu-item href="namespacemembers.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_enum.html">Enumerations
                        </bx-header-menu-item>
                        <bx-header-menu-item href="namespacemembers_eval.html">Enumerator
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Classes" trigger-content="Classes">
                    <bx-header-menu-item href="annotated.html">Class List
                    </bx-header-menu-item>
                    <bx-header-menu-item href="classes.html">Class Index
                    </bx-header-menu-item>
                    <bx-header-menu-item href="inherits.html">Class Hierarchy
                    </bx-header-menu-item>
                    <bx-header-menu menu-label="Class Members" trigger-content="Class Members">
                        <bx-header-menu-item href="functions.html">All
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_func.html">Functions
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Variables
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_type.html">Typedefs
                        </bx-header-menu-item>
                        <bx-header-menu-item href="functions_enum.html">Enumerations
                        </bx-header-menu-item>
                    </bx-header-menu>
                </bx-header-menu>
                <bx-header-menu menu-label="Files" trigger-content="Files">
                    <bx-header-menu-item href="files.html">File List</bx-header-menu-item>
                </bx-header-menu>
            </bx-header-nav>
        </bx-header>
        <!-- do not remove this div, it is closed by doxygen! -->
        <!-- end header part --><!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehelayers.html">helayers</a></li><li class="navelem"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html">SealBootstrapUtils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classhelayers_1_1SealBootstrapUtils-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">helayers::SealBootstrapUtils Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class with various utility methods for performing CKKS bootstrapping.  
 <a href="classhelayers_1_1SealBootstrapUtils.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SealBootstrapUtils_8h_source.html">SealBootstrapUtils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af317b376af9344d32304afa99c5698ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#af317b376af9344d32304afa99c5698ad">SealBootstrapUtils</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;h, const <a class="el" href="classhelayers_1_1BootstrapConfig.html">BootstrapConfig</a> &amp;_bc, uint64_t firstMod=0)</td></tr>
<tr class="memdesc:af317b376af9344d32304afa99c5698ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Bootstrap Utils object.  <a href="classhelayers_1_1SealBootstrapUtils.html#af317b376af9344d32304afa99c5698ad">More...</a><br /></td></tr>
<tr class="separator:af317b376af9344d32304afa99c5698ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a692fc13e11213a41d1f44e50f91187"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a3a692fc13e11213a41d1f44e50f91187">SealBootstrapUtils</a> (const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;h)</td></tr>
<tr class="memdesc:a3a692fc13e11213a41d1f44e50f91187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classhelayers_1_1SealBootstrapUtils.html" title="A class with various utility methods for performing CKKS bootstrapping.">SealBootstrapUtils</a> object using a given HE context.  <a href="classhelayers_1_1SealBootstrapUtils.html#a3a692fc13e11213a41d1f44e50f91187">More...</a><br /></td></tr>
<tr class="separator:a3a692fc13e11213a41d1f44e50f91187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ee3c8ce92483c232f643495bb4aaa7"><td class="memItemLeft" align="right" valign="top"><a id="ae4ee3c8ce92483c232f643495bb4aaa7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ae4ee3c8ce92483c232f643495bb4aaa7">getExpectedBSCost</a> ()</td></tr>
<tr class="memdesc:ae4ee3c8ce92483c232f643495bb4aaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of products expected in the bootstrap process. <br /></td></tr>
<tr class="separator:ae4ee3c8ce92483c232f643495bb4aaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff56eac09c171d96f860ca20c04e453"><td class="memItemLeft" align="right" valign="top"><a id="aaff56eac09c171d96f860ca20c04e453"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCoef2slotEncodingScale</b> (double _coef2slotEncodingScale)</td></tr>
<tr class="separator:aaff56eac09c171d96f860ca20c04e453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3935014ee4135b6669a8e3d35e2127"><td class="memItemLeft" align="right" valign="top"><a id="a7e3935014ee4135b6669a8e3d35e2127"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getCoef2slotEncodingScale</b> ()</td></tr>
<tr class="separator:a7e3935014ee4135b6669a8e3d35e2127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdffb48fd8a3eb66252c35d8ef35f04"><td class="memItemLeft" align="right" valign="top"><a id="aafdffb48fd8a3eb66252c35d8ef35f04"></a>
const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aafdffb48fd8a3eb66252c35d8ef35f04">getHe</a> () const</td></tr>
<tr class="memdesc:aafdffb48fd8a3eb66252c35d8ef35f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classhelayers_1_1HeContext.html" title="An abstract main class representing an underlying HE library &amp; scheme, configured,...">HeContext</a> object. <br /></td></tr>
<tr class="separator:aafdffb48fd8a3eb66252c35d8ef35f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf2480e46547f8bde233bf848253e2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aebf2480e46547f8bde233bf848253e2b">printSignature</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aebf2480e46547f8bde233bf848253e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print signature of Bootstrap process configuration to output stream.  <a href="classhelayers_1_1SealBootstrapUtils.html#aebf2480e46547f8bde233bf848253e2b">More...</a><br /></td></tr>
<tr class="separator:aebf2480e46547f8bde233bf848253e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9869959ff3b0548d5b5f3dedef901c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#add9869959ff3b0548d5b5f3dedef901c">polyEvalInPlace</a> (const std::vector&lt; double &gt; &amp;coefs, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c) const</td></tr>
<tr class="memdesc:add9869959ff3b0548d5b5f3dedef901c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a polynomial over a ciphertext (DFS method)  <a href="classhelayers_1_1SealBootstrapUtils.html#add9869959ff3b0548d5b5f3dedef901c">More...</a><br /></td></tr>
<tr class="separator:add9869959ff3b0548d5b5f3dedef901c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd7c041640a34768f14af5d9378535d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a2dd7c041640a34768f14af5d9378535d">polyEvalInPlace2</a> (const std::vector&lt; double &gt; &amp;coefs, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c) const</td></tr>
<tr class="memdesc:a2dd7c041640a34768f14af5d9378535d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a polynomial over a ciphertext (with powers cache)  <a href="classhelayers_1_1SealBootstrapUtils.html#a2dd7c041640a34768f14af5d9378535d">More...</a><br /></td></tr>
<tr class="separator:a2dd7c041640a34768f14af5d9378535d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9f9a6fb925ad0539e29a7f7f841603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTile.html">CTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aef9f9a6fb925ad0539e29a7f7f841603">polyEval</a> (const std::vector&lt; double &gt; &amp;coefs, const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c) const</td></tr>
<tr class="memdesc:aef9f9a6fb925ad0539e29a7f7f841603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns evaluation of a polynomial over a ciphertext.  <a href="classhelayers_1_1SealBootstrapUtils.html#aef9f9a6fb925ad0539e29a7f7f841603">More...</a><br /></td></tr>
<tr class="separator:aef9f9a6fb925ad0539e29a7f7f841603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391e7d930ffe840159b853e6edc850ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTile.html">CTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a391e7d930ffe840159b853e6edc850ea">polyEvalCoefFirst</a> (const std::vector&lt; double &gt; &amp;coefs, const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c) const</td></tr>
<tr class="memdesc:a391e7d930ffe840159b853e6edc850ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns evaluation of a polynomial over a ciphertext term by term.  <a href="classhelayers_1_1SealBootstrapUtils.html#a391e7d930ffe840159b853e6edc850ea">More...</a><br /></td></tr>
<tr class="separator:a391e7d930ffe840159b853e6edc850ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca20700bf93274d5c9fe171a67aae6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTile.html">CTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a3ca20700bf93274d5c9fe171a67aae6d">polyEvalHorner</a> (std::vector&lt; double &gt; &amp;coeffs, const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c) const</td></tr>
<tr class="memdesc:a3ca20700bf93274d5c9fe171a67aae6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns evaluation of a polynomial over a ciphertext using Horner's method.  <a href="classhelayers_1_1SealBootstrapUtils.html#a3ca20700bf93274d5c9fe171a67aae6d">More...</a><br /></td></tr>
<tr class="separator:a3ca20700bf93274d5c9fe171a67aae6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78da89b9c29a65c5ac4166a255b08c9c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a78da89b9c29a65c5ac4166a255b08c9c">polyEvalPlainHorner</a> (std::vector&lt; double &gt; coeffs, double v) const</td></tr>
<tr class="memdesc:a78da89b9c29a65c5ac4166a255b08c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns evaluation of a polynomial over plain value using Horner's method.  <a href="classhelayers_1_1SealBootstrapUtils.html#a78da89b9c29a65c5ac4166a255b08c9c">More...</a><br /></td></tr>
<tr class="separator:a78da89b9c29a65c5ac4166a255b08c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc34094aa9ee8a4d8a2227bc366712b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aadc34094aa9ee8a4d8a2227bc366712b">powInPlace</a> (<a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, int d) const</td></tr>
<tr class="memdesc:aadc34094aa9ee8a4d8a2227bc366712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise ciphertext to given power.  <a href="classhelayers_1_1SealBootstrapUtils.html#aadc34094aa9ee8a4d8a2227bc366712b">More...</a><br /></td></tr>
<tr class="separator:aadc34094aa9ee8a4d8a2227bc366712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8001231ccb7f547b80cecf0bf79bc2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aba8001231ccb7f547b80cecf0bf79bc2">searchMods</a> (double q, double Z, int M, int <a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a3e004f0002769e8114ce5323f385da64">R</a>, int numZsteps, const std::string &amp;outfilename)</td></tr>
<tr class="memdesc:aba8001231ccb7f547b80cecf0bf79bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search various mod configurations.  <a href="classhelayers_1_1SealBootstrapUtils.html#aba8001231ccb7f547b80cecf0bf79bc2">More...</a><br /></td></tr>
<tr class="separator:aba8001231ccb7f547b80cecf0bf79bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b82fb2a5867a73edb6df57c7490810"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a62b82fb2a5867a73edb6df57c7490810">decryptDecodeComplexMockup</a> (<a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c) const</td></tr>
<tr class="memdesc:a62b82fb2a5867a73edb6df57c7490810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt and decode a mockup ciphertext into a vector of complex vals.  <a href="classhelayers_1_1SealBootstrapUtils.html#a62b82fb2a5867a73edb6df57c7490810">More...</a><br /></td></tr>
<tr class="separator:a62b82fb2a5867a73edb6df57c7490810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e03c8f9db17cff2f958c394ec3307c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a42e03c8f9db17cff2f958c394ec3307c">modInPlace</a> (<a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, double q, bool verbose, int _R=-1) const</td></tr>
<tr class="memdesc:a42e03c8f9db17cff2f958c394ec3307c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mod (cq) over slots using Sin approximation.  <a href="classhelayers_1_1SealBootstrapUtils.html#a42e03c8f9db17cff2f958c394ec3307c">More...</a><br /></td></tr>
<tr class="separator:a42e03c8f9db17cff2f958c394ec3307c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79dc4fa8af96f57f60d6b9f62f9f9ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aa79dc4fa8af96f57f60d6b9f62f9f9ba">modInPlaceForBootstrap</a> (<a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, double q, bool verbose) const</td></tr>
<tr class="memdesc:aa79dc4fa8af96f57f60d6b9f62f9f9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mod (cq) over slots as part of the bootstrap process.  <a href="classhelayers_1_1SealBootstrapUtils.html#aa79dc4fa8af96f57f60d6b9f62f9f9ba">More...</a><br /></td></tr>
<tr class="separator:aa79dc4fa8af96f57f60d6b9f62f9f9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53dbab5d9bf9af61dd4a30356c9f323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aa53dbab5d9bf9af61dd4a30356c9f323">modInPlaceViaPolyEstimate</a> (<a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, double q) const</td></tr>
<tr class="memdesc:aa53dbab5d9bf9af61dd4a30356c9f323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mod (cq) over slots using a polynomial estimation.  <a href="classhelayers_1_1SealBootstrapUtils.html#aa53dbab5d9bf9af61dd4a30356c9f323">More...</a><br /></td></tr>
<tr class="separator:aa53dbab5d9bf9af61dd4a30356c9f323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2469cd5da50685f4fc64bfa91c28589c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a2469cd5da50685f4fc64bfa91c28589c">multiplyAngleInPlace</a> (<a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;cosA, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;sinA, int n) const</td></tr>
<tr class="memdesc:a2469cd5da50685f4fc64bfa91c28589c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given noisy cos/bin of input angle, returns cos/sin of the andle multiplies by n (not used.  <a href="classhelayers_1_1SealBootstrapUtils.html#a2469cd5da50685f4fc64bfa91c28589c">More...</a><br /></td></tr>
<tr class="separator:a2469cd5da50685f4fc64bfa91c28589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0cb5e64367fd36d6c8cc2173d6813f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTile.html">CTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a5d0cb5e64367fd36d6c8cc2173d6813f">pow</a> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, int d) const</td></tr>
<tr class="memdesc:a5d0cb5e64367fd36d6c8cc2173d6813f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raising of a ciphertext by a given power.  <a href="classhelayers_1_1SealBootstrapUtils.html#a5d0cb5e64367fd36d6c8cc2173d6813f">More...</a><br /></td></tr>
<tr class="separator:a5d0cb5e64367fd36d6c8cc2173d6813f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739de746c1004c88c45ba5c002164f3f"><td class="memItemLeft" align="right" valign="top"><a id="a739de746c1004c88c45ba5c002164f3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a739de746c1004c88c45ba5c002164f3f">createRotationDependencyMap</a> ()</td></tr>
<tr class="memdesc:a739de746c1004c88c45ba5c002164f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the dependency graph between rotations where the dependency is a rotation by a power of two. <br /></td></tr>
<tr class="separator:a739de746c1004c88c45ba5c002164f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1596f2da85c5550af51b0755d768652e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a1596f2da85c5550af51b0755d768652e">getAllRotationsOf</a> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, std::vector&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt; &amp;rots) const</td></tr>
<tr class="memdesc:a1596f2da85c5550af51b0755d768652e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the required rotations the given ciphertext.  <a href="classhelayers_1_1SealBootstrapUtils.html#a1596f2da85c5550af51b0755d768652e">More...</a><br /></td></tr>
<tr class="separator:a1596f2da85c5550af51b0755d768652e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1493be00f8269e8f7d0d4f5d28f667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a2b1493be00f8269e8f7d0d4f5d28f667">rotJob</a> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, std::vector&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt; &amp;rots, std::queue&lt; int &gt; &amp;rotJobs, int &amp;jobsLeft, omp_lock_t &amp;queueLock) const</td></tr>
<tr class="memdesc:a2b1493be00f8269e8f7d0d4f5d28f667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation job.  <a href="classhelayers_1_1SealBootstrapUtils.html#a2b1493be00f8269e8f7d0d4f5d28f667">More...</a><br /></td></tr>
<tr class="separator:a2b1493be00f8269e8f7d0d4f5d28f667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295ac184122d75581af5342dc56d8bc3"><td class="memItemLeft" align="right" valign="top"><a id="a295ac184122d75581af5342dc56d8bc3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a295ac184122d75581af5342dc56d8bc3">setRootsOfUnity</a> ()</td></tr>
<tr class="memdesc:a295ac184122d75581af5342dc56d8bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-calculate all the roots of unity expected to be used. <br /></td></tr>
<tr class="separator:a295ac184122d75581af5342dc56d8bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05ce8aafacc27da63653d6e0df8b385"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#af05ce8aafacc27da63653d6e0df8b385">getRootOfUnity</a> (int k)</td></tr>
<tr class="memdesc:af05ce8aafacc27da63653d6e0df8b385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the k'th M'th root of unity.  <a href="classhelayers_1_1SealBootstrapUtils.html#af05ce8aafacc27da63653d6e0df8b385">More...</a><br /></td></tr>
<tr class="separator:af05ce8aafacc27da63653d6e0df8b385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af260c760a4f002eb0ae8dae7d36e7e0f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; std::vector&lt; <a class="el" href="classhelayers_1_1PTile.html">PTile</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#af260c760a4f002eb0ae8dae7d36e7e0f">getEncodedVectorsFromFunctionalMatrix</a> (<a class="el" href="classhelayers_1_1FunctionalMatrix.html">FunctionalMatrix</a> &amp;fm, int chainIndex=-1, double factor=1.0, double scale=-1)</td></tr>
<tr class="memdesc:af260c760a4f002eb0ae8dae7d36e7e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns encoded plaintexts From a functional matrix object.  <a href="classhelayers_1_1SealBootstrapUtils.html#af260c760a4f002eb0ae8dae7d36e7e0f">More...</a><br /></td></tr>
<tr class="separator:af260c760a4f002eb0ae8dae7d36e7e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cfbbc889e7011177f22ea34c1f41e2"><td class="memItemLeft" align="right" valign="top"><a id="a52cfbbc889e7011177f22ea34c1f41e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a52cfbbc889e7011177f22ea34c1f41e2">setEncodingMatrices</a> ()</td></tr>
<tr class="memdesc:a52cfbbc889e7011177f22ea34c1f41e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the encoding matrices. <br /></td></tr>
<tr class="separator:a52cfbbc889e7011177f22ea34c1f41e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b406ba9801b9e72c9734733e0bb5a5"><td class="memItemLeft" align="right" valign="top"><a id="a86b406ba9801b9e72c9734733e0bb5a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a86b406ba9801b9e72c9734733e0bb5a5">setEncodingRealsMatrices</a> ()</td></tr>
<tr class="memdesc:a86b406ba9801b9e72c9734733e0bb5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the encoding matrices when all slots are non-complex. <br /></td></tr>
<tr class="separator:a86b406ba9801b9e72c9734733e0bb5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de37899a15cf6b51472421984de11c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a8de37899a15cf6b51472421984de11c0">powMod</a> (int a, int b, int m)</td></tr>
<tr class="memdesc:a8de37899a15cf6b51472421984de11c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns power under a given modulu (a^b)m in O(log b)  <a href="classhelayers_1_1SealBootstrapUtils.html#a8de37899a15cf6b51472421984de11c0">More...</a><br /></td></tr>
<tr class="separator:a8de37899a15cf6b51472421984de11c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c28b652ede23055df0aea32c6e1e8a2"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a0c28b652ede23055df0aea32c6e1e8a2">zeta</a> (int i, int j)</td></tr>
<tr class="memdesc:a0c28b652ede23055df0aea32c6e1e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the power of the corresponding root of unity (j*(5^i)M)M.  <a href="classhelayers_1_1SealBootstrapUtils.html#a0c28b652ede23055df0aea32c6e1e8a2">More...</a><br /></td></tr>
<tr class="separator:a0c28b652ede23055df0aea32c6e1e8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230893cfbff98c151ecb9478681ced91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1PTile.html">PTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a230893cfbff98c151ecb9478681ced91">getScale1Encoding</a> (std::complex&lt; double &gt; val, int chainIndex=-1) const</td></tr>
<tr class="memdesc:a230893cfbff98c151ecb9478681ced91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoding without scaling (scale=2^0=1)  <a href="classhelayers_1_1SealBootstrapUtils.html#a230893cfbff98c151ecb9478681ced91">More...</a><br /></td></tr>
<tr class="separator:a230893cfbff98c151ecb9478681ced91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1b887009d7c7c6ceff8fb52e6b4648"><td class="memItemLeft" align="right" valign="top"><a id="a1f1b887009d7c7c6ceff8fb52e6b4648"></a>
<a class="el" href="classhelayers_1_1PTile.html">PTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a1f1b887009d7c7c6ceff8fb52e6b4648">encode</a> (int val, int chainIndex=-1, double defaultScale=1.0) const</td></tr>
<tr class="memdesc:a1f1b887009d7c7c6ceff8fb52e6b4648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classhelayers_1_1PTile.html" title="A class representing an encoded (unencrypted) plaintext.">PTile</a> for an integer with specific chain-index and scale. <br /></td></tr>
<tr class="separator:a1f1b887009d7c7c6ceff8fb52e6b4648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14057df39bfa3d6242edf95f2be0233"><td class="memItemLeft" align="right" valign="top"><a id="ae14057df39bfa3d6242edf95f2be0233"></a>
<a class="el" href="classhelayers_1_1PTile.html">PTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ae14057df39bfa3d6242edf95f2be0233">encode</a> (double val, int chainIndex=-1, double defaultScale=1.0) const</td></tr>
<tr class="memdesc:ae14057df39bfa3d6242edf95f2be0233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classhelayers_1_1PTile.html" title="A class representing an encoded (unencrypted) plaintext.">PTile</a> for a double with specific chain-index and scale. <br /></td></tr>
<tr class="separator:ae14057df39bfa3d6242edf95f2be0233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab658797fae4bbbb483cdf34c68586c4e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ab658797fae4bbbb483cdf34c68586c4e">getRequiredScaleOfMultipliedPTile</a> (double inScale, int inLevel, double outLevel) const</td></tr>
<tr class="memdesc:ab658797fae4bbbb483cdf34c68586c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the required ~double scale of a multiplied <a class="el" href="classhelayers_1_1PTile.html" title="A class representing an encoded (unencrypted) plaintext.">PTile</a> object such that the desired scale (on the normal ladder) would result after the product followed by 2 rescales.  <a href="classhelayers_1_1SealBootstrapUtils.html#ab658797fae4bbbb483cdf34c68586c4e">More...</a><br /></td></tr>
<tr class="separator:ab658797fae4bbbb483cdf34c68586c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad901a623fd25c015d1ba55c24c9c4b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTile.html">CTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ad901a623fd25c015d1ba55c24c9c4b46">getMulCipherWithDiagonalizedMatrix</a> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, const std::vector&lt; <a class="el" href="classhelayers_1_1PTile.html">PTile</a> &gt; &amp;m) const</td></tr>
<tr class="memdesc:ad901a623fd25c015d1ba55c24c9c4b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns product of the ciphertext with a given diagonalized matrix.  <a href="classhelayers_1_1SealBootstrapUtils.html#ad901a623fd25c015d1ba55c24c9c4b46">More...</a><br /></td></tr>
<tr class="separator:ad901a623fd25c015d1ba55c24c9c4b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a3cae8047ea0dfecc287b7dd988907"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a>, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a56a3cae8047ea0dfecc287b7dd988907">getMulCipherWithDiagonalizedEncodingMatrix</a> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, const std::vector&lt; <a class="el" href="classhelayers_1_1PTile.html">PTile</a> &gt; &amp;m11) const</td></tr>
<tr class="memdesc:a56a3cae8047ea0dfecc287b7dd988907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns product of the ciphertext with a given diagonalized encoding matrix.  <a href="classhelayers_1_1SealBootstrapUtils.html#a56a3cae8047ea0dfecc287b7dd988907">More...</a><br /></td></tr>
<tr class="separator:a56a3cae8047ea0dfecc287b7dd988907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edc301cab82d90f7d0ca303cb520873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTile.html">CTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a5edc301cab82d90f7d0ca303cb520873">getMulCipherWithDiagonalizedDecodingMatrix</a> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c, const std::vector&lt; <a class="el" href="classhelayers_1_1PTile.html">PTile</a> &gt; &amp;m) const</td></tr>
<tr class="memdesc:a5edc301cab82d90f7d0ca303cb520873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns product of the ciphertext with a given diagonalized decoding matrix.  <a href="classhelayers_1_1SealBootstrapUtils.html#a5edc301cab82d90f7d0ca303cb520873">More...</a><br /></td></tr>
<tr class="separator:a5edc301cab82d90f7d0ca303cb520873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e9947bf5c60e87fb8b78537ae43b4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a>, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a2b3e9947bf5c60e87fb8b78537ae43b4">coef2slotFFT</a> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c) const</td></tr>
<tr class="memdesc:a2b3e9947bf5c60e87fb8b78537ae43b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the coef2slot step over the given ciphertext using FFT.  <a href="classhelayers_1_1SealBootstrapUtils.html#a2b3e9947bf5c60e87fb8b78537ae43b4">More...</a><br /></td></tr>
<tr class="separator:a2b3e9947bf5c60e87fb8b78537ae43b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1749f432f8bf3b39e8d1ec065eb8526"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a>, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aa1749f432f8bf3b39e8d1ec065eb8526">coef2slot</a> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c) const</td></tr>
<tr class="memdesc:aa1749f432f8bf3b39e8d1ec065eb8526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the coef2slot step over the given ciphertext Returns the result in two ciphertext for the two halves of the vector.  <a href="classhelayers_1_1SealBootstrapUtils.html#aa1749f432f8bf3b39e8d1ec065eb8526">More...</a><br /></td></tr>
<tr class="separator:aa1749f432f8bf3b39e8d1ec065eb8526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a19f98f07ad0983649fc42fb1147ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTile.html">CTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ab3a19f98f07ad0983649fc42fb1147ed">slot2coefFFT</a> (const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c) const</td></tr>
<tr class="memdesc:ab3a19f98f07ad0983649fc42fb1147ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of slot2coef step over the given ciphertext.  <a href="classhelayers_1_1SealBootstrapUtils.html#ab3a19f98f07ad0983649fc42fb1147ed">More...</a><br /></td></tr>
<tr class="separator:ab3a19f98f07ad0983649fc42fb1147ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b42106c3197dc1129600acec7035cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelayers_1_1CTile.html">CTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a23b42106c3197dc1129600acec7035cc">slot2coef</a> (<a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c1, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;c2) const</td></tr>
<tr class="memdesc:a23b42106c3197dc1129600acec7035cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of the slot2coef step over the given ciphertexts using FFT.  <a href="classhelayers_1_1SealBootstrapUtils.html#a23b42106c3197dc1129600acec7035cc">More...</a><br /></td></tr>
<tr class="separator:a23b42106c3197dc1129600acec7035cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8e9c16ded7f9ab94a0db5293edb2018b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a8e9c16ded7f9ab94a0db5293edb2018b">getExpectedBSCost</a> (const <a class="el" href="classhelayers_1_1BootstrapConfig.html">BootstrapConfig</a> &amp;<a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ab37ab3318e5931b09183f185a2a43c3b">bc</a>, int <a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a0985508c40073ac982bec89c9d316022">SC</a>)</td></tr>
<tr class="memdesc:a8e9c16ded7f9ab94a0db5293edb2018b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of products expected in the bootstrap process.  <a href="classhelayers_1_1SealBootstrapUtils.html#a8e9c16ded7f9ab94a0db5293edb2018b">More...</a><br /></td></tr>
<tr class="separator:a8e9c16ded7f9ab94a0db5293edb2018b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8facd9ae7da531368fb0cdf050a527f"><td class="memItemLeft" align="right" valign="top"><a id="ae8facd9ae7da531368fb0cdf050a527f"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ae8facd9ae7da531368fb0cdf050a527f">getDefaultExpectedBSCost</a> ()</td></tr>
<tr class="memdesc:ae8facd9ae7da531368fb0cdf050a527f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default expected number of products expected in the bootstrap process assuming a default <a class="el" href="classhelayers_1_1BootstrapConfig.html" title="A configuration of the Bootstrap process via various parameter setups.">BootstrapConfig</a>, and ignoring the number of slots. <br /></td></tr>
<tr class="separator:ae8facd9ae7da531368fb0cdf050a527f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63463d728cdb638dafd3c28d24f10287"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a63463d728cdb638dafd3c28d24f10287">computeR</a> (int <a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a0985508c40073ac982bec89c9d316022">SC</a>)</td></tr>
<tr class="memdesc:a63463d728cdb638dafd3c28d24f10287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the R parameter of the bootstrap process, that is, the part of the factor that shrinks down the value in the slots as a preparation to the Sin step of the bootstrap.  <a href="classhelayers_1_1SealBootstrapUtils.html#a63463d728cdb638dafd3c28d24f10287">More...</a><br /></td></tr>
<tr class="separator:a63463d728cdb638dafd3c28d24f10287"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab37ab3318e5931b09183f185a2a43c3b"><td class="memItemLeft" align="right" valign="top"><a id="ab37ab3318e5931b09183f185a2a43c3b"></a>
<a class="el" href="classhelayers_1_1BootstrapConfig.html">BootstrapConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ab37ab3318e5931b09183f185a2a43c3b">bc</a></td></tr>
<tr class="memdesc:ab37ab3318e5931b09183f185a2a43c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration of the bootstrap process. <br /></td></tr>
<tr class="separator:ab37ab3318e5931b09183f185a2a43c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76341d1baccb23c5fd9d8672cb756bf3"><td class="memItemLeft" align="right" valign="top"><a id="a76341d1baccb23c5fd9d8672cb756bf3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a76341d1baccb23c5fd9d8672cb756bf3">cost</a></td></tr>
<tr class="memdesc:a76341d1baccb23c5fd9d8672cb756bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">expected depth of computation needed to perform the bootstrap <br /></td></tr>
<tr class="separator:a76341d1baccb23c5fd9d8672cb756bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0985508c40073ac982bec89c9d316022"><td class="memItemLeft" align="right" valign="top"><a id="a0985508c40073ac982bec89c9d316022"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a0985508c40073ac982bec89c9d316022">SC</a></td></tr>
<tr class="memdesc:a0985508c40073ac982bec89c9d316022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of slots. <br /></td></tr>
<tr class="separator:a0985508c40073ac982bec89c9d316022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab176a9158771ae5d8f96ce9f7f3beaeb"><td class="memItemLeft" align="right" valign="top"><a id="ab176a9158771ae5d8f96ce9f7f3beaeb"></a>
std::vector&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ab176a9158771ae5d8f96ce9f7f3beaeb">cos_coefs</a></td></tr>
<tr class="memdesc:ab176a9158771ae5d8f96ce9f7f3beaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coeffs of cos approximation polynomial. <br /></td></tr>
<tr class="separator:ab176a9158771ae5d8f96ce9f7f3beaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22a793f611b856e222c2b7b658b6715"><td class="memItemLeft" align="right" valign="top"><a id="ae22a793f611b856e222c2b7b658b6715"></a>
std::vector&lt; long double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#ae22a793f611b856e222c2b7b658b6715">sin_coefs</a></td></tr>
<tr class="memdesc:ae22a793f611b856e222c2b7b658b6715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coeffs of sin approximation polynomial. <br /></td></tr>
<tr class="separator:ae22a793f611b856e222c2b7b658b6715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add85069cb6ee1b47d0c96890c32fb757"><td class="memItemLeft" align="right" valign="top"><a id="add85069cb6ee1b47d0c96890c32fb757"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#add85069cb6ee1b47d0c96890c32fb757">dependentRotation</a></td></tr>
<tr class="memdesc:add85069cb6ee1b47d0c96890c32fb757"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rotation upon which this rotation depends. <br /></td></tr>
<tr class="separator:add85069cb6ee1b47d0c96890c32fb757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2625f0510d3df574dc94ad56ff3d331f"><td class="memItemLeft" align="right" valign="top"><a id="a2625f0510d3df574dc94ad56ff3d331f"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a2625f0510d3df574dc94ad56ff3d331f">dependentRotationDelta</a></td></tr>
<tr class="memdesc:a2625f0510d3df574dc94ad56ff3d331f"><td class="mdescLeft">&#160;</td><td class="mdescRight">How much to rotate the source rotation to get this target rotation. <br /></td></tr>
<tr class="separator:a2625f0510d3df574dc94ad56ff3d331f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766fefbe37f49ad9021fbb5a1927f28a"><td class="memItemLeft" align="right" valign="top"><a id="a766fefbe37f49ad9021fbb5a1927f28a"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a766fefbe37f49ad9021fbb5a1927f28a">dependentRotationDepth</a></td></tr>
<tr class="memdesc:a766fefbe37f49ad9021fbb5a1927f28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth in the BFS order of the rotation. <br /></td></tr>
<tr class="separator:a766fefbe37f49ad9021fbb5a1927f28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8eb1829d1802d9a0a7efd041838a60"><td class="memItemLeft" align="right" valign="top"><a id="a4a8eb1829d1802d9a0a7efd041838a60"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a4a8eb1829d1802d9a0a7efd041838a60">rotsOfDepth</a></td></tr>
<tr class="memdesc:a4a8eb1829d1802d9a0a7efd041838a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotations needed at the corresponding depth of dependency in the BFS rotation computation order. <br /></td></tr>
<tr class="separator:a4a8eb1829d1802d9a0a7efd041838a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3c80ac44b8f5e63972358ecf4bd5d5"><td class="memItemLeft" align="right" valign="top"><a id="a9f3c80ac44b8f5e63972358ecf4bd5d5"></a>
std::shared_ptr&lt; <a class="el" href="classhelayers_1_1FFTUtils.html">FFTUtils</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a9f3c80ac44b8f5e63972358ecf4bd5d5">fft</a></td></tr>
<tr class="memdesc:a9f3c80ac44b8f5e63972358ecf4bd5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classhelayers_1_1FFTUtils.html" title="A class with utilities for computing the the coef2slot matrix multiplication using FFT.">FFTUtils</a> object for performing the FFT steps of the bootstrap. <br /></td></tr>
<tr class="separator:a9f3c80ac44b8f5e63972358ecf4bd5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e004f0002769e8114ce5323f385da64"><td class="memItemLeft" align="right" valign="top"><a id="a3e004f0002769e8114ce5323f385da64"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a3e004f0002769e8114ce5323f385da64">R</a></td></tr>
<tr class="memdesc:a3e004f0002769e8114ce5323f385da64"><td class="mdescLeft">&#160;</td><td class="mdescRight">R is part of the factor that shrinks down the value in the slots as a preparation to the Sin step of the bootstrap. <br /></td></tr>
<tr class="separator:a3e004f0002769e8114ce5323f385da64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cffd3dbb0e70a08025f44bd5499c5d5"><td class="memItemLeft" align="right" valign="top"><a id="a5cffd3dbb0e70a08025f44bd5499c5d5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a5cffd3dbb0e70a08025f44bd5499c5d5">r1</a> = -1</td></tr>
<tr class="memdesc:a5cffd3dbb0e70a08025f44bd5499c5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">r1 will be init to 2/qR and used as a factor for the coef2slot matrix, except for some tests when r1 should have no effect. <br /></td></tr>
<tr class="separator:a5cffd3dbb0e70a08025f44bd5499c5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719d9fc078015ad16a00cd2d65d0ea01"><td class="memItemLeft" align="right" valign="top"><a id="a719d9fc078015ad16a00cd2d65d0ea01"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a719d9fc078015ad16a00cd2d65d0ea01">encodingFactor</a> = -1</td></tr>
<tr class="memdesc:a719d9fc078015ad16a00cd2d65d0ea01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The factor to multiply the values by before the encode/coef2slot step. <br /></td></tr>
<tr class="separator:a719d9fc078015ad16a00cd2d65d0ea01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e545ea1e14a9ebdd18262432a8d9b44"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a2e545ea1e14a9ebdd18262432a8d9b44">coef2slotEncodingScale</a> = -1</td></tr>
<tr class="memdesc:a2e545ea1e14a9ebdd18262432a8d9b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scale used for the encoding carried out during coef2slot.  <a href="classhelayers_1_1SealBootstrapUtils.html#a2e545ea1e14a9ebdd18262432a8d9b44">More...</a><br /></td></tr>
<tr class="separator:a2e545ea1e14a9ebdd18262432a8d9b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf68d1d61cc6dc9de91fdb8ac955465"><td class="memItemLeft" align="right" valign="top"><a id="abdf68d1d61cc6dc9de91fdb8ac955465"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#abdf68d1d61cc6dc9de91fdb8ac955465">r2</a> = -1</td></tr>
<tr class="memdesc:abdf68d1d61cc6dc9de91fdb8ac955465"><td class="mdescLeft">&#160;</td><td class="mdescRight">r2 will be init to q/2Pi and used as a factor for the slot2coed matrix, except for some tests when r2 should have no effect. <br /></td></tr>
<tr class="separator:abdf68d1d61cc6dc9de91fdb8ac955465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf65a42485f75b93518c9dd5fffed1d5"><td class="memItemLeft" align="right" valign="top"><a id="abf65a42485f75b93518c9dd5fffed1d5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#abf65a42485f75b93518c9dd5fffed1d5">decodingFactor</a> = -1</td></tr>
<tr class="memdesc:abf65a42485f75b93518c9dd5fffed1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The factor to multiply the values by before the decode/slot2coef step. <br /></td></tr>
<tr class="separator:abf65a42485f75b93518c9dd5fffed1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02926d5e17e0056c55ba98b8849ecf8"><td class="memItemLeft" align="right" valign="top"><a id="aa02926d5e17e0056c55ba98b8849ecf8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aa02926d5e17e0056c55ba98b8849ecf8">targetChainIndex</a></td></tr>
<tr class="memdesc:aa02926d5e17e0056c55ba98b8849ecf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final chain index to target the bootstrap process at. <br /></td></tr>
<tr class="separator:aa02926d5e17e0056c55ba98b8849ecf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab240e77b160f3132f315f847f822666"><td class="memItemLeft" align="right" valign="top"><a id="aab240e77b160f3132f315f847f822666"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#aab240e77b160f3132f315f847f822666">encodingChainIndex</a></td></tr>
<tr class="memdesc:aab240e77b160f3132f315f847f822666"><td class="mdescLeft">&#160;</td><td class="mdescRight">The chain index at the encoding/coef2slot step of the bootstrap. <br /></td></tr>
<tr class="separator:aab240e77b160f3132f315f847f822666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b82235aa0ce0f7179577a44a4cf138f"><td class="memItemLeft" align="right" valign="top"><a id="a2b82235aa0ce0f7179577a44a4cf138f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a2b82235aa0ce0f7179577a44a4cf138f">decodingChainIndex</a></td></tr>
<tr class="memdesc:a2b82235aa0ce0f7179577a44a4cf138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The chain index at the decoding/slot2coef step of the bootstrap. <br /></td></tr>
<tr class="separator:a2b82235aa0ce0f7179577a44a4cf138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bac226f34e6783c7ce5f24ce4216dc"><td class="memItemLeft" align="right" valign="top"><a id="a77bac226f34e6783c7ce5f24ce4216dc"></a>
std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a77bac226f34e6783c7ce5f24ce4216dc">oneDivN</a></td></tr>
<tr class="memdesc:a77bac226f34e6783c7ce5f24ce4216dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">1/N (N being 2*numSlots) <br /></td></tr>
<tr class="separator:a77bac226f34e6783c7ce5f24ce4216dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328bd4ac9b97b1e45050de9d8f25336f"><td class="memItemLeft" align="right" valign="top"><a id="a328bd4ac9b97b1e45050de9d8f25336f"></a>
std::shared_ptr&lt; std::vector&lt; std::complex&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a328bd4ac9b97b1e45050de9d8f25336f">zMinusIDiv2</a></td></tr>
<tr class="memdesc:a328bd4ac9b97b1e45050de9d8f25336f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector with all entries = -i/2. <br /></td></tr>
<tr class="separator:a328bd4ac9b97b1e45050de9d8f25336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2ccf66d1d30006a6a75e6cbe8de88ef5"><td class="memItemLeft" align="right" valign="top"><a id="a2ccf66d1d30006a6a75e6cbe8de88ef5"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelayers_1_1SealBootstrapUtils.html#a2ccf66d1d30006a6a75e6cbe8de88ef5">defaultTargetChainIndex</a> = 4</td></tr>
<tr class="memdesc:a2ccf66d1d30006a6a75e6cbe8de88ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default target chain index. <br /></td></tr>
<tr class="separator:a2ccf66d1d30006a6a75e6cbe8de88ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class with various utility methods for performing CKKS bootstrapping. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af317b376af9344d32304afa99c5698ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af317b376af9344d32304afa99c5698ad">&#9670;&nbsp;</a></span>SealBootstrapUtils() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::SealBootstrapUtils::SealBootstrapUtils </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1BootstrapConfig.html">BootstrapConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>firstMod</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Bootstrap Utils object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the HE context </td></tr>
    <tr><td class="paramname">bc</td><td>the bootstrap configuration </td></tr>
    <tr><td class="paramname">firstMod</td><td>the first prime in the prime-chain. 0 =&gt; automatically deduce the first prime form the HE context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a692fc13e11213a41d1f44e50f91187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a692fc13e11213a41d1f44e50f91187">&#9670;&nbsp;</a></span>SealBootstrapUtils() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">helayers::SealBootstrapUtils::SealBootstrapUtils </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1HeContext.html">HeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classhelayers_1_1SealBootstrapUtils.html" title="A class with various utility methods for performing CKKS bootstrapping.">SealBootstrapUtils</a> object using a given HE context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the HE context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa1749f432f8bf3b39e8d1ec065eb8526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1749f432f8bf3b39e8d1ec065eb8526">&#9670;&nbsp;</a></span>coef2slot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a>, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt; helayers::SealBootstrapUtils::coef2slot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the coef2slot step over the given ciphertext Returns the result in two ciphertext for the two halves of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the transformed ciphertext </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b3e9947bf5c60e87fb8b78537ae43b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3e9947bf5c60e87fb8b78537ae43b4">&#9670;&nbsp;</a></span>coef2slotFFT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a>, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt; helayers::SealBootstrapUtils::coef2slotFFT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the coef2slot step over the given ciphertext using FFT. </p>
<p>Returns the result in two ciphertext for the two halves of the vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the transformed ciphertext </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63463d728cdb638dafd3c28d24f10287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63463d728cdb638dafd3c28d24f10287">&#9670;&nbsp;</a></span>computeR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int helayers::SealBootstrapUtils::computeR </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the R parameter of the bootstrap process, that is, the part of the factor that shrinks down the value in the slots as a preparation to the Sin step of the bootstrap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SC</td><td>the number of slots in a ciphertext </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62b82fb2a5867a73edb6df57c7490810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b82fb2a5867a73edb6df57c7490810">&#9670;&nbsp;</a></span>decryptDecodeComplexMockup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; complex&lt; double &gt; &gt; helayers::SealBootstrapUtils::decryptDecodeComplexMockup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt and decode a mockup ciphertext into a vector of complex vals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the ciphertext to decryp and decode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1596f2da85c5550af51b0755d768652e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1596f2da85c5550af51b0755d768652e">&#9670;&nbsp;</a></span>getAllRotationsOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::getAllRotationsOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the required rotations the given ciphertext. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the ciphertext to rotate </td></tr>
    <tr><td class="paramname">rots</td><td>the resulting rotations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af260c760a4f002eb0ae8dae7d36e7e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af260c760a4f002eb0ae8dae7d36e7e0f">&#9670;&nbsp;</a></span>getEncodedVectorsFromFunctionalMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; vector&lt; <a class="el" href="classhelayers_1_1PTile.html">PTile</a> &gt; &gt; helayers::SealBootstrapUtils::getEncodedVectorsFromFunctionalMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1FunctionalMatrix.html">FunctionalMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>fm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chainIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns encoded plaintexts From a functional matrix object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>the functional-matrix to extract the plaintexts from </td></tr>
    <tr><td class="paramname">chainIndex</td><td>the chain-index ot encode in </td></tr>
    <tr><td class="paramname">factor</td><td>a factor to multiply all the values by </td></tr>
    <tr><td class="paramname">scale</td><td>the encoding scale </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e9c16ded7f9ab94a0db5293edb2018b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9c16ded7f9ab94a0db5293edb2018b">&#9670;&nbsp;</a></span>getExpectedBSCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int helayers::SealBootstrapUtils::getExpectedBSCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1BootstrapConfig.html">BootstrapConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of products expected in the bootstrap process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bc</td><td>the bootstrap configuration </td></tr>
    <tr><td class="paramname">SC</td><td>the number of slots </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5edc301cab82d90f7d0ca303cb520873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edc301cab82d90f7d0ca303cb520873">&#9670;&nbsp;</a></span>getMulCipherWithDiagonalizedDecodingMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> helayers::SealBootstrapUtils::getMulCipherWithDiagonalizedDecodingMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelayers_1_1PTile.html">PTile</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns product of the ciphertext with a given diagonalized decoding matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the cipher to multiply </td></tr>
    <tr><td class="paramname">m</td><td>the matrix to multiply by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56a3cae8047ea0dfecc287b7dd988907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a3cae8047ea0dfecc287b7dd988907">&#9670;&nbsp;</a></span>getMulCipherWithDiagonalizedEncodingMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a>, <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt; helayers::SealBootstrapUtils::getMulCipherWithDiagonalizedEncodingMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelayers_1_1PTile.html">PTile</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m11</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns product of the ciphertext with a given diagonalized encoding matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the cipher to multiply </td></tr>
    <tr><td class="paramname">m</td><td>the matrix to multiply by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad901a623fd25c015d1ba55c24c9c4b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad901a623fd25c015d1ba55c24c9c4b46">&#9670;&nbsp;</a></span>getMulCipherWithDiagonalizedMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> helayers::SealBootstrapUtils::getMulCipherWithDiagonalizedMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelayers_1_1PTile.html">PTile</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns product of the ciphertext with a given diagonalized matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the cipher to multiply </td></tr>
    <tr><td class="paramname">m</td><td>the matrix to multiply by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab658797fae4bbbb483cdf34c68586c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab658797fae4bbbb483cdf34c68586c4e">&#9670;&nbsp;</a></span>getRequiredScaleOfMultipliedPTile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helayers::SealBootstrapUtils::getRequiredScaleOfMultipliedPTile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the required ~double scale of a multiplied <a class="el" href="classhelayers_1_1PTile.html" title="A class representing an encoded (unencrypted) plaintext.">PTile</a> object such that the desired scale (on the normal ladder) would result after the product followed by 2 rescales. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inScale</td><td>input scale of multiplied ciphertext </td></tr>
    <tr><td class="paramname">inLevel</td><td>input level of multiplied ciphertext (may deviate from the normal scales ladder) </td></tr>
    <tr><td class="paramname">outLevel</td><td>the targeted output level after the product and 2 rescales </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af05ce8aafacc27da63653d6e0df8b385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05ce8aafacc27da63653d6e0df8b385">&#9670;&nbsp;</a></span>getRootOfUnity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; helayers::SealBootstrapUtils::getRootOfUnity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the k'th M'th root of unity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a230893cfbff98c151ecb9478681ced91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230893cfbff98c151ecb9478681ced91">&#9670;&nbsp;</a></span>getScale1Encoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1PTile.html">PTile</a> helayers::SealBootstrapUtils::getScale1Encoding </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; double &gt;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chainIndex</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an encoding without scaling (scale=2^0=1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the values to encode </td></tr>
    <tr><td class="paramname">chainIndex</td><td>the chain index to encode in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42e03c8f9db17cff2f958c394ec3307c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e03c8f9db17cff2f958c394ec3307c">&#9670;&nbsp;</a></span>modInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::modInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_R</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mod (cq) over slots using Sin approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the ciphertext with the slots to compute the mod on </td></tr>
    <tr><td class="paramname">q</td><td>the mod </td></tr>
    <tr><td class="paramname">verbose</td><td></td></tr>
    <tr><td class="paramname">_R</td><td>factor. -1 =&gt; use R field of this <a class="el" href="classhelayers_1_1SealBootstrapUtils.html" title="A class with various utility methods for performing CKKS bootstrapping.">SealBootstrapUtils</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa79dc4fa8af96f57f60d6b9f62f9f9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79dc4fa8af96f57f60d6b9f62f9f9ba">&#9670;&nbsp;</a></span>modInPlaceForBootstrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::modInPlaceForBootstrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mod (cq) over slots as part of the bootstrap process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the ciphertext with the slots to compute the mod on </td></tr>
    <tr><td class="paramname">q</td><td>the mod </td></tr>
    <tr><td class="paramname">verbose</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa53dbab5d9bf9af61dd4a30356c9f323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53dbab5d9bf9af61dd4a30356c9f323">&#9670;&nbsp;</a></span>modInPlaceViaPolyEstimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::modInPlaceViaPolyEstimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mod (cq) over slots using a polynomial estimation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the ciphertext with the slots to compute the mod on </td></tr>
    <tr><td class="paramname">q</td><td>the mod (1st prime in the chain) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2469cd5da50685f4fc64bfa91c28589c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2469cd5da50685f4fc64bfa91c28589c">&#9670;&nbsp;</a></span>multiplyAngleInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::multiplyAngleInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>cosA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>sinA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given noisy cos/bin of input angle, returns cos/sin of the andle multiplies by n (not used. </p>
<p>consider removing) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cosA</td><td>cos of input angle (noisy) </td></tr>
    <tr><td class="paramname">sinA</td><td>sin of input angle (noisy) </td></tr>
    <tr><td class="paramname">n</td><td>required multiple of input angle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef9f9a6fb925ad0539e29a7f7f841603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9f9a6fb925ad0539e29a7f7f841603">&#9670;&nbsp;</a></span>polyEval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> helayers::SealBootstrapUtils::polyEval </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns evaluation of a polynomial over a ciphertext. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>coeffs of polynomial </td></tr>
    <tr><td class="paramname">c</td><td>encrypted value to set the polynomial variable to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391e7d930ffe840159b853e6edc850ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391e7d930ffe840159b853e6edc850ea">&#9670;&nbsp;</a></span>polyEvalCoefFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> helayers::SealBootstrapUtils::polyEvalCoefFirst </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns evaluation of a polynomial over a ciphertext term by term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>coeffs of polynomial </td></tr>
    <tr><td class="paramname">c</td><td>encrypted value to set the polynomial variable to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ca20700bf93274d5c9fe171a67aae6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca20700bf93274d5c9fe171a67aae6d">&#9670;&nbsp;</a></span>polyEvalHorner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> helayers::SealBootstrapUtils::polyEvalHorner </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns evaluation of a polynomial over a ciphertext using Horner's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>coeffs of polynomial </td></tr>
    <tr><td class="paramname">c</td><td>encrypted value to set the polynomial variable to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add9869959ff3b0548d5b5f3dedef901c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9869959ff3b0548d5b5f3dedef901c">&#9670;&nbsp;</a></span>polyEvalInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::polyEvalInPlace </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a polynomial over a ciphertext (DFS method) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>coeffs of polynomial </td></tr>
    <tr><td class="paramname">c</td><td>encrypted value to set the polynomial variable to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dd7c041640a34768f14af5d9378535d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd7c041640a34768f14af5d9378535d">&#9670;&nbsp;</a></span>polyEvalInPlace2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::polyEvalInPlace2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a polynomial over a ciphertext (with powers cache) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>coeffs of polynomial </td></tr>
    <tr><td class="paramname">c</td><td>encrypted value to set the polynomial variable to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78da89b9c29a65c5ac4166a255b08c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78da89b9c29a65c5ac4166a255b08c9c">&#9670;&nbsp;</a></span>polyEvalPlainHorner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helayers::SealBootstrapUtils::polyEvalPlainHorner </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns evaluation of a polynomial over plain value using Horner's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>coeffs of polynomial </td></tr>
    <tr><td class="paramname">v</td><td>value to set the polynomial variable to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d0cb5e64367fd36d6c8cc2173d6813f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0cb5e64367fd36d6c8cc2173d6813f">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> helayers::SealBootstrapUtils::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the raising of a ciphertext by a given power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the ciphertext to raise </td></tr>
    <tr><td class="paramname">d</td><td>the power </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadc34094aa9ee8a4d8a2227bc366712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc34094aa9ee8a4d8a2227bc366712b">&#9670;&nbsp;</a></span>powInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::powInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise ciphertext to given power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>ciphertext to raise </td></tr>
    <tr><td class="paramname">d</td><td>the power to raise by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8de37899a15cf6b51472421984de11c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de37899a15cf6b51472421984de11c0">&#9670;&nbsp;</a></span>powMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int helayers::SealBootstrapUtils::powMod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns power under a given modulu (a^b)m in O(log b) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>base </td></tr>
    <tr><td class="paramname">b</td><td>power </td></tr>
    <tr><td class="paramname">m</td><td>modulus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebf2480e46547f8bde233bf848253e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf2480e46547f8bde233bf848253e2b">&#9670;&nbsp;</a></span>printSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::printSignature </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print signature of Bootstrap process configuration to output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b1493be00f8269e8f7d0d4f5d28f667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1493be00f8269e8f7d0d4f5d28f667">&#9670;&nbsp;</a></span>rotJob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helayers::SealBootstrapUtils::rotJob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rotJobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>jobsLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">omp_lock_t &amp;&#160;</td>
          <td class="paramname"><em>queueLock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotation job. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the ciphertext to rotate </td></tr>
    <tr><td class="paramname">rots</td><td>the resulting rotations </td></tr>
    <tr><td class="paramname">rotJobs</td><td>the queue of remaining rotation jobs </td></tr>
    <tr><td class="paramname">jobsLeft</td><td>number of jobs left </td></tr>
    <tr><td class="paramname">queueLock</td><td>semaphore for accesses to shared storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba8001231ccb7f547b80cecf0bf79bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8001231ccb7f547b80cecf0bf79bc2">&#9670;&nbsp;</a></span>searchMods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helayers::SealBootstrapUtils::searchMods </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numZsteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search various mod configurations. </p>
<p>Used by corresponding test. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the mod </td></tr>
    <tr><td class="paramname">Z</td><td>the max value to mod </td></tr>
    <tr><td class="paramname">M</td><td>expected number of q-s that will drop </td></tr>
    <tr><td class="paramname">R</td><td>factor </td></tr>
    <tr><td class="paramname">numZsteps</td><td>number of Zs to test </td></tr>
    <tr><td class="paramname">outfilename</td><td>file to save the results in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23b42106c3197dc1129600acec7035cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b42106c3197dc1129600acec7035cc">&#9670;&nbsp;</a></span>slot2coef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> helayers::SealBootstrapUtils::slot2coef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of the slot2coef step over the given ciphertexts using FFT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>the 1st half of the vector </td></tr>
    <tr><td class="paramname">c2</td><td>the 2nd part of the vector - only used when supporting complex slots </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3a19f98f07ad0983649fc42fb1147ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a19f98f07ad0983649fc42fb1147ed">&#9670;&nbsp;</a></span>slot2coefFFT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelayers_1_1CTile.html">CTile</a> helayers::SealBootstrapUtils::slot2coefFFT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelayers_1_1CTile.html">CTile</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of slot2coef step over the given ciphertext. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the 1st half of the vector the 2nd half is deduced because we assume non complex slots here </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c28b652ede23055df0aea32c6e1e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c28b652ede23055df0aea32c6e1e8a2">&#9670;&nbsp;</a></span>zeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">complex&lt; double &gt; helayers::SealBootstrapUtils::zeta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the power of the corresponding root of unity (j*(5^i)M)M. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>row </td></tr>
    <tr><td class="paramname">j</td><td>column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2e545ea1e14a9ebdd18262432a8d9b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e545ea1e14a9ebdd18262432a8d9b44">&#9670;&nbsp;</a></span>coef2slotEncodingScale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helayers::SealBootstrapUtils::coef2slotEncodingScale = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The scale used for the encoding carried out during coef2slot. </p>
<p>This also equals the ciphertext scale at the entry to coef2slot. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/helayers/math/bootstrap/seal/<a class="el" href="SealBootstrapUtils_8h_source.html">SealBootstrapUtils.h</a></li>
<li>src/helayers/math/bootstrap/seal/SealBootstrapUtils.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
